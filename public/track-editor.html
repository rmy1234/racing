<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>íŠ¸ë™ í¸ì§‘ê¸° - ê°œë°œìš©</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Courier New', monospace;
      background: #1a1a1a;
      color: #fff;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      height: 100vh;
    }

    .header {
      background: #2a2a2a;
      padding: 10px 20px;
      border-bottom: 2px solid #444;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .header h1 {
      font-size: 18px;
      color: #00ff88;
    }

    .controls {
      display: flex;
      gap: 10px;
    }

    button {
      padding: 8px 16px;
      background: #333;
      color: #fff;
      border: 1px solid #555;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
    }

    button:hover {
      background: #444;
    }

    button.active {
      background: #00ff88;
      color: #000;
    }

    button.danger {
      background: #ff3366;
    }

    .main-container {
      display: flex;
      flex: 1;
      overflow: hidden;
    }

    .canvas-container {
      flex: 1;
      position: relative;
      background: #0a0a0a;
      overflow: hidden;
    }
    
    .minimap {
      position: absolute;
      top: 10px;
      right: 10px;
      width: 200px;
      height: 150px;
      background: rgba(42, 42, 42, 0.9);
      border: 2px solid #555;
      border-radius: 4px;
      z-index: 100;
      cursor: crosshair;
    }
    
    #minimapCanvas {
      width: 100%;
      height: 100%;
      display: block;
    }
    
    .zoom-controls {
      position: absolute;
      bottom: 10px;
      right: 10px;
      display: flex;
      flex-direction: column;
      gap: 5px;
      z-index: 100;
    }
    
    .zoom-controls button {
      width: 40px;
      height: 40px;
      padding: 0;
      font-size: 18px;
      background: rgba(42, 42, 42, 0.9);
      border: 1px solid #555;
    }

    #editorCanvas {
      display: block;
      cursor: crosshair;
      width: 100%;
      height: 100%;
      image-rendering: pixelated;
    }

    .sidebar {
      width: 350px;
      background: #2a2a2a;
      border-left: 2px solid #444;
      overflow-y: auto;
      padding: 20px;
    }

    .section {
      margin-bottom: 20px;
      padding: 15px;
      background: #333;
      border-radius: 6px;
    }

    .section h3 {
      font-size: 14px;
      margin-bottom: 10px;
      color: #00ff88;
      border-bottom: 1px solid #555;
      padding-bottom: 5px;
    }

    .input-group {
      margin-bottom: 10px;
    }

    .input-group label {
      display: block;
      font-size: 11px;
      color: #aaa;
      margin-bottom: 4px;
    }

    .input-group input {
      width: 100%;
      padding: 6px;
      background: #1a1a1a;
      color: #fff;
      border: 1px solid #555;
      border-radius: 4px;
      font-size: 12px;
    }

    .point-list {
      max-height: 200px;
      overflow-y: auto;
      margin-top: 10px;
    }

    .point-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 6px;
      background: #1a1a1a;
      margin-bottom: 4px;
      border-radius: 4px;
      font-size: 11px;
    }

    .point-item:hover {
      background: #2a2a2a;
    }

    .point-item.selected {
      background: #00ff8833;
      border: 1px solid #00ff88;
    }

    .point-coords {
      color: #aaa;
      font-family: monospace;
    }

    .point-actions {
      display: flex;
      gap: 4px;
    }

    .point-actions button {
      padding: 2px 6px;
      font-size: 10px;
    }

    .code-output {
      width: 100%;
      height: 300px;
      padding: 10px;
      background: #1a1a1a;
      color: #00ff88;
      border: 1px solid #555;
      border-radius: 4px;
      font-family: 'Courier New', monospace;
      font-size: 11px;
      resize: vertical;
    }

    .info {
      font-size: 11px;
      color: #aaa;
      margin-top: 10px;
      padding: 10px;
      background: #1a1a1a;
      border-radius: 4px;
      line-height: 1.6;
    }

    .toolbar {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(42, 42, 42, 0.9);
      padding: 10px;
      border-radius: 6px;
      display: flex;
      gap: 8px;
      z-index: 100;
    }

    .toolbar button {
      padding: 6px 12px;
      font-size: 11px;
    }

    .status {
      position: absolute;
      bottom: 10px;
      left: 10px;
      background: rgba(42, 42, 42, 0.9);
      padding: 8px 12px;
      border-radius: 4px;
      font-size: 11px;
      color: #aaa;
    }
  </style>
  <!-- íŠ¸ë™ íŒŒì¼ ë¯¸ë¦¬ ë¡œë“œ -->
  <script src="/js/track.js"></script>
  <script src="/js/tracks/basic-circuit.js"></script>
  <script src="/js/tracks/monza.js"></script>
</head>
<body>
    <div class="header">
      <h1>ğŸ íŠ¸ë™ í¸ì§‘ê¸° (ê°œë°œìš©)</h1>
      <div class="controls">
        <button id="backToGameBtn" onclick="window.location.href='/'">â† ê²Œì„ìœ¼ë¡œ</button>
        <button id="newTrackBtn" style="background: #00d4ff; color: #000;">ìƒˆ íŠ¸ë™</button>
        <button id="loadTrackBtn">íŠ¸ë™ ë¡œë“œ</button>
        <button id="saveTrackBtn">ì½”ë“œ ë³µì‚¬</button>
        <button id="clearBtn" class="danger">ì´ˆê¸°í™”</button>
      </div>
    </div>

  <div class="main-container">
    <div class="canvas-container">
      <div class="toolbar">
        <button id="addModeBtn" class="active">â• í¬ì¸íŠ¸ ì¶”ê°€</button>
        <button id="moveModeBtn">â†”ï¸ í¬ì¸íŠ¸ ì´ë™</button>
        <button id="deleteModeBtn">âœ–ï¸ í¬ì¸íŠ¸ ì‚­ì œ</button>
        <button id="addCheckpointBtn">ğŸ ì²´í¬í¬ì¸íŠ¸ ì¶”ê°€</button>
        <button id="moveCheckpointBtn">â†”ï¸ ì²´í¬í¬ì¸íŠ¸ ì´ë™</button>
        <button id="deleteCheckpointBtn">âœ–ï¸ ì²´í¬í¬ì¸íŠ¸ ì‚­ì œ</button>
        <button id="addKerbBtn">ğŸŸ¦ ì—°ì„ ì¶”ê°€</button>
        <button id="moveKerbBtn">â†”ï¸ ì—°ì„ ì´ë™</button>
        <button id="deleteKerbBtn">âœ–ï¸ ì—°ì„ ì‚­ì œ</button>
        <button id="previewBtn">ğŸ‘ï¸ ë¯¸ë¦¬ë³´ê¸°</button>
      </div>
      <canvas id="editorCanvas" width="1200" height="800"></canvas>
      <div class="status" id="status">ëª¨ë“œ: í¬ì¸íŠ¸ ì¶”ê°€ | í¬ì¸íŠ¸: 0ê°œ</div>
      <div class="minimap">
        <canvas id="minimapCanvas"></canvas>
      </div>
      <div class="zoom-controls">
        <button id="zoomInBtn" title="í™•ëŒ€">+</button>
        <button id="zoomOutBtn" title="ì¶•ì†Œ">-</button>
        <button id="resetViewBtn" title="ë·° ë¦¬ì…‹">âŒ‚</button>
      </div>
    </div>

    <div class="sidebar">
      <div class="section">
        <h3>íŠ¸ë™ ì •ë³´</h3>
        <div class="input-group">
          <label>íŠ¸ë™ ì´ë¦„</label>
          <input type="text" id="trackName" value="ìƒˆ íŠ¸ë™">
        </div>
        <div class="input-group">
          <label>íŠ¸ë™ ID</label>
          <input type="text" id="trackId" value="new-track">
        </div>
        <div class="input-group">
          <label>ë§µ ë„ˆë¹„</label>
          <input type="number" id="mapWidth" value="4500">
        </div>
        <div class="input-group">
          <label>ë§µ ë†’ì´</label>
          <input type="number" id="mapHeight" value="3000">
        </div>
        <div class="input-group">
          <label>íŠ¸ë™ í­</label>
          <input type="number" id="trackWidth" value="120" readonly>
        </div>
      </div>

      <div class="section">
        <h3>í¬ì¸íŠ¸ ëª©ë¡</h3>
        <div class="point-list" id="pointList">
          <div style="color: #666; font-size: 11px; text-align: center; padding: 20px;">
            í¬ì¸íŠ¸ë¥¼ ì¶”ê°€í•˜ë ¤ë©´ ìº”ë²„ìŠ¤ë¥¼ í´ë¦­í•˜ì„¸ìš”
          </div>
        </div>
      </div>

      <div class="section">
        <h3>ì„ íƒëœ í¬ì¸íŠ¸</h3>
        <div id="selectedPointInfo" style="color: #666; font-size: 11px;">
          í¬ì¸íŠ¸ë¥¼ ì„ íƒí•˜ì„¸ìš”
        </div>
        <div class="input-group" id="pointEditGroup" style="display: none; margin-top: 10px;">
          <label>X ì¢Œí‘œ</label>
          <input type="number" id="pointX" step="1">
        </div>
        <div class="input-group" id="pointEditGroup2" style="display: none;">
          <label>Y ì¢Œí‘œ</label>
          <input type="number" id="pointY" step="1">
        </div>
        <div class="input-group" id="pointEditGroup3" style="display: none; margin-top: 10px;">
          <label>í¬ì¸íŠ¸ íƒ€ì…</label>
          <div style="display: flex; gap: 5px;">
            <button id="setStraightBtn" style="flex: 1; font-size: 11px;">ì§ì„ </button>
            <button id="setCurveBtn" style="flex: 1; font-size: 11px;">ê³¡ì„ </button>
          </div>
        </div>
      </div>

      <div class="section">
        <h3>ì²´í¬í¬ì¸íŠ¸ ëª©ë¡</h3>
        <div class="point-list" id="checkpointList">
          <div style="color: #666; font-size: 11px; text-align: center; padding: 20px;">
            ì²´í¬í¬ì¸íŠ¸ë¥¼ ì¶”ê°€í•˜ë ¤ë©´ ì²´í¬í¬ì¸íŠ¸ ì¶”ê°€ ëª¨ë“œë¥¼ ì„ íƒí•˜ì„¸ìš”
          </div>
        </div>
      </div>

      <div class="section">
        <h3>ì„ íƒëœ ì²´í¬í¬ì¸íŠ¸</h3>
        <div id="selectedCheckpointInfo" style="color: #666; font-size: 11px;">
          ì²´í¬í¬ì¸íŠ¸ë¥¼ ì„ íƒí•˜ì„¸ìš”
        </div>
        <div class="input-group" id="checkpointEditGroup" style="display: none; margin-top: 10px;">
          <label>X ì¢Œí‘œ</label>
          <input type="number" id="checkpointX" step="1">
        </div>
        <div class="input-group" id="checkpointEditGroup2" style="display: none;">
          <label>Y ì¢Œí‘œ</label>
          <input type="number" id="checkpointY" step="1">
        </div>
        <div class="input-group" id="checkpointEditGroup3" style="display: none;">
          <label>ê°ë„ (ë¼ë””ì•ˆ)</label>
          <input type="number" id="checkpointAngle" step="0.1">
        </div>
        <div class="input-group" id="checkpointEditGroup4" style="display: none; margin-top: 5px;">
          <label>ê°ë„ (ë„)</label>
          <input type="number" id="checkpointAngleDeg" step="1" min="0" max="360">
        </div>
      </div>

      <div class="section">
        <h3>ìƒì„±ëœ ì½”ë“œ</h3>
        <button id="copyCodeBtn" style="width: 100%; margin-bottom: 10px;">ì½”ë“œ ë³µì‚¬</button>
        <textarea id="codeOutput" class="code-output" readonly></textarea>
      </div>

      <div class="info">
        <strong>ì‚¬ìš©ë²•:</strong><br>
        â€¢ í¬ì¸íŠ¸ ì¶”ê°€ ëª¨ë“œ: ìº”ë²„ìŠ¤ í´ë¦­ìœ¼ë¡œ í¬ì¸íŠ¸ ì¶”ê°€<br>
        â€¢ í¬ì¸íŠ¸ ì´ë™ ëª¨ë“œ: í¬ì¸íŠ¸ë¥¼ ë“œë˜ê·¸í•˜ì—¬ ì´ë™<br>
        â€¢ í¬ì¸íŠ¸ ì‚­ì œ ëª¨ë“œ: í¬ì¸íŠ¸ í´ë¦­ìœ¼ë¡œ ì‚­ì œ<br>
        â€¢ ë¯¸ë¦¬ë³´ê¸°: íŠ¸ë™ ë Œë”ë§ ë¯¸ë¦¬ë³´ê¸°
      </div>
    </div>
  </div>

  <script>
    class TrackEditor {
      constructor() {
        this.canvas = document.getElementById('editorCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.minimapCanvas = document.getElementById('minimapCanvas');
        this.minimapCtx = this.minimapCanvas.getContext('2d');
        this.points = [];
        this.checkpoints = []; // ì²´í¬í¬ì¸íŠ¸ ë°°ì—´
        this.curbs = []; // ì—°ì„ ë°°ì—´ { x, y, angle, length }
        this.selectedPointIndex = -1;
        this.selectedCheckpointIndex = -1; // ì„ íƒëœ ì²´í¬í¬ì¸íŠ¸ ì¸ë±ìŠ¤
        this.selectedKerbIndex = -1; // ì„ íƒëœ ì—°ì„ ì¸ë±ìŠ¤
        this.draggingPointIndex = -1;
        this.draggingCheckpointIndex = -1; // ë“œë˜ê·¸ ì¤‘ì¸ ì²´í¬í¬ì¸íŠ¸ ì¸ë±ìŠ¤
        this.draggingKerbIndex = -1; // ë“œë˜ê·¸ ì¤‘ì¸ ì—°ì„ ì¸ë±ìŠ¤
        this.hoveredPointIndex = -1; // í˜¸ë²„ ì¤‘ì¸ í¬ì¸íŠ¸ ì¸ë±ìŠ¤
        this.hoveredCheckpointIndex = -1; // í˜¸ë²„ ì¤‘ì¸ ì²´í¬í¬ì¸íŠ¸ ì¸ë±ìŠ¤
        this.hoveredKerbIndex = -1; // í˜¸ë²„ ì¤‘ì¸ ì—°ì„ ì¸ë±ìŠ¤
        this.mode = 'add'; // 'add', 'move', 'delete', 'addCheckpoint', 'moveCheckpoint', 'deleteCheckpoint', 'addKerb', 'moveKerb', 'deleteKerb'
        this.zoom = 1;
        this.offsetX = 0;
        this.offsetY = 0;
        this.previewMode = false;
        
        // íŒ¬(ì´ë™) ê´€ë ¨ ë³€ìˆ˜
        this.isPanning = false;
        this.panStartX = 0;
        this.panStartY = 0;
        this.panStartOffsetX = 0;
        this.panStartOffsetY = 0;
        
        // ë¯¸ë‹ˆë§µ ë“œë˜ê·¸ ê´€ë ¨ ë³€ìˆ˜
        this.isMinimapDragging = false;
        this.minimapDragStartX = 0;
        this.minimapDragStartY = 0;
        
        // ë Œë”ë§ ìµœì í™”ë¥¼ ìœ„í•œ ë³€ìˆ˜
        this.animationFrameId = null;
        this.pendingRender = false;

        // ìº”ë²„ìŠ¤ í¬ê¸° ì¡°ì •
        this.resizeCanvas();
        window.addEventListener('resize', () => this.resizeCanvas());

        // localStorageì—ì„œ ë°ì´í„° ë³µì›
        this.loadFromStorage();
        
        this.setupEventListeners();
        this.updateCodeOutput();
        
        // ì´ˆê¸° ë Œë”ë§ì€ ì•½ê°„ ì§€ì—°í•˜ì—¬ DOMì´ ì™„ì „íˆ ë¡œë“œëœ í›„ ìˆ˜í–‰
        // requestAnimationFrameì„ ì‚¬ìš©í•˜ì—¬ ë¸Œë¼ìš°ì €ê°€ ì¤€ë¹„ëœ í›„ ë Œë”ë§
        requestAnimationFrame(() => {
          // ìº”ë²„ìŠ¤ í¬ê¸° ì¬í™•ì¸
          this.resizeCanvas();
          
          if (this.points.length > 0) {
            // ì €ì¥ëœ ë°ì´í„°ê°€ ìˆìœ¼ë©´ ê·¸ ë·° ì‚¬ìš©, ì—†ìœ¼ë©´ ë¦¬ì…‹
            const savedZoom = localStorage.getItem('trackEditor_zoom');
            const savedOffsetX = localStorage.getItem('trackEditor_offsetX');
            const savedOffsetY = localStorage.getItem('trackEditor_offsetY');
            if (savedZoom && savedOffsetX && savedOffsetY) {
              this.zoom = parseFloat(savedZoom);
              this.offsetX = parseFloat(savedOffsetX);
              this.offsetY = parseFloat(savedOffsetY);
            } else {
              this.resetView();
            }
          } else {
            this.resetView();
          }
          
          // ì¦‰ì‹œ ë Œë”ë§
          this.render();
          
          // ì¶”ê°€ë¡œ í•œ ë²ˆ ë” ë Œë”ë§ (ìº”ë²„ìŠ¤ê°€ ì™„ì „íˆ ì¤€ë¹„ëœ í›„)
          setTimeout(() => {
            this.resizeCanvas();
            this.render();
          }, 50);
        });
      }
      
      // localStorageì— ì €ì¥
      saveToStorage() {
        try {
          localStorage.setItem('trackEditor_points', JSON.stringify(this.points));
          localStorage.setItem('trackEditor_checkpoints', JSON.stringify(this.checkpoints));
          localStorage.setItem('trackEditor_curbs', JSON.stringify(this.curbs));
          localStorage.setItem('trackEditor_trackName', document.getElementById('trackName').value);
          localStorage.setItem('trackEditor_trackId', document.getElementById('trackId').value);
          localStorage.setItem('trackEditor_mapWidth', document.getElementById('mapWidth').value);
          localStorage.setItem('trackEditor_mapHeight', document.getElementById('mapHeight').value);
          localStorage.setItem('trackEditor_selectedPointIndex', this.selectedPointIndex.toString());
          localStorage.setItem('trackEditor_selectedCheckpointIndex', this.selectedCheckpointIndex.toString());
          localStorage.setItem('trackEditor_selectedKerbIndex', this.selectedKerbIndex.toString());
          localStorage.setItem('trackEditor_zoom', this.zoom.toString());
          localStorage.setItem('trackEditor_offsetX', this.offsetX.toString());
          localStorage.setItem('trackEditor_offsetY', this.offsetY.toString());
          localStorage.setItem('trackEditor_previewMode', this.previewMode.toString());
        } catch (e) {
          console.warn('ì €ì¥ ì‹¤íŒ¨:', e);
        }
      }
      
      // localStorageì—ì„œ ë³µì›
      loadFromStorage() {
        try {
          const savedPoints = localStorage.getItem('trackEditor_points');
          if (savedPoints) {
            this.points = JSON.parse(savedPoints);
          }
          
          const savedCheckpoints = localStorage.getItem('trackEditor_checkpoints');
          if (savedCheckpoints) {
            this.checkpoints = JSON.parse(savedCheckpoints);
          }
          
          const savedCurbs = localStorage.getItem('trackEditor_curbs');
          if (savedCurbs) {
            this.curbs = JSON.parse(savedCurbs);
          }
          
          const trackName = localStorage.getItem('trackEditor_trackName');
          const trackId = localStorage.getItem('trackEditor_trackId');
          const mapWidth = localStorage.getItem('trackEditor_mapWidth');
          const mapHeight = localStorage.getItem('trackEditor_mapHeight');
          const selectedIndex = localStorage.getItem('trackEditor_selectedPointIndex');
          const selectedCheckpointIndex = localStorage.getItem('trackEditor_selectedCheckpointIndex');
          const selectedKerbIndex = localStorage.getItem('trackEditor_selectedKerbIndex');
          
          if (trackName) document.getElementById('trackName').value = trackName;
          if (trackId) document.getElementById('trackId').value = trackId;
          if (mapWidth) document.getElementById('mapWidth').value = mapWidth;
          if (mapHeight) document.getElementById('mapHeight').value = mapHeight;
          if (selectedIndex) this.selectedPointIndex = parseInt(selectedIndex, 10);
          if (selectedCheckpointIndex) this.selectedCheckpointIndex = parseInt(selectedCheckpointIndex, 10);
          if (selectedKerbIndex) this.selectedKerbIndex = parseInt(selectedKerbIndex, 10);
          
          // ë¯¸ë¦¬ë³´ê¸° ëª¨ë“œ ë³µì›
          const savedPreviewMode = localStorage.getItem('trackEditor_previewMode');
          if (savedPreviewMode === 'true') {
            this.previewMode = true;
            document.getElementById('previewBtn').classList.add('active');
          }
          
          if (this.points.length > 0) {
            this.updatePointList();
            this.updateSelectedPointInfo();
          }
          if (this.checkpoints.length > 0) {
            this.updateCheckpointList();
            this.updateSelectedCheckpointInfo();
          }
          if (this.curbs.length > 0) {
            this.updateKerbList();
            this.updateSelectedKerbInfo();
          }
          
          if (this.checkpoints.length > 0) {
            this.updateCheckpointList();
            this.updateSelectedCheckpointInfo();
          }
        } catch (e) {
          console.warn('ë³µì› ì‹¤íŒ¨:', e);
        }
      }

      resizeCanvas() {
        const container = this.canvas.parentElement;
        const rect = container.getBoundingClientRect();
        this.canvas.width = rect.width;
        this.canvas.height = rect.height;
        
        // ë¯¸ë‹ˆë§µ ìº”ë²„ìŠ¤ í¬ê¸° ì„¤ì •
        if (this.minimapCanvas) {
          this.minimapCanvas.width = 200;
          this.minimapCanvas.height = 150;
        }
      }

      setupEventListeners() {
        // ëª¨ë“œ ë²„íŠ¼
        document.getElementById('addModeBtn').addEventListener('click', () => this.setMode('add'));
        document.getElementById('moveModeBtn').addEventListener('click', () => this.setMode('move'));
        document.getElementById('deleteModeBtn').addEventListener('click', () => this.setMode('delete'));
        document.getElementById('addCheckpointBtn').addEventListener('click', () => this.setMode('addCheckpoint'));
        document.getElementById('moveCheckpointBtn').addEventListener('click', () => this.setMode('moveCheckpoint'));
        document.getElementById('deleteCheckpointBtn').addEventListener('click', () => this.setMode('deleteCheckpoint'));
        document.getElementById('addKerbBtn').addEventListener('click', () => this.setMode('addKerb'));
        document.getElementById('moveKerbBtn').addEventListener('click', () => this.setMode('moveKerb'));
        document.getElementById('deleteKerbBtn').addEventListener('click', () => this.setMode('deleteKerb'));
        document.getElementById('previewBtn').addEventListener('click', () => this.togglePreview());

        // ìº”ë²„ìŠ¤ ì´ë²¤íŠ¸
        this.canvas.addEventListener('click', (e) => this.handleCanvasClick(e));
        this.canvas.addEventListener('mousedown', (e) => this.handleMouseDown(e));
        this.canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));
        this.canvas.addEventListener('mouseup', (e) => this.handleMouseUp(e));
        this.canvas.addEventListener('wheel', (e) => this.handleWheel(e));
        this.canvas.addEventListener('contextmenu', (e) => e.preventDefault()); // ìš°í´ë¦­ ë©”ë‰´ ë°©ì§€
        this.canvas.addEventListener('mouseleave', (e) => {
          // ìº”ë²„ìŠ¤ë¥¼ ë²—ì–´ë‚  ë•Œ í˜¸ë²„ ìƒíƒœ ì´ˆê¸°í™”
          this.hoveredPointIndex = -1;
          this.hoveredCheckpointIndex = -1;
          this.hoveredKerbIndex = -1;
          if (this.mode === 'delete' || this.mode === 'deleteCheckpoint' || this.mode === 'deleteKerb') {
            this.canvas.style.cursor = 'not-allowed';
          }
          this.render();
        });
        
        // ë¯¸ë‹ˆë§µ ì´ë²¤íŠ¸
        if (this.minimapCanvas) {
          this.minimapCanvas.addEventListener('mousedown', (e) => this.handleMinimapMouseDown(e));
          this.minimapCanvas.addEventListener('mousemove', (e) => this.handleMinimapMouseMove(e));
          this.minimapCanvas.addEventListener('mouseup', (e) => this.handleMinimapMouseUp(e));
          this.minimapCanvas.addEventListener('mouseleave', (e) => this.handleMinimapMouseUp(e));
        }
        
        // ì¤Œ ì»¨íŠ¸ë¡¤ ë²„íŠ¼
        document.getElementById('zoomInBtn').addEventListener('click', () => this.zoomIn());
        document.getElementById('zoomOutBtn').addEventListener('click', () => this.zoomOut());
        document.getElementById('resetViewBtn').addEventListener('click', () => this.resetView());

        // ì…ë ¥ í•„ë“œ ë³€ê²½
        document.getElementById('trackName').addEventListener('input', () => { this.updateCodeOutput(); this.saveToStorage(); });
        document.getElementById('trackId').addEventListener('input', () => { this.updateCodeOutput(); this.saveToStorage(); });
        document.getElementById('mapWidth').addEventListener('input', () => { this.render(); this.updateCodeOutput(); this.saveToStorage(); });
        document.getElementById('mapHeight').addEventListener('input', () => { this.render(); this.updateCodeOutput(); this.saveToStorage(); });
        document.getElementById('pointX').addEventListener('input', () => this.updateSelectedPoint());
        document.getElementById('pointY').addEventListener('input', () => this.updateSelectedPoint());
        
        // í¬ì¸íŠ¸ íƒ€ì… ë³€ê²½ ë²„íŠ¼
        document.getElementById('setStraightBtn').addEventListener('click', () => this.setPointType('straight'));
        document.getElementById('setCurveBtn').addEventListener('click', () => this.setPointType('curve'));
        
        // ì²´í¬í¬ì¸íŠ¸ ì…ë ¥ í•„ë“œ (ìš”ì†Œê°€ ì¡´ì¬í•˜ëŠ” ê²½ìš°ì—ë§Œ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì¶”ê°€)
        const checkpointX = document.getElementById('checkpointX');
        const checkpointY = document.getElementById('checkpointY');
        const checkpointAngle = document.getElementById('checkpointAngle');
        const checkpointAngleDeg = document.getElementById('checkpointAngleDeg');
        
        if (checkpointX) {
          checkpointX.addEventListener('input', () => this.updateSelectedCheckpoint());
        }
        if (checkpointY) {
          checkpointY.addEventListener('input', () => this.updateSelectedCheckpoint());
        }
        if (checkpointAngle) {
          checkpointAngle.addEventListener('input', () => {
            const angle = parseFloat(checkpointAngle.value);
            if (!isNaN(angle) && checkpointAngleDeg) {
              checkpointAngleDeg.value = Math.round(angle * 180 / Math.PI);
              this.updateSelectedCheckpoint();
            }
          });
        }
        if (checkpointAngleDeg) {
          checkpointAngleDeg.addEventListener('input', () => {
            const angleDeg = parseFloat(checkpointAngleDeg.value);
            if (!isNaN(angleDeg) && checkpointAngle) {
              checkpointAngle.value = (angleDeg * Math.PI / 180).toFixed(3);
              this.updateSelectedCheckpoint();
            }
          });
        }
        
        // ì—°ì„ ì…ë ¥ í•„ë“œ
        const kerbX = document.getElementById('kerbX');
        const kerbY = document.getElementById('kerbY');
        const kerbAngle = document.getElementById('kerbAngle');
        const kerbAngleDeg = document.getElementById('kerbAngleDeg');
        const kerbLength = document.getElementById('kerbLength');
        
        if (kerbX) {
          kerbX.addEventListener('input', () => this.updateSelectedKerb());
        }
        if (kerbY) {
          kerbY.addEventListener('input', () => this.updateSelectedKerb());
        }
        if (kerbAngle) {
          kerbAngle.addEventListener('input', () => {
            const angle = parseFloat(kerbAngle.value);
            if (!isNaN(angle) && kerbAngleDeg) {
              kerbAngleDeg.value = Math.round(angle * 180 / Math.PI);
              this.updateSelectedKerb();
            }
          });
        }
        if (kerbAngleDeg) {
          kerbAngleDeg.addEventListener('input', () => {
            const angleDeg = parseFloat(kerbAngleDeg.value);
            if (!isNaN(angleDeg) && kerbAngle) {
              kerbAngle.value = (angleDeg * Math.PI / 180).toFixed(3);
              this.updateSelectedKerb();
            }
          });
        }
        if (kerbLength) {
          kerbLength.addEventListener('input', () => this.updateSelectedKerb());
        }

        // ë²„íŠ¼
        document.getElementById('newTrackBtn').addEventListener('click', () => this.newTrack());
        document.getElementById('copyCodeBtn').addEventListener('click', () => this.copyCode());
        document.getElementById('saveTrackBtn').addEventListener('click', () => this.copyCode());
        document.getElementById('clearBtn').addEventListener('click', () => this.clearTrack());
        document.getElementById('loadTrackBtn').addEventListener('click', () => this.loadTrack());

        // í‚¤ë³´ë“œ
        document.addEventListener('keydown', (e) => {
          if (e.key === 'Delete' || e.key === 'Backspace') {
            if (this.selectedPointIndex >= 0) {
              this.deletePoint(this.selectedPointIndex);
            }
          }
          // ìŠ¤í˜ì´ìŠ¤ë°”ë¡œ íŒ¬ ëª¨ë“œ í™œì„±í™”
          if (e.key === ' ') {
            e.preventDefault();
            this.canvas.style.cursor = 'grabbing';
          }
        });
        
        document.addEventListener('keyup', (e) => {
          if (e.key === ' ') {
            this.canvas.style.cursor = this.mode === 'add' ? 'crosshair' : this.mode === 'move' ? 'move' : 'pointer';
          }
        });
      }

      setMode(mode) {
        this.mode = mode;
        document.getElementById('addModeBtn').classList.toggle('active', mode === 'add');
        document.getElementById('moveModeBtn').classList.toggle('active', mode === 'move');
        document.getElementById('deleteModeBtn').classList.toggle('active', mode === 'delete');
        document.getElementById('addCheckpointBtn').classList.toggle('active', mode === 'addCheckpoint');
        document.getElementById('moveCheckpointBtn').classList.toggle('active', mode === 'moveCheckpoint');
        document.getElementById('deleteCheckpointBtn').classList.toggle('active', mode === 'deleteCheckpoint');
        document.getElementById('addKerbBtn').classList.toggle('active', mode === 'addKerb');
        document.getElementById('moveKerbBtn').classList.toggle('active', mode === 'moveKerb');
        document.getElementById('deleteKerbBtn').classList.toggle('active', mode === 'deleteKerb');
        
        // ì»¤ì„œ ì„¤ì •
        if (mode === 'add' || mode === 'addCheckpoint' || mode === 'addKerb') {
          this.canvas.style.cursor = 'crosshair';
        } else if (mode === 'move' || mode === 'moveCheckpoint' || mode === 'moveKerb') {
          this.canvas.style.cursor = 'move';
        } else if (mode === 'delete' || mode === 'deleteCheckpoint' || mode === 'deleteKerb') {
          this.canvas.style.cursor = 'not-allowed'; // ì‚­ì œ ëª¨ë“œ ê¸°ë³¸ ì»¤ì„œ
        } else {
          this.canvas.style.cursor = 'pointer';
        }
        // í˜¸ë²„ ìƒíƒœ ì´ˆê¸°í™”
        this.hoveredPointIndex = -1;
        this.hoveredCheckpointIndex = -1;
        this.hoveredKerbIndex = -1;
        this.updateStatus();
        this.render(); // ì»¤ì„œ ë³€ê²½ì„ ìœ„í•´ ë‹¤ì‹œ ë Œë”ë§
      }

      togglePreview() {
        this.previewMode = !this.previewMode;
        document.getElementById('previewBtn').classList.toggle('active', this.previewMode);
        // ë¯¸ë¦¬ë³´ê¸° ëª¨ë“œ ìƒíƒœ ì €ì¥
        localStorage.setItem('trackEditor_previewMode', this.previewMode.toString());
        this.render();
      }

      // ìº”ë²„ìŠ¤ ì¢Œí‘œë¥¼ ì›”ë“œ ì¢Œí‘œë¡œ ë³€í™˜
      canvasToWorld(canvasX, canvasY) {
        const worldX = (canvasX - this.offsetX) / this.zoom;
        const worldY = (canvasY - this.offsetY) / this.zoom;
        return { x: worldX, y: worldY };
      }
      
      // ì›”ë“œ ì¢Œí‘œë¥¼ ìº”ë²„ìŠ¤ ì¢Œí‘œë¡œ ë³€í™˜
      worldToCanvas(worldX, worldY) {
        const canvasX = worldX * this.zoom + this.offsetX;
        const canvasY = worldY * this.zoom + this.offsetY;
        return { x: canvasX, y: canvasY };
      }
      
      getCanvasPoint(e) {
        const rect = this.canvas.getBoundingClientRect();
        const canvasX = e.clientX - rect.left;
        const canvasY = e.clientY - rect.top;
        
        // ì¤Œê³¼ ì˜¤í”„ì…‹ì„ ê³ ë ¤í•˜ì—¬ ì›”ë“œ ì¢Œí‘œë¡œ ë³€í™˜
        const world = this.canvasToWorld(canvasX, canvasY);
        return { x: Math.round(world.x), y: Math.round(world.y) };
      }

      findPointAt(x, y, radius = 10) {
        for (let i = this.points.length - 1; i >= 0; i--) {
          const p = this.points[i];
          const dx = p.x - x;
          const dy = p.y - y;
          if (dx * dx + dy * dy < radius * radius) {
            return i;
          }
        }
        return -1;
      }
      
      // ì²´í¬í¬ì¸íŠ¸ ê°ë„ ê³„ì‚° (ê°€ì¥ ê°€ê¹Œìš´ íŠ¸ë™ í¬ì¸íŠ¸ì˜ ë°©í–¥)
      calculateCheckpointAngle(x, y) {
        if (this.points.length < 2) return 0;
        
        // ê°€ì¥ ê°€ê¹Œìš´ í¬ì¸íŠ¸ ì°¾ê¸°
        let minDist = Infinity;
        let nearestIndex = 0;
        for (let i = 0; i < this.points.length; i++) {
          const p = this.points[i];
          const dx = x - p.x;
          const dy = y - p.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist < minDist) {
            minDist = dist;
            nearestIndex = i;
          }
        }
        
        // ë‹¤ìŒ í¬ì¸íŠ¸ ë°©í–¥ ê³„ì‚°
        const p1 = this.points[nearestIndex];
        const p2 = this.points[(nearestIndex + 1) % this.points.length];
        const dx = p2.x - p1.x;
        const dy = p2.y - p1.y;
        return Math.atan2(dy, dx);
      }
      
      // ì²´í¬í¬ì¸íŠ¸ ì°¾ê¸°
      findCheckpointAt(x, y, radius = 15) {
        for (let i = this.checkpoints.length - 1; i >= 0; i--) {
          const cp = this.checkpoints[i];
          const dx = cp.x - x;
          const dy = cp.y - y;
          if (dx * dx + dy * dy < radius * radius) {
            return i;
          }
        }
        return -1;
      }
      
      // ì—°ì„ ì°¾ê¸°
      // ì—°ì„ ê°ì§€ - ê²½ë¡œ ê¸°ë°˜
      findKerbAt(x, y, threshold = 30) {
        for (let i = this.curbs.length - 1; i >= 0; i--) {
          const kerb = this.curbs[i];
          
          // ìƒˆë¡œìš´ ê²½ë¡œ ê¸°ë°˜ ì—°ì„
          if (kerb.centerPath && kerb.centerPath.length > 0) {
            // í´ë¦­ ìœ„ì¹˜ì—ì„œ ì—°ì„ ê²½ë¡œê¹Œì§€ì˜ ìµœì†Œ ê±°ë¦¬ ê³„ì‚°
            let minDist = Infinity;
            for (let j = 0; j < kerb.centerPath.length; j++) {
              const p = kerb.centerPath[j];
              const dx = p.x - x;
              const dy = p.y - y;
              const dist = Math.sqrt(dx * dx + dy * dy);
              if (dist < minDist) {
                minDist = dist;
              }
            }
            // ì—°ì„ì˜ í­ì„ ê³ ë ¤í•œ ê°ì§€ ë²”ìœ„
            const detectRange = (kerb.width || 20) / 2 + threshold;
            if (minDist < detectRange) {
              return i;
            }
          }
          // êµ¬í˜• í¬ë§· (í•˜ìœ„ í˜¸í™˜ì„±)
          else if (kerb.x !== undefined && kerb.y !== undefined) {
            const dx = kerb.x - x;
            const dy = kerb.y - y;
            if (dx * dx + dy * dy < threshold * threshold) {
              return i;
            }
          }
        }
        return -1;
      }
      
      // ê°€ì¥ ê°€ê¹Œìš´ íŠ¸ë™ ê²½ê³„ ì°¾ê¸° (ì—°ì„ ë°°ì¹˜ìš©) - ê°œì„ ëœ ë²„ì „
      findNearestTrackBoundary(x, y, kerbLength = 300) {
        if (this.points.length < 2) return null;
        
        const trackWidth = parseInt(document.getElementById('trackWidth')?.value || '120') || 120;
        const smoothPath = this.getSmoothPath(this.points, 200);
        const { innerPath, outerPath } = this.getTrackBounds(smoothPath, trackWidth);
        
        let minDist = Infinity;
        let nearestIndex = -1;
        let isInnerPath = false;
        let nearestT = 0; // ì„¸ê·¸ë¨¼íŠ¸ ë‚´ ìœ„ì¹˜ (0~1)
        
        // ë‚´ë¶€ ê²½ê³„ í™•ì¸ - ê° ì„¸ê·¸ë¨¼íŠ¸ë¥¼ ë” ì„¸ë°€í•˜ê²Œ ìƒ˜í”Œë§
        for (let i = 0; i < innerPath.length - 1; i++) {
          const p1 = innerPath[i];
          const p2 = innerPath[i + 1];
          
          // ì„¸ê·¸ë¨¼íŠ¸ë¥¼ ë” ì„¸ë°€í•˜ê²Œ ìƒ˜í”Œë§ (5ê°œ ì ìœ¼ë¡œ)
          for (let j = 0; j <= 5; j++) {
            const t = j / 5;
            const px = p1.x + (p2.x - p1.x) * t;
            const py = p1.y + (p2.y - p1.y) * t;
            const dx = x - px;
            const dy = y - py;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist < minDist) {
              minDist = dist;
              nearestIndex = i;
              nearestT = t;
              isInnerPath = true;
            }
          }
        }
        
        // ì™¸ë¶€ ê²½ê³„ í™•ì¸ - ê° ì„¸ê·¸ë¨¼íŠ¸ë¥¼ ë” ì„¸ë°€í•˜ê²Œ ìƒ˜í”Œë§
        for (let i = 0; i < outerPath.length - 1; i++) {
          const p1 = outerPath[i];
          const p2 = outerPath[i + 1];
          
          // ì„¸ê·¸ë¨¼íŠ¸ë¥¼ ë” ì„¸ë°€í•˜ê²Œ ìƒ˜í”Œë§ (5ê°œ ì ìœ¼ë¡œ)
          for (let j = 0; j <= 5; j++) {
            const t = j / 5;
            const px = p1.x + (p2.x - p1.x) * t;
            const py = p1.y + (p2.y - p1.y) * t;
            const dx = x - px;
            const dy = y - py;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist < minDist) {
              minDist = dist;
              nearestIndex = i;
              nearestT = t;
              isInnerPath = false;
            }
          }
        }
        
        // ê±°ë¦¬ ì¡°ê±´ì„ ì¤„ì—¬ì„œ íŠ¸ë™ ê²½ê³„ì— ë” ê°€ê¹Œìš´ ê³³ì—ì„œë§Œ ì—°ì„ ë°°ì¹˜ ê°€ëŠ¥
        if (nearestIndex >= 0 && minDist < trackWidth * 1.5) {
          const path = isInnerPath ? innerPath : outerPath;
          
          // í´ë¦­í•œ ì§€ì ì—ì„œ ê²½ë¡œë¥¼ ë”°ë¼ ì§€ì •ëœ ê¸¸ì´ë§Œí¼ì˜ ê²½ë¡œ ì¶”ì¶œ (ì„¸ë°€í•œ ìœ„ì¹˜ ê³ ë ¤)
          const kerbPath = this.extractPathSegment(path, nearestIndex, kerbLength, nearestT);
          
          return {
            path: isInnerPath ? innerPath : outerPath,
            closestIndex: nearestIndex,
            isInner: isInnerPath,
            kerbPath: kerbPath,
            trackWidth: trackWidth
          };
        }
        
        return null;
      }
      
      // ê²½ë¡œì—ì„œ ì§€ì •ëœ ê¸¸ì´ë§Œí¼ì˜ ì„¸ê·¸ë¨¼íŠ¸ ì¶”ì¶œ (ì„¸ë°€í•œ ìœ„ì¹˜ ê³ ë ¤)
      extractPathSegment(path, startIndex, targetLength, t = 0) {
        if (!path || path.length === 0) return [];
        
        const segment = [];
        
        // ì‹œì‘ì  ê³„ì‚° (startIndexì™€ startIndex+1 ì‚¬ì´ì˜ ì •í™•í•œ ìœ„ì¹˜)
        let startPoint;
        if (startIndex < path.length - 1 && t > 0) {
          const p1 = path[startIndex];
          const p2 = path[startIndex + 1];
          startPoint = {
            x: p1.x + (p2.x - p1.x) * t,
            y: p1.y + (p2.y - p1.y) * t
          };
        } else {
          startPoint = { ...path[startIndex] };
        }
        
        // ì¤‘ì‹¬ì  ì¶”ê°€
        segment.push(startPoint);
        
        // ë’¤ìª½ìœ¼ë¡œ í™•ì¥ (ê²½ë¡œì˜ ì ˆë°˜ ê¸¸ì´)
        let backwardLength = 0;
        // ì‹œì‘ ì„¸ê·¸ë¨¼íŠ¸ì˜ ë’¤ìª½ ë¶€ë¶„ ê¸¸ì´ ê³„ì‚°
        if (startIndex < path.length - 1 && t > 0) {
          const p1 = path[startIndex];
          const p2 = path[startIndex + 1];
          const segDist = Math.sqrt((p2.x - p1.x) ** 2 + (p2.y - p1.y) ** 2);
          backwardLength += segDist * t;
        }
        
        for (let i = startIndex - 1; i >= 0 && backwardLength < targetLength / 2; i--) {
          const p1 = path[i];
          const p2 = path[i + 1];
          const dist = Math.sqrt((p2.x - p1.x) ** 2 + (p2.y - p1.y) ** 2);
          backwardLength += dist;
          segment.unshift({ ...p1 });
        }
        
        // ì•ìª½ìœ¼ë¡œ í™•ì¥ (ê²½ë¡œì˜ ì ˆë°˜ ê¸¸ì´)
        let forwardLength = 0;
        // ì‹œì‘ ì„¸ê·¸ë¨¼íŠ¸ì˜ ì•ìª½ ë¶€ë¶„ ê¸¸ì´ ê³„ì‚°
        if (startIndex < path.length - 1 && t < 1) {
          const p1 = path[startIndex];
          const p2 = path[startIndex + 1];
          const segDist = Math.sqrt((p2.x - p1.x) ** 2 + (p2.y - p1.y) ** 2);
          forwardLength += segDist * (1 - t);
        }
        
        for (let i = startIndex + 1; i < path.length && forwardLength < targetLength / 2; i++) {
          const p1 = path[i - 1];
          const p2 = path[i];
          const dist = Math.sqrt((p2.x - p1.x) ** 2 + (p2.y - p1.y) ** 2);
          forwardLength += dist;
          segment.push({ ...p2 });
        }
        
        return segment;
      }

      handleCanvasClick(e) {
        const point = this.getCanvasPoint(e);
        
        if (this.mode === 'add') {
          this.addPoint(point.x, point.y);
        } else if (this.mode === 'delete') {
          const index = this.findPointAt(point.x, point.y);
          if (index >= 0) {
            this.deletePoint(index);
          }
        } else if (this.mode === 'addCheckpoint') {
          // ê°€ì¥ ê°€ê¹Œìš´ í¬ì¸íŠ¸ì˜ ê°ë„ ê³„ì‚°
          const angle = this.calculateCheckpointAngle(point.x, point.y);
          this.addCheckpoint(point.x, point.y, angle);
        } else if (this.mode === 'deleteCheckpoint') {
          const index = this.findCheckpointAt(point.x, point.y);
          if (index >= 0) {
            this.deleteCheckpoint(index);
          }
        } else if (this.mode === 'addKerb') {
          console.log('addKerb mode, point:', point);
          // ê¸°ë³¸ ì—°ì„ ê¸¸ì´ 300
          const kerbLength = 300;
          this.addKerb(point.x, point.y, kerbLength);
        } else if (this.mode === 'deleteKerb') {
          const index = this.findKerbAt(point.x, point.y);
          if (index >= 0) {
            this.deleteKerb(index);
          }
        }
      }

      handleMouseDown(e) {
        // ìš°í´ë¦­ ë˜ëŠ” ìŠ¤í˜ì´ìŠ¤ë°” + ë“œë˜ê·¸ë¡œ íŒ¬
        if (e.button === 2 || (e.button === 0 && e.spaceKey)) {
          this.isPanning = true;
          this.panStartX = e.clientX;
          this.panStartY = e.clientY;
          this.panStartOffsetX = this.offsetX;
          this.panStartOffsetY = this.offsetY;
          this.canvas.style.cursor = 'grabbing';
          return;
        }
        
        const point = this.getCanvasPoint(e);
        
        if (this.mode === 'move') {
          this.draggingPointIndex = this.findPointAt(point.x, point.y);
          if (this.draggingPointIndex >= 0) {
            this.selectedPointIndex = this.draggingPointIndex;
            this.selectedCheckpointIndex = -1;
            this.updatePointList();
            this.updateSelectedPointInfo();
            this.updateCheckpointList();
            this.updateSelectedCheckpointInfo();
          }
        } else if (this.mode === 'moveCheckpoint') {
          this.draggingCheckpointIndex = this.findCheckpointAt(point.x, point.y);
          if (this.draggingCheckpointIndex >= 0) {
            this.selectedCheckpointIndex = this.draggingCheckpointIndex;
            this.selectedPointIndex = -1;
            this.selectedKerbIndex = -1;
            this.updatePointList();
            this.updateSelectedPointInfo();
            this.updateCheckpointList();
            this.updateSelectedCheckpointInfo();
            this.updateKerbList();
            this.updateSelectedKerbInfo();
          }
        } else if (this.mode === 'moveKerb') {
          this.draggingKerbIndex = this.findKerbAt(point.x, point.y);
          if (this.draggingKerbIndex >= 0) {
            this.selectedKerbIndex = this.draggingKerbIndex;
            this.selectedPointIndex = -1;
            this.selectedCheckpointIndex = -1;
            this.updatePointList();
            this.updateSelectedPointInfo();
            this.updateCheckpointList();
            this.updateSelectedCheckpointInfo();
            this.updateKerbList();
            this.updateSelectedKerbInfo();
          }
        }
      }

      handleMouseMove(e) {
        // íŒ¬ ì¤‘ì¼ ë•Œ
        if (this.isPanning) {
          const deltaX = e.clientX - this.panStartX;
          const deltaY = e.clientY - this.panStartY;
          this.offsetX = this.panStartOffsetX + deltaX;
          this.offsetY = this.panStartOffsetY + deltaY;
          this.saveToStorage(); // ì €ì¥ (throttle í•„ìš”í•  ìˆ˜ ìˆìŒ)
          this.render();
          return;
        }
        
        // ì‚­ì œ/ì´ë™ ëª¨ë“œì¼ ë•Œ í˜¸ë²„ ê°€ëŠ¥í•œ í•­ëª© ê°ì§€ ë° ì»¤ì„œ ë³€ê²½
        const point = this.getCanvasPoint(e);
        let cursorChanged = false;
        
        if (this.mode === 'delete' || this.mode === 'move') {
          const pointIndex = this.findPointAt(point.x, point.y);
          if (pointIndex >= 0) {
            if (this.hoveredPointIndex !== pointIndex) {
              this.hoveredPointIndex = pointIndex;
              this.canvas.style.cursor = this.mode === 'delete' ? 'pointer' : 'move';
              cursorChanged = true;
              this.render();
            }
          } else if (this.hoveredPointIndex >= 0) {
            this.hoveredPointIndex = -1;
            this.canvas.style.cursor = this.mode === 'delete' ? 'not-allowed' : 'move';
            cursorChanged = true;
            this.render();
          }
        } else if (this.mode === 'deleteCheckpoint' || this.mode === 'moveCheckpoint') {
          const checkpointIndex = this.findCheckpointAt(point.x, point.y);
          if (checkpointIndex >= 0) {
            if (this.hoveredCheckpointIndex !== checkpointIndex) {
              this.hoveredCheckpointIndex = checkpointIndex;
              this.canvas.style.cursor = this.mode === 'deleteCheckpoint' ? 'pointer' : 'move';
              cursorChanged = true;
              this.render();
            }
          } else if (this.hoveredCheckpointIndex >= 0) {
            this.hoveredCheckpointIndex = -1;
            this.canvas.style.cursor = this.mode === 'deleteCheckpoint' ? 'not-allowed' : 'move';
            cursorChanged = true;
            this.render();
          }
        } else if (this.mode === 'deleteKerb' || this.mode === 'moveKerb') {
          const kerbIndex = this.findKerbAt(point.x, point.y);
          if (kerbIndex >= 0) {
            if (this.hoveredKerbIndex !== kerbIndex) {
              this.hoveredKerbIndex = kerbIndex;
              this.canvas.style.cursor = this.mode === 'deleteKerb' ? 'pointer' : 'move';
              cursorChanged = true;
              this.render();
            }
          } else if (this.hoveredKerbIndex >= 0) {
            this.hoveredKerbIndex = -1;
            this.canvas.style.cursor = this.mode === 'deleteKerb' ? 'not-allowed' : 'move';
            cursorChanged = true;
            this.render();
          }
        } else {
          // ë‹¤ë¥¸ ëª¨ë“œì¼ ë•Œ í˜¸ë²„ ìƒíƒœ ì´ˆê¸°í™”
          if (this.hoveredPointIndex >= 0 || this.hoveredCheckpointIndex >= 0 || this.hoveredKerbIndex >= 0) {
            this.hoveredPointIndex = -1;
            this.hoveredCheckpointIndex = -1;
            this.hoveredKerbIndex = -1;
            this.render();
          }
        }
        
        if (cursorChanged) {
          return; // ì»¤ì„œ ë³€ê²½ë§Œ í–ˆìœ¼ë©´ ë“œë˜ê·¸ ì²˜ë¦¬í•˜ì§€ ì•ŠìŒ
        }
        
        if (this.draggingPointIndex >= 0 && this.mode === 'move') {
          const point = this.getCanvasPoint(e);
          const currentPoint = this.points[this.draggingPointIndex];
          this.points[this.draggingPointIndex] = { 
            x: point.x, 
            y: point.y, 
            type: currentPoint.type || 'straight' 
          };
          this.updateSelectedPointInfo();
          this.updateCodeOutput();
          this.saveToStorage(); // ì €ì¥
          this.render();
        } else if (this.draggingCheckpointIndex >= 0 && this.mode === 'moveCheckpoint') {
          const point = this.getCanvasPoint(e);
          const currentCheckpoint = this.checkpoints[this.draggingCheckpointIndex];
          this.checkpoints[this.draggingCheckpointIndex] = {
            x: point.x,
            y: point.y,
            angle: currentCheckpoint.angle || 0
          };
          this.updateSelectedCheckpointInfo();
          this.updateCodeOutput();
          this.saveToStorage(); // ì €ì¥
          this.render();
        } else if (this.draggingKerbIndex >= 0 && this.mode === 'moveKerb') {
          const point = this.getCanvasPoint(e);
          const currentKerb = this.curbs[this.draggingKerbIndex];
          // íŠ¸ë™ ê²½ê³„ë¥¼ ë”°ë¼ ìƒˆë¡œìš´ ê²½ë¡œ ìƒì„±
          const kerbLength = currentKerb.length || 300;
          const boundary = this.findNearestTrackBoundary(point.x, point.y, kerbLength);
          
          if (boundary && boundary.kerbPath && boundary.kerbPath.length >= 2) {
            this.curbs[this.draggingKerbIndex] = {
              centerPath: boundary.kerbPath,
              width: currentKerb.width || 20,
              length: kerbLength,
              trackSide: boundary.isInner ? 'inner' : 'outer'
            };
            this.updateSelectedKerbInfo();
            // ë¶€ë“œëŸ¬ìš´ ì´ë™ì„ ìœ„í•´ requestAnimationFrame ì‚¬ìš©
            this.scheduleRender();
            // ì €ì¥ì€ ë“œë˜ê·¸ ì¢…ë£Œ ì‹œì—ë§Œ ìˆ˜í–‰ (ì„±ëŠ¥ ìµœì í™”)
          }
        }
      }

      handleMouseUp(e) {
        if (this.isPanning) {
          this.isPanning = false;
          const cursorMap = {
            'add': 'crosshair',
            'addCheckpoint': 'crosshair',
            'move': 'move',
            'moveCheckpoint': 'move',
            'delete': 'pointer',
            'deleteCheckpoint': 'pointer'
          };
          this.canvas.style.cursor = cursorMap[this.mode] || 'default';
          this.saveToStorage(); // íŒ¬ ì¢…ë£Œ ì‹œ ì €ì¥
        }
        
        if (this.draggingPointIndex >= 0) {
          this.draggingPointIndex = -1;
        }
        
        if (this.draggingCheckpointIndex >= 0) {
          this.draggingCheckpointIndex = -1;
        }
        
        if (this.draggingKerbIndex >= 0) {
          this.draggingKerbIndex = -1;
          this.updateCodeOutput();
          this.saveToStorage(); // ë“œë˜ê·¸ ì¢…ë£Œ ì‹œ ì €ì¥
          this.render(); // ìµœì¢… ë Œë”ë§
        }
      }
      
      handleWheel(e) {
        e.preventDefault();
        
        const rect = this.canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;
        
        // ë§ˆìš°ìŠ¤ ì»¤ì„œ ìœ„ì¹˜ì˜ ì›”ë“œ ì¢Œí‘œ ê³„ì‚° (ì¤Œ ë³€ê²½ ì „)
        // canvasToWorld: (canvasX - offsetX) / zoom
        const worldX = (mouseX - this.offsetX) / this.zoom;
        const worldY = (mouseY - this.offsetY) / this.zoom;
        
        // ì¤Œ ë³€ê²½
        const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
        const newZoom = Math.max(0.1, Math.min(5, this.zoom * zoomFactor));
        
        // ë§ˆìš°ìŠ¤ ì»¤ì„œê°€ ê°€ë¦¬í‚¤ëŠ” ì›”ë“œ ì¢Œí‘œê°€ ê°™ì€ í™”ë©´ ìœ„ì¹˜ì— ìˆë„ë¡ ì˜¤í”„ì…‹ ì¡°ì •
        // ìƒˆë¡œìš´ ì˜¤í”„ì…‹ = ë§ˆìš°ìŠ¤ ìœ„ì¹˜ - (ì›”ë“œ ì¢Œí‘œ * ìƒˆë¡œìš´ ì¤Œ)
        this.offsetX = mouseX - worldX * newZoom;
        this.offsetY = mouseY - worldY * newZoom;
        this.zoom = newZoom;
        
        this.saveToStorage(); // ì €ì¥
        this.render();
      }
      
      zoomIn() {
        const centerX = this.canvas.width / 2;
        const centerY = this.canvas.height / 2;
        const worldBefore = this.canvasToWorld(centerX, centerY);
        
        this.zoom = Math.min(5, this.zoom * 1.2);
        
        const worldAfter = this.canvasToWorld(centerX, centerY);
        this.offsetX += (worldBefore.x - worldAfter.x) * this.zoom;
        this.offsetY += (worldBefore.y - worldAfter.y) * this.zoom;
        
        this.saveToStorage(); // ì €ì¥
        this.render();
      }
      
      zoomOut() {
        const centerX = this.canvas.width / 2;
        const centerY = this.canvas.height / 2;
        const worldBefore = this.canvasToWorld(centerX, centerY);
        
        this.zoom = Math.max(0.1, this.zoom / 1.2);
        
        const worldAfter = this.canvasToWorld(centerX, centerY);
        this.offsetX += (worldBefore.x - worldAfter.x) * this.zoom;
        this.offsetY += (worldBefore.y - worldAfter.y) * this.zoom;
        
        this.saveToStorage(); // ì €ì¥
        this.render();
      }
      
      resetView() {
        const width = parseInt(document.getElementById('mapWidth')?.value || '4500') || 4500;
        const height = parseInt(document.getElementById('mapHeight')?.value || '3000') || 3000;
        
        // ë§µì„ í™”ë©´ ì¤‘ì•™ì— ë§ì¶”ê¸°
        const scaleX = this.canvas.width / width;
        const scaleY = this.canvas.height / height;
        this.zoom = Math.min(scaleX, scaleY) * 0.9; // ì•½ê°„ì˜ ì—¬ìœ  ê³µê°„
        
        this.offsetX = (this.canvas.width - width * this.zoom) / 2;
        this.offsetY = (this.canvas.height - height * this.zoom) / 2;
        
        this.saveToStorage(); // ì €ì¥
        this.render();
      }
      
      handleMinimapMouseDown(e) {
        e.preventDefault();
        this.isMinimapDragging = true;
        const rect = this.minimapCanvas.getBoundingClientRect();
        this.minimapDragStartX = e.clientX - rect.left;
        this.minimapDragStartY = e.clientY - rect.top;
        this.minimapCanvas.style.cursor = 'grabbing';
        this.updateMinimapView(this.minimapDragStartX, this.minimapDragStartY);
      }
      
      handleMinimapMouseMove(e) {
        if (!this.isMinimapDragging) return;
        e.preventDefault();
        const rect = this.minimapCanvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        this.updateMinimapView(x, y);
      }
      
      handleMinimapMouseUp(e) {
        if (!this.isMinimapDragging) return;
        this.isMinimapDragging = false;
        this.minimapCanvas.style.cursor = 'pointer';
        this.saveToStorage(); // ì €ì¥
      }
      
      updateMinimapView(x, y) {
        const width = parseInt(document.getElementById('mapWidth')?.value || '4500') || 4500;
        const height = parseInt(document.getElementById('mapHeight')?.value || '3000') || 3000;
        
        // ë¯¸ë‹ˆë§µ ìŠ¤ì¼€ì¼ ê³„ì‚°
        const minimapScaleX = this.minimapCanvas.width / width;
        const minimapScaleY = this.minimapCanvas.height / height;
        const minimapScale = Math.min(minimapScaleX, minimapScaleY);
        
        const mapWidthOnMinimap = width * minimapScale;
        const mapHeightOnMinimap = height * minimapScale;
        const mapOffsetX = (this.minimapCanvas.width - mapWidthOnMinimap) / 2;
        const mapOffsetY = (this.minimapCanvas.height - mapHeightOnMinimap) / 2;
        
        // ë¯¸ë‹ˆë§µ ì¢Œí‘œë¥¼ ì›”ë“œ ì¢Œí‘œë¡œ ë³€í™˜
        const worldX = (x - mapOffsetX) / minimapScale;
        const worldY = (y - mapOffsetY) / minimapScale;
        
        // í´ë¦­í•œ ìœ„ì¹˜ê°€ í™”ë©´ ì¤‘ì•™ì— ì˜¤ë„ë¡ ì˜¤í”„ì…‹ ì¡°ì •
        this.offsetX = this.canvas.width / 2 - worldX * this.zoom;
        this.offsetY = this.canvas.height / 2 - worldY * this.zoom;
        
        this.render();
      }
      
      renderMinimap() {
        if (!this.minimapCanvas || !this.minimapCtx) return;
        
        const width = parseInt(document.getElementById('mapWidth')?.value || '4500') || 4500;
        const height = parseInt(document.getElementById('mapHeight')?.value || '3000') || 3000;
        const trackWidth = parseInt(document.getElementById('trackWidth')?.value || '120') || 120;
        
        const minimapScaleX = this.minimapCanvas.width / width;
        const minimapScaleY = this.minimapCanvas.height / height;
        const minimapScale = Math.min(minimapScaleX, minimapScaleY);
        
        // ë¯¸ë‹ˆë§µ ì´ˆê¸°í™”
        this.minimapCtx.clearRect(0, 0, this.minimapCanvas.width, this.minimapCanvas.height);
        
        // ë°°ê²½
        this.minimapCtx.fillStyle = '#1e4620';
        this.minimapCtx.fillRect(0, 0, this.minimapCanvas.width, this.minimapCanvas.height);
        
        // ë§µ ì˜ì—­ í‘œì‹œ
        const mapWidthOnMinimap = width * minimapScale;
        const mapHeightOnMinimap = height * minimapScale;
        const mapOffsetX = (this.minimapCanvas.width - mapWidthOnMinimap) / 2;
        const mapOffsetY = (this.minimapCanvas.height - mapHeightOnMinimap) / 2;
        
        // ë¯¸ë‹ˆë§µì—ì„œë„ ê²½ê³„ì„ ì„ ë” ëˆˆì— ë„ê²Œ
        this.minimapCtx.strokeStyle = '#00d4ff'; // ë°ì€ íŒŒë€ìƒ‰
        this.minimapCtx.lineWidth = 2;
        this.minimapCtx.strokeRect(mapOffsetX, mapOffsetY, mapWidthOnMinimap, mapHeightOnMinimap);
        
        // íŠ¸ë™ ê·¸ë¦¬ê¸°
        if (this.previewMode && this.points.length >= 2) {
          const smoothCenterPath = this.getSmoothPath(this.points, 100);
          const { innerPath, outerPath } = this.getTrackBounds(smoothCenterPath, trackWidth);
          const smoothInnerPath = this.getSmoothPath(innerPath, 100);
          const smoothOuterPath = this.getSmoothPath(outerPath, 100);
          
          // íŠ¸ë™ ì±„ìš°ê¸°
          this.minimapCtx.fillStyle = '#4a4a4a';
          this.minimapCtx.beginPath();
          if (smoothOuterPath.length > 0) {
            const p0 = smoothOuterPath[0];
            this.minimapCtx.moveTo(mapOffsetX + p0.x * minimapScale, mapOffsetY + p0.y * minimapScale);
            for (let i = 1; i < smoothOuterPath.length; i++) {
              const p = smoothOuterPath[i];
              this.minimapCtx.lineTo(mapOffsetX + p.x * minimapScale, mapOffsetY + p.y * minimapScale);
            }
            if (this.points.length > 2) {
              this.minimapCtx.closePath();
            }
          }
          if (smoothInnerPath.length > 0 && this.points.length > 2) {
            const p0 = smoothInnerPath[0];
            this.minimapCtx.moveTo(mapOffsetX + p0.x * minimapScale, mapOffsetY + p0.y * minimapScale);
            for (let i = smoothInnerPath.length - 1; i >= 0; i--) {
              const p = smoothInnerPath[i];
              this.minimapCtx.lineTo(mapOffsetX + p.x * minimapScale, mapOffsetY + p.y * minimapScale);
            }
            this.minimapCtx.closePath();
          }
          this.minimapCtx.fill('evenodd');
          
          // ì¤‘ì•™ì„ 
          this.minimapCtx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
          this.minimapCtx.lineWidth = 1;
          this.minimapCtx.beginPath();
          if (smoothCenterPath.length > 0) {
            const p0 = smoothCenterPath[0];
            this.minimapCtx.moveTo(mapOffsetX + p0.x * minimapScale, mapOffsetY + p0.y * minimapScale);
            for (let i = 1; i < smoothCenterPath.length; i++) {
              const p = smoothCenterPath[i];
              this.minimapCtx.lineTo(mapOffsetX + p.x * minimapScale, mapOffsetY + p.y * minimapScale);
            }
            if (this.points.length > 2) {
              this.minimapCtx.closePath();
            }
          }
          this.minimapCtx.stroke();
        } else if (this.points.length >= 2) {
          // í¸ì§‘ ëª¨ë“œ: í¬ì¸íŠ¸ë§Œ í‘œì‹œ
          this.minimapCtx.strokeStyle = '#00ff88';
          this.minimapCtx.lineWidth = 1;
          this.minimapCtx.beginPath();
          const p0 = this.points[0];
          this.minimapCtx.moveTo(mapOffsetX + p0.x * minimapScale, mapOffsetY + p0.y * minimapScale);
          for (let i = 1; i < this.points.length; i++) {
            const p = this.points[i];
            this.minimapCtx.lineTo(mapOffsetX + p.x * minimapScale, mapOffsetY + p.y * minimapScale);
          }
          if (this.points.length > 2) {
            this.minimapCtx.closePath();
          }
          this.minimapCtx.stroke();
        }
        
        // í¬ì¸íŠ¸ í‘œì‹œ
        this.points.forEach((p, i) => {
          const x = mapOffsetX + p.x * minimapScale;
          const y = mapOffsetY + p.y * minimapScale;
          this.minimapCtx.fillStyle = i === this.selectedPointIndex ? '#00ff88' : '#fff';
          this.minimapCtx.beginPath();
          this.minimapCtx.arc(x, y, 2, 0, Math.PI * 2);
          this.minimapCtx.fill();
        });
        
        // í˜„ì¬ ë·°í¬íŠ¸ í‘œì‹œ
        const viewportWorldLeft = -this.offsetX / this.zoom;
        const viewportWorldTop = -this.offsetY / this.zoom;
        const viewportWorldRight = (this.canvas.width - this.offsetX) / this.zoom;
        const viewportWorldBottom = (this.canvas.height - this.offsetY) / this.zoom;
        
        const viewportMinimapX = mapOffsetX + viewportWorldLeft * minimapScale;
        const viewportMinimapY = mapOffsetY + viewportWorldTop * minimapScale;
        const viewportMinimapWidth = (viewportWorldRight - viewportWorldLeft) * minimapScale;
        const viewportMinimapHeight = (viewportWorldBottom - viewportWorldTop) * minimapScale;
        
        this.minimapCtx.strokeStyle = '#00ff88';
        this.minimapCtx.lineWidth = 2;
        this.minimapCtx.strokeRect(viewportMinimapX, viewportMinimapY, viewportMinimapWidth, viewportMinimapHeight);
      }

      addPoint(x, y) {
        // ê¸°ë³¸ê°’ì€ ì§ì„ , ì´ì „ í¬ì¸íŠ¸ê°€ ê³¡ì„ ì´ë©´ ê³¡ì„ ìœ¼ë¡œ ì„¤ì •
        const type = this.points.length > 0 && this.points[this.points.length - 1].type === 'curve' ? 'curve' : 'straight';
        this.points.push({ x, y, type });
        this.selectedPointIndex = this.points.length - 1;
        this.selectedCheckpointIndex = -1;
        this.updatePointList();
        this.updateSelectedPointInfo();
        this.updateCheckpointList();
        this.updateSelectedCheckpointInfo();
        this.updateCodeOutput();
        this.saveToStorage(); // ì €ì¥
        this.render();
      }
      
      addCheckpoint(x, y, angle = 0) {
        this.checkpoints.push({ x, y, angle });
        this.selectedCheckpointIndex = this.checkpoints.length - 1;
        this.selectedPointIndex = -1;
        this.updatePointList();
        this.updateSelectedPointInfo();
        this.updateCheckpointList();
        this.updateSelectedCheckpointInfo();
        this.updateCodeOutput();
        this.saveToStorage(); // ì €ì¥
        this.render();
      }
      
      deleteCheckpoint(index) {
        this.checkpoints.splice(index, 1);
        if (this.selectedCheckpointIndex >= this.checkpoints.length) {
          this.selectedCheckpointIndex = this.checkpoints.length - 1;
        }
        this.updateCheckpointList();
        this.updateSelectedCheckpointInfo();
        this.updateCodeOutput();
        this.saveToStorage(); // ì €ì¥
        this.render();
      }
      
      addKerb(x, y, length = 300) {
        // íŠ¸ë™ ê²½ê³„ë¥¼ ë”°ë¼ ê²½ë¡œ ê¸°ë°˜ ì—°ì„ ì¶”ê°€
        console.log('addKerb called:', { x, y, length });
        
        const boundary = this.findNearestTrackBoundary(x, y, length);
        if (!boundary || !boundary.kerbPath || boundary.kerbPath.length < 2) {
          console.warn('Unable to create kerb: no valid path found');
          return;
        }
        
        this.curbs.push({ 
          centerPath: boundary.kerbPath, // ì—°ì„ì˜ ì¤‘ì‹¬ ê²½ë¡œ
          width: 20, // ì—°ì„ì˜ ë‘ê»˜ (í­)
          length: length, // ì—°ì„ì˜ ê¸¸ì´
          trackSide: boundary.isInner ? 'inner' : 'outer'
        });
        
        this.selectedKerbIndex = this.curbs.length - 1;
        this.selectedPointIndex = -1;
        this.selectedCheckpointIndex = -1;
        this.updatePointList();
        this.updateSelectedPointInfo();
        this.updateCheckpointList();
        this.updateSelectedCheckpointInfo();
        this.updateKerbList();
        this.updateSelectedKerbInfo();
        this.updateCodeOutput();
        this.saveToStorage(); // ì €ì¥
        this.render();
        console.log('Kerb added, total curbs:', this.curbs.length);
      }
      
      deleteKerb(index) {
        this.curbs.splice(index, 1);
        if (this.selectedKerbIndex >= this.curbs.length) {
          this.selectedKerbIndex = this.curbs.length - 1;
        }
        this.updateKerbList();
        this.updateSelectedKerbInfo();
        this.updateCodeOutput();
        this.saveToStorage(); // ì €ì¥
        this.render();
      }
      
      selectKerb(index) {
        this.selectedKerbIndex = index;
        this.selectedPointIndex = -1;
        this.selectedCheckpointIndex = -1;
        this.updatePointList();
        this.updateSelectedPointInfo();
        this.updateCheckpointList();
        this.updateSelectedCheckpointInfo();
        this.updateKerbList();
        this.updateSelectedKerbInfo();
        this.render();
      }
      
      updateKerbList() {
        const list = document.getElementById('kerbList');
        if (!list) return;
        
        if (this.curbs.length === 0) {
          list.innerHTML = '<div style="color: #666; font-size: 11px; text-align: center; padding: 20px;">ì—°ì„ì„ ì¶”ê°€í•˜ë ¤ë©´ ì—°ì„ ì¶”ê°€ ëª¨ë“œë¥¼ ì„ íƒí•˜ì„¸ìš”</div>';
          return;
        }

        list.innerHTML = this.curbs.map((kerb, i) => {
          let displayInfo = '';
          if (kerb.centerPath && kerb.centerPath.length > 0) {
            // ê²½ë¡œ ê¸°ë°˜ ì—°ì„
            const midIdx = Math.floor(kerb.centerPath.length / 2);
            const midPoint = kerb.centerPath[midIdx];
            displayInfo = `
              <span>ì—°ì„ ${i + 1}</span>
              <span class="point-coords">${kerb.trackSide === 'inner' ? 'ë‚´ë¶€' : 'ì™¸ë¶€'}</span>
              <span style="font-size: 10px; color: #ff9500;">
                ${kerb.length || 300}px
              </span>
            `;
          } else {
            // êµ¬í˜• í¬ë§·
            displayInfo = `
              <span>ì—°ì„ ${i + 1}</span>
              <span class="point-coords">(${kerb.x}, ${kerb.y})</span>
              <span style="font-size: 10px; color: #ff9500;">
                ${kerb.width || 200}px
              </span>
            `;
          }
          
          return `
            <div class="point-item ${i === this.selectedKerbIndex ? 'selected' : ''}" 
                 data-kerb-index="${i}">
              ${displayInfo}
              <div class="point-actions">
                <button class="delete-kerb-btn" data-kerb-index="${i}">ì‚­ì œ</button>
              </div>
            </div>
          `;
        }).join('');
        
        // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì¶”ê°€
        list.querySelectorAll('.point-item').forEach(item => {
          item.addEventListener('click', (e) => {
            if (!e.target.classList.contains('delete-kerb-btn')) {
              const index = parseInt(item.dataset.kerbIndex);
              this.selectKerb(index);
            }
          });
        });
        
        // ì‚­ì œ ë²„íŠ¼ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
        list.querySelectorAll('.delete-kerb-btn').forEach(btn => {
          btn.addEventListener('click', (e) => {
            e.stopPropagation();
            const index = parseInt(btn.dataset.kerbIndex);
            this.deleteKerb(index);
          });
        });
      }
      
      updateSelectedKerbInfo() {
        const infoDiv = document.getElementById('selectedKerbInfo');
        if (!infoDiv) return;
        
        const editGroup = document.getElementById('kerbEditGroup');
        const editGroup2 = document.getElementById('kerbEditGroup2');
        const editGroup3 = document.getElementById('kerbEditGroup3');
        const editGroup4 = document.getElementById('kerbEditGroup4');
        const editGroup5 = document.getElementById('kerbEditGroup5');

        if (this.selectedKerbIndex >= 0 && this.selectedKerbIndex < this.curbs.length) {
          const kerb = this.curbs[this.selectedKerbIndex];
          
          // ê²½ë¡œ ê¸°ë°˜ ì—°ì„
          if (kerb.centerPath && kerb.centerPath.length > 0) {
            const sideText = kerb.trackSide === 'inner' ? 'ë‚´ë¶€' : 'ì™¸ë¶€';
            const widthText = kerb.width || 20;
            const lengthText = kerb.length || 300;
            infoDiv.textContent = `ì—°ì„ ${this.selectedKerbIndex + 1}: ${sideText} | í­: ${widthText}px, ê¸¸ì´: ${lengthText}px`;
            
            // ê¸¸ì´ ì¡°ì ˆë§Œ ê°€ëŠ¥í•˜ë„ë¡ (ìœ„ì¹˜ëŠ” ë“œë˜ê·¸ë¡œ)
            if (document.getElementById('kerbLength')) {
              document.getElementById('kerbLength').value = lengthText;
            }
            // ë‹¤ë¥¸ í•„ë“œë“¤ì€ ìˆ¨ê¸°ê±°ë‚˜ ë¹„í™œì„±í™”
            if (editGroup) editGroup.style.display = 'none';
            if (editGroup2) editGroup2.style.display = 'none';
            if (editGroup3) editGroup3.style.display = 'none';
            if (editGroup4) editGroup4.style.display = 'none';
            if (editGroup5) editGroup5.style.display = 'block'; // ê¸¸ì´ë§Œ í‘œì‹œ
          }
          // êµ¬í˜• í¬ë§·
          else if (kerb.x !== undefined && kerb.y !== undefined) {
            const angleDeg = ((kerb.angle || 0) * 180 / Math.PI).toFixed(1);
            infoDiv.textContent = `ì—°ì„ ${this.selectedKerbIndex + 1}: (${kerb.x}, ${kerb.y}) [${angleDeg}Â°] ê¸¸ì´: ${kerb.width || 200}px`;
            if (document.getElementById('kerbX')) document.getElementById('kerbX').value = kerb.x;
            if (document.getElementById('kerbY')) document.getElementById('kerbY').value = kerb.y;
            if (document.getElementById('kerbAngle')) document.getElementById('kerbAngle').value = (kerb.angle || 0).toFixed(3);
            if (document.getElementById('kerbAngleDeg')) document.getElementById('kerbAngleDeg').value = Math.round((kerb.angle || 0) * 180 / Math.PI);
            if (document.getElementById('kerbLength')) document.getElementById('kerbLength').value = kerb.width || 200;
            if (editGroup) editGroup.style.display = 'block';
            if (editGroup2) editGroup2.style.display = 'block';
            if (editGroup3) editGroup3.style.display = 'block';
            if (editGroup4) editGroup4.style.display = 'block';
            if (editGroup5) editGroup5.style.display = 'block';
          }
        } else {
          infoDiv.textContent = 'ì—°ì„ì„ ì„ íƒí•˜ì„¸ìš”';
          if (editGroup) editGroup.style.display = 'none';
          if (editGroup2) editGroup2.style.display = 'none';
          if (editGroup3) editGroup3.style.display = 'none';
          if (editGroup4) editGroup4.style.display = 'none';
          if (editGroup5) editGroup5.style.display = 'none';
        }
      }
      
      updateSelectedKerb() {
        if (this.selectedKerbIndex >= 0) {
          const currentKerb = this.curbs[this.selectedKerbIndex];
          const length = parseFloat(document.getElementById('kerbLength')?.value || 300);
          
          // ê²½ë¡œ ê¸°ë°˜ ì—°ì„
          if (currentKerb.centerPath && currentKerb.centerPath.length > 0) {
            if (!isNaN(length) && length > 0) {
              // ê¸¸ì´ë§Œ ë³€ê²½ (ì¤‘ì‹¬ì  ìœ ì§€í•˜ë©´ì„œ ê²½ë¡œ ì¬ìƒì„±)
              const midIdx = Math.floor(currentKerb.centerPath.length / 2);
              const midPoint = currentKerb.centerPath[midIdx];
              
              // ì¤‘ì‹¬ì  ê¸°ì¤€ìœ¼ë¡œ ìƒˆ ê²½ë¡œ ìƒì„±
              const boundary = this.findNearestTrackBoundary(midPoint.x, midPoint.y, length);
              if (boundary && boundary.kerbPath && boundary.kerbPath.length >= 2) {
                this.curbs[this.selectedKerbIndex] = {
                  centerPath: boundary.kerbPath,
                  width: currentKerb.width || 20,
                  length: length,
                  trackSide: boundary.isInner ? 'inner' : 'outer'
                };
              } else {
                // ê²½ë¡œ ìƒì„± ì‹¤íŒ¨ ì‹œ ê¸¸ì´ë§Œ ì—…ë°ì´íŠ¸
                currentKerb.length = length;
              }
            }
          }
          // êµ¬í˜• í¬ë§·
          else if (currentKerb.x !== undefined && currentKerb.y !== undefined) {
            const x = parseFloat(document.getElementById('kerbX')?.value || currentKerb.x);
            const y = parseFloat(document.getElementById('kerbY')?.value || currentKerb.y);
            const angle = parseFloat(document.getElementById('kerbAngle')?.value || currentKerb.angle || 0);
            if (!isNaN(x) && !isNaN(y) && !isNaN(angle) && !isNaN(length)) {
              this.curbs[this.selectedKerbIndex] = { 
                x, 
                y, 
                angle, 
                width: length,
                height: currentKerb.height || 20
              };
            }
          }
          
          this.updateSelectedKerbInfo();
          this.updateCodeOutput();
          this.saveToStorage(); // ì €ì¥
          this.render();
        }
      }

      deletePoint(index) {
        this.points.splice(index, 1);
        if (this.selectedPointIndex >= this.points.length) {
          this.selectedPointIndex = this.points.length - 1;
        }
        this.updatePointList();
        this.updateSelectedPointInfo();
        this.updateCodeOutput();
        this.saveToStorage(); // ì €ì¥
        this.render();
      }

      updateSelectedPoint() {
        if (this.selectedPointIndex >= 0) {
          const x = parseFloat(document.getElementById('pointX').value);
          const y = parseFloat(document.getElementById('pointY').value);
          if (!isNaN(x) && !isNaN(y)) {
            const currentPoint = this.points[this.selectedPointIndex];
            this.points[this.selectedPointIndex] = { 
              x, 
              y, 
              type: currentPoint.type || 'straight' 
            };
            this.updateCodeOutput();
            this.saveToStorage(); // ì €ì¥
            this.render();
          }
        }
      }

      updateSelectedPointInfo() {
        const infoDiv = document.getElementById('selectedPointInfo');
        const editGroup = document.getElementById('pointEditGroup');
        const editGroup2 = document.getElementById('pointEditGroup2');
        const editGroup3 = document.getElementById('pointEditGroup3');

        if (this.selectedPointIndex >= 0 && this.selectedPointIndex < this.points.length) {
          const p = this.points[this.selectedPointIndex];
          const typeText = p.type === 'curve' ? 'ê³¡ì„ ' : 'ì§ì„ ';
          infoDiv.textContent = `í¬ì¸íŠ¸ ${this.selectedPointIndex + 1}: (${p.x}, ${p.y}) [${typeText}]`;
          document.getElementById('pointX').value = p.x;
          document.getElementById('pointY').value = p.y;
          editGroup.style.display = 'block';
          editGroup2.style.display = 'block';
          editGroup3.style.display = 'block';
          
          // íƒ€ì… ë²„íŠ¼ ìƒíƒœ ì—…ë°ì´íŠ¸
          const straightBtn = document.getElementById('setStraightBtn');
          const curveBtn = document.getElementById('setCurveBtn');
          straightBtn.classList.toggle('active', p.type === 'straight');
          curveBtn.classList.toggle('active', p.type === 'curve');
        } else {
          infoDiv.textContent = 'í¬ì¸íŠ¸ë¥¼ ì„ íƒí•˜ì„¸ìš”';
          editGroup.style.display = 'none';
          editGroup2.style.display = 'none';
          editGroup3.style.display = 'none';
        }
      }
      
      setPointType(type) {
        if (this.selectedPointIndex >= 0 && this.selectedPointIndex < this.points.length) {
          this.points[this.selectedPointIndex].type = type;
          this.updatePointList();
          this.updateSelectedPointInfo();
          this.updateCodeOutput();
          this.saveToStorage(); // ì €ì¥
          this.render();
        }
      }

      updatePointList() {
        const list = document.getElementById('pointList');
        if (this.points.length === 0) {
          list.innerHTML = '<div style="color: #666; font-size: 11px; text-align: center; padding: 20px;">í¬ì¸íŠ¸ë¥¼ ì¶”ê°€í•˜ë ¤ë©´ ìº”ë²„ìŠ¤ë¥¼ í´ë¦­í•˜ì„¸ìš”</div>';
          return;
        }

        list.innerHTML = this.points.map((p, i) => `
          <div class="point-item ${i === this.selectedPointIndex ? 'selected' : ''}" 
               data-point-index="${i}">
            <span>í¬ì¸íŠ¸ ${i + 1}</span>
            <span class="point-coords">(${p.x}, ${p.y})</span>
            <span style="font-size: 10px; color: ${p.type === 'curve' ? '#ff6b6b' : '#4ecdc4'};">
              ${p.type === 'curve' ? 'ê³¡ì„ ' : 'ì§ì„ '}
            </span>
            <div class="point-actions">
              <button class="delete-point-btn" data-point-index="${i}">ì‚­ì œ</button>
            </div>
          </div>
        `).join('');
        
        // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì¶”ê°€
        list.querySelectorAll('.point-item').forEach(item => {
          item.addEventListener('click', (e) => {
            // ì‚­ì œ ë²„íŠ¼ í´ë¦­ì´ ì•„ë‹Œ ê²½ìš°ì—ë§Œ í¬ì¸íŠ¸ ì„ íƒ
            if (!e.target.classList.contains('delete-point-btn')) {
              const index = parseInt(item.dataset.pointIndex);
              this.selectPoint(index);
            }
          });
        });
        
        // ì‚­ì œ ë²„íŠ¼ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
        list.querySelectorAll('.delete-point-btn').forEach(btn => {
          btn.addEventListener('click', (e) => {
            e.stopPropagation();
            const index = parseInt(btn.dataset.pointIndex);
            this.deletePoint(index);
          });
        });
      }

      selectPoint(index) {
        this.selectedPointIndex = index;
        this.selectedCheckpointIndex = -1;
        this.updatePointList();
        this.updateSelectedPointInfo();
        this.updateCheckpointList();
        this.updateSelectedCheckpointInfo();
        this.render();
      }
      
      selectCheckpoint(index) {
        this.selectedCheckpointIndex = index;
        this.selectedPointIndex = -1;
        this.updatePointList();
        this.updateSelectedPointInfo();
        this.updateCheckpointList();
        this.updateSelectedCheckpointInfo();
        this.render();
      }
      
      updateCheckpointList() {
        const list = document.getElementById('checkpointList');
        if (!list) return;
        
        if (this.checkpoints.length === 0) {
          list.innerHTML = '<div style="color: #666; font-size: 11px; text-align: center; padding: 20px;">ì²´í¬í¬ì¸íŠ¸ë¥¼ ì¶”ê°€í•˜ë ¤ë©´ ì²´í¬í¬ì¸íŠ¸ ì¶”ê°€ ëª¨ë“œë¥¼ ì„ íƒí•˜ì„¸ìš”</div>';
          return;
        }

        list.innerHTML = this.checkpoints.map((cp, i) => `
          <div class="point-item ${i === this.selectedCheckpointIndex ? 'selected' : ''}" 
               data-checkpoint-index="${i}">
            <span>ì²´í¬í¬ì¸íŠ¸ ${i + 1}</span>
            <span class="point-coords">(${cp.x}, ${cp.y})</span>
            <span style="font-size: 10px; color: #ffd700;">
              ${(cp.angle * 180 / Math.PI).toFixed(0)}Â°
            </span>
            <div class="point-actions">
              <button class="delete-checkpoint-btn" data-checkpoint-index="${i}">ì‚­ì œ</button>
            </div>
          </div>
        `).join('');
        
        // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì¶”ê°€
        list.querySelectorAll('.point-item').forEach(item => {
          item.addEventListener('click', (e) => {
            // ì‚­ì œ ë²„íŠ¼ í´ë¦­ì´ ì•„ë‹Œ ê²½ìš°ì—ë§Œ ì²´í¬í¬ì¸íŠ¸ ì„ íƒ
            if (!e.target.classList.contains('delete-checkpoint-btn')) {
              const index = parseInt(item.dataset.checkpointIndex);
              this.selectCheckpoint(index);
            }
          });
        });
        
        // ì‚­ì œ ë²„íŠ¼ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
        list.querySelectorAll('.delete-checkpoint-btn').forEach(btn => {
          btn.addEventListener('click', (e) => {
            e.stopPropagation();
            const index = parseInt(btn.dataset.checkpointIndex);
            this.deleteCheckpoint(index);
          });
        });
      }
      
      updateSelectedCheckpointInfo() {
        const infoDiv = document.getElementById('selectedCheckpointInfo');
        if (!infoDiv) return;
        
        const editGroup = document.getElementById('checkpointEditGroup');
        const editGroup2 = document.getElementById('checkpointEditGroup2');
        const editGroup3 = document.getElementById('checkpointEditGroup3');
        const editGroup4 = document.getElementById('checkpointEditGroup4');

        if (this.selectedCheckpointIndex >= 0 && this.selectedCheckpointIndex < this.checkpoints.length) {
          const cp = this.checkpoints[this.selectedCheckpointIndex];
          const angleDeg = (cp.angle * 180 / Math.PI).toFixed(1);
          infoDiv.textContent = `ì²´í¬í¬ì¸íŠ¸ ${this.selectedCheckpointIndex + 1}: (${cp.x}, ${cp.y}) [${angleDeg}Â°]`;
          if (document.getElementById('checkpointX')) document.getElementById('checkpointX').value = cp.x;
          if (document.getElementById('checkpointY')) document.getElementById('checkpointY').value = cp.y;
          if (document.getElementById('checkpointAngle')) document.getElementById('checkpointAngle').value = cp.angle.toFixed(3);
          if (document.getElementById('checkpointAngleDeg')) document.getElementById('checkpointAngleDeg').value = Math.round(cp.angle * 180 / Math.PI);
          if (editGroup) editGroup.style.display = 'block';
          if (editGroup2) editGroup2.style.display = 'block';
          if (editGroup3) editGroup3.style.display = 'block';
          if (editGroup4) editGroup4.style.display = 'block';
        } else {
          infoDiv.textContent = 'ì²´í¬í¬ì¸íŠ¸ë¥¼ ì„ íƒí•˜ì„¸ìš”';
          if (editGroup) editGroup.style.display = 'none';
          if (editGroup2) editGroup2.style.display = 'none';
          if (editGroup3) editGroup3.style.display = 'none';
          if (editGroup4) editGroup4.style.display = 'none';
        }
      }
      
      updateSelectedCheckpoint() {
        if (this.selectedCheckpointIndex >= 0) {
          const x = parseFloat(document.getElementById('checkpointX').value);
          const y = parseFloat(document.getElementById('checkpointY').value);
          const angle = parseFloat(document.getElementById('checkpointAngle').value);
          if (!isNaN(x) && !isNaN(y) && !isNaN(angle)) {
            this.checkpoints[this.selectedCheckpointIndex] = { x, y, angle };
            this.updateSelectedCheckpointInfo();
            this.updateCodeOutput();
            this.saveToStorage(); // ì €ì¥
            this.render();
          }
        }
      }

      // ì§ì„ ê³¼ ê³¡ì„ ì„ êµ¬ë¶„í•˜ì—¬ ê²½ë¡œ ìƒì„± (ì „í™˜ ì§€ì  ë¶€ë“œëŸ½ê²Œ ì²˜ë¦¬)
      getSmoothPath(points, targetPoints = 400) {
        if (points.length < 2) return points;
        
        const smoothPath = [];
        const numPoints = points.length;
        
        for (let i = 0; i < numPoints; i++) {
          const p1 = points[i];
          const p2 = points[(i + 1) % numPoints];
          const p0 = points[(i - 1 + numPoints) % numPoints];
          const p3 = points[(i + 2) % numPoints];
          
          const p1Type = p1.type || 'straight';
          const p2Type = p2.type || 'straight';
          
          // ì „í™˜ êµ¬ê°„ ê°ì§€: ì§ì„ ->ê³¡ì„  ë˜ëŠ” ê³¡ì„ ->ì§ì„ 
          const isTransition = (p1Type === 'straight' && p2Type === 'curve') || 
                               (p1Type === 'curve' && p2Type === 'straight');
          
          // ê³¡ì„  êµ¬ê°„ ë˜ëŠ” ì „í™˜ êµ¬ê°„ì¸ì§€ í™•ì¸
          const isCurve = p1Type === 'curve' || p2Type === 'curve' || isTransition;
          
          if (isCurve && numPoints >= 4) {
            // ê³¡ì„  êµ¬ê°„ ë˜ëŠ” ì „í™˜ êµ¬ê°„: Catmull-Rom ìŠ¤í”Œë¼ì¸ ì‚¬ìš©
            const steps = Math.ceil(targetPoints / numPoints);
            
            // ì „í™˜ êµ¬ê°„ì¸ ê²½ìš° ë” ë§ì€ í¬ì¸íŠ¸ë¡œ ë¶€ë“œëŸ½ê²Œ ì²˜ë¦¬
            const transitionSteps = isTransition ? steps * 1.5 : steps;
            
            for (let j = 0; j < transitionSteps; j++) {
              const t = j / transitionSteps;
              const t2 = t * t;
              const t3 = t2 * t;
              
              const x = 0.5 * (
                (2 * p1.x) +
                (-p0.x + p2.x) * t +
                (2 * p0.x - 5 * p1.x + 4 * p2.x - p3.x) * t2 +
                (-p0.x + 3 * p1.x - 3 * p2.x + p3.x) * t3
              );
              
              const y = 0.5 * (
                (2 * p1.y) +
                (-p0.y + p2.y) * t +
                (2 * p0.y - 5 * p1.y + 4 * p2.y - p3.y) * t2 +
                (-p0.y + 3 * p1.y - 3 * p2.y + p3.y) * t3
              );
              
              smoothPath.push({ x, y });
            }
          } else {
            // ìˆœìˆ˜ ì§ì„  êµ¬ê°„: ë‹¨ìˆœ ì„ í˜• ë³´ê°„
            const steps = Math.max(2, Math.ceil(targetPoints / numPoints / 2));
            for (let j = 0; j <= steps; j++) {
              const t = j / steps;
              smoothPath.push({
                x: p1.x + (p2.x - p1.x) * t,
                y: p1.y + (p2.y - p1.y) * t
              });
            }
          }
        }
        
        return smoothPath;
      }
      
      // ê³¡ì„  ì—°ì„ ê·¸ë¦¬ê¸°
      // ê²½ë¡œ ê¸°ë°˜ ì—°ì„ ê·¸ë¦¬ê¸° - í•˜ë‚˜ì˜ ì—°ì†ëœ í˜•íƒœë¡œ (íŠ¸ë™ ë°”ê¹¥ìª½ì—ë§Œ ë°°ì¹˜)
      drawPathBasedKerb(centerPath, kerbWidth, trackSide = 'outer') {
        if (!centerPath || centerPath.length < 2) return;

        // ëˆ„ì  ê¸¸ì´ í…Œì´ë¸”
        const cumulative = [0];
        for (let i = 1; i < centerPath.length; i++) {
          const p1 = centerPath[i - 1];
          const p2 = centerPath[i];
          const dx = p2.x - p1.x;
          const dy = p2.y - p1.y;
          cumulative.push(cumulative[i - 1] + Math.hypot(dx, dy));
        }
        const totalLength = cumulative[cumulative.length - 1];

        // ê²½ë¡œìƒì˜ íŠ¹ì • ê±°ë¦¬ì—ì„œ ìœ„ì¹˜ì™€ ë²•ì„ ì„ ê³„ì‚°
        const getPointAt = (dist) => {
          const clamped = Math.min(Math.max(dist, 0), totalLength);
          // í•´ë‹¹ ì„¸ê·¸ë¨¼íŠ¸ ì°¾ê¸°
          let idx = cumulative.findIndex((len) => len >= clamped);
          if (idx === -1) idx = cumulative.length - 1;
          if (idx === 0) idx = 1;

          const p1 = centerPath[idx - 1];
          const p2 = centerPath[idx];
          const segLen = cumulative[idx] - cumulative[idx - 1] || 1;
          const t = (clamped - cumulative[idx - 1]) / segLen;

          const x = p1.x + (p2.x - p1.x) * t;
          const y = p1.y + (p2.y - p1.y) * t;

          const dx = p2.x - p1.x;
          const dy = p2.y - p1.y;
          const len = Math.hypot(dx, dy) || 1;

          // ê¸°ë³¸ ë²•ì„  (ì¢Œì¸¡ ê¸°ì¤€)
          const nx = -dy / len;
          const ny = dx / len;
          const sign = trackSide === 'inner' ? 1 : -1;

          return {
            track: { x, y },
            outer: { x: x + nx * kerbWidth * sign, y: y + ny * kerbWidth * sign },
            tangent: { x: dx / len, y: dy / len }
          };
        };

        const blockSize = 40; // ìƒ‰ìƒ íŒ¨í„´ ê¸¸ì´
        const stepSize = 0.5; // ê²½ë¡œë¥¼ ë”°ë¼ ê·¸ë¦´ ë•Œì˜ ê°„ê²© (ì‘ì„ìˆ˜ë¡ ë¶€ë“œëŸ¬ì›€)

        this.ctx.save();
        this.ctx.globalCompositeOperation = 'source-over';

        // ê²½ë¡œë¥¼ ë”°ë¼ ìƒ‰ìƒë§Œ ë³€ê²½í•˜ë©´ì„œ ì—°ì†ì ìœ¼ë¡œ ê·¸ë¦¬ê¸°
        // ìƒ‰ìƒì´ ë°”ë€ŒëŠ” ì§€ì ë“¤ì„ ë¨¼ì € ì°¾ê¸°
        const colorChangePoints = [0];
        for (let d = blockSize; d < totalLength; d += blockSize) {
          colorChangePoints.push(d);
        }
        colorChangePoints.push(totalLength);

        // ê° ìƒ‰ìƒ ë¸”ë¡ì„ ì—°ì†ì ìœ¼ë¡œ ê·¸ë¦¬ê¸°
        for (let i = 0; i < colorChangePoints.length - 1; i++) {
          const startDist = colorChangePoints[i];
          const endDist = colorChangePoints[i + 1];
          const blockIdx = Math.floor(startDist / blockSize);
          const isRed = blockIdx % 2 === 0;
          const color = isRed ? '#ff0000' : '#ffffff';

          // íŠ¸ë™ ê²½ê³„ì„ ê³¼ ë°”ê¹¥ìª½ ê²½ê³„ì„ ì„ ë”°ë¼ ë¶€ë“œëŸ½ê²Œ ê·¸ë¦¬ê¸°
          this.ctx.beginPath();
          
          // íŠ¸ë™ ê²½ê³„ì„  (ì•ì—ì„œ ë’¤ë¡œ)
          for (let d = startDist; d <= endDist; d += stepSize) {
            const dist = Math.min(d, endDist);
            const pt = getPointAt(dist);
            if (d === startDist) {
              this.ctx.moveTo(pt.track.x, pt.track.y);
            } else {
              this.ctx.lineTo(pt.track.x, pt.track.y);
            }
          }
          
          // ë°”ê¹¥ìª½ ê²½ê³„ì„  (ë’¤ì—ì„œ ì•ìœ¼ë¡œ)
          for (let d = endDist; d >= startDist; d -= stepSize) {
            const dist = Math.max(d, startDist);
            const pt = getPointAt(dist);
            this.ctx.lineTo(pt.outer.x, pt.outer.y);
          }
          
          this.ctx.closePath();
          this.ctx.fillStyle = color;
          this.ctx.fill();
        }

        // ê²€ì€ìƒ‰ í…Œë‘ë¦¬ ì œê±°ë¨

        this.ctx.restore();
      }
      
      // êµ¬í˜• ê³¡ì„  ì—°ì„ ê·¸ë¦¬ê¸° (í•˜ìœ„ í˜¸í™˜ì„±)
      drawCurvedKerb(pathSegment, height, isSelected) {
        if (!pathSegment || pathSegment.length < 2) return;
        
        const blockWidth = 20; // ê° ë¸”ë¡ì˜ ë„ˆë¹„
        const blockHeight = height;
        
        this.ctx.save();
        this.ctx.globalCompositeOperation = 'source-over';
        
        // ê³¡ì„  ê²½ë¡œë¥¼ ë”°ë¼ ì‘ì€ ë¸”ë¡ë“¤ì„ ê·¸ë¦¬ê¸°
        for (let i = 0; i < pathSegment.length - 1; i++) {
          const p1 = pathSegment[i];
          const p2 = pathSegment[i + 1];
          
          // ë‘ ì  ì‚¬ì´ì˜ ê±°ë¦¬ì™€ ê°ë„ ê³„ì‚°
          const dx = p2.x - p1.x;
          const dy = p2.y - p1.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          const angle = Math.atan2(dy, dx);
          
          // ë¸”ë¡ ê°œìˆ˜ ê³„ì‚°
          const blockCount = Math.max(1, Math.floor(dist / blockWidth));
          
          for (let j = 0; j < blockCount; j++) {
            const t = j / blockCount;
            const x = p1.x + dx * t;
            const y = p1.y + dy * t;
            const isRed = (i * blockCount + j) % 2 === 0;
            
            this.ctx.save();
            this.ctx.translate(x, y);
            this.ctx.rotate(angle);
            
            // í°ìƒ‰/ë¹¨ê°„ìƒ‰ íŒ¨í„´ (ì„ íƒ ìƒíƒœì™€ ê´€ê³„ì—†ì´ í•­ìƒ ë¹¨ê°„ìƒ‰/í•˜ì–€ìƒ‰)
            const color = isRed ? '#ff0000' : '#ffffff';
            this.ctx.fillStyle = color;
            this.ctx.fillRect(-blockWidth / 2, -blockHeight / 2, blockWidth, blockHeight);
            
            // ê²€ì€ìƒ‰ í…Œë‘ë¦¬ ì œê±°ë¨
            
            this.ctx.restore();
          }
        }
        
        this.ctx.restore();
      }

      // íŠ¸ë™ ê²½ê³„ ìƒì„± (ì¤‘ì•™ì„ ì—ì„œ ì¢Œìš°ë¡œ í™•ì¥)
      getTrackBounds(centerPath, trackWidth) {
        const innerPath = [];
        const outerPath = [];
        
        for (let i = 0; i < centerPath.length; i++) {
          const curr = centerPath[i];
          const prev = centerPath[(i - 1 + centerPath.length) % centerPath.length];
          const next = centerPath[(i + 1) % centerPath.length];
          
          // ë°©í–¥ ë²¡í„° ê³„ì‚°
          const dx = next.x - prev.x;
          const dy = next.y - prev.y;
          const len = Math.sqrt(dx * dx + dy * dy);
          
          if (len > 0) {
            // ë²•ì„  ë²¡í„° (ì¢Œìš°)
            const nx = -dy / len;
            const ny = dx / len;
            
            const halfWidth = trackWidth / 2;
            
            innerPath.push({
              x: curr.x + nx * halfWidth,
              y: curr.y + ny * halfWidth
            });
            
            outerPath.push({
              x: curr.x - nx * halfWidth,
              y: curr.y - ny * halfWidth
            });
          } else {
            // ê¸¸ì´ê°€ 0ì´ë©´ ê·¸ëŒ€ë¡œ ì‚¬ìš©
            innerPath.push({ x: curr.x, y: curr.y });
            outerPath.push({ x: curr.x, y: curr.y });
          }
        }
        
        return { innerPath, outerPath };
      }

      // ë¶€ë“œëŸ¬ìš´ ê²½ë¡œ ê·¸ë¦¬ê¸°
      drawSmoothPath(ctx, path, closed = false) {
        if (path.length < 2) return;
        
        ctx.beginPath();
        ctx.moveTo(path[0].x, path[0].y);
        
        for (let i = 1; i < path.length; i++) {
          ctx.lineTo(path[i].x, path[i].y);
        }
        
        if (closed && path.length > 2) {
          ctx.closePath();
        }
      }

      // ë Œë”ë§ ìŠ¤ì¼€ì¤„ë§ (ë¶€ë“œëŸ¬ìš´ ì• ë‹ˆë©”ì´ì…˜ì„ ìœ„í•´)
      scheduleRender() {
        if (this.animationFrameId) return; // ì´ë¯¸ ìŠ¤ì¼€ì¤„ë§ë¨
        
        this.animationFrameId = requestAnimationFrame(() => {
          this.render();
          this.animationFrameId = null;
          this.pendingRender = false;
        });
        this.pendingRender = true;
      }

      render() {
        if (!this.canvas || !this.ctx) return;
        
        const width = parseInt(document.getElementById('mapWidth')?.value || '4500') || 4500;
        const height = parseInt(document.getElementById('mapHeight')?.value || '3000') || 3000;
        const trackWidth = parseInt(document.getElementById('trackWidth')?.value || '120') || 120;

        // ìº”ë²„ìŠ¤ ì´ˆê¸°í™”
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

        // ë°°ê²½ (ì „ì²´ ìº”ë²„ìŠ¤ ì±„ìš°ê¸°)
        this.ctx.fillStyle = '#1e4620';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        
        // ì¤Œê³¼ ì˜¤í”„ì…‹ ì ìš©
        this.ctx.save();
        this.ctx.translate(this.offsetX, this.offsetY);
        this.ctx.scale(this.zoom, this.zoom);

        // ë§µ ì˜ì—­ í‘œì‹œ (ì¤Œê³¼ ê´€ê³„ì—†ì´ ê³ ì •ëœ ë‘ê»˜) - ë” ëˆˆì— ë„ê²Œ
        // ì™¸ê³½ í…Œë‘ë¦¬ (ë‘êº¼ìš´ ì„ )
        this.ctx.strokeStyle = '#00d4ff'; // ë°ì€ íŒŒë€ìƒ‰
        this.ctx.lineWidth = 4; // ë” ë‘ê»ê²Œ
        this.ctx.setLineDash([]); // ì‹¤ì„ 
        this.ctx.strokeRect(0, 0, width, height);
        
        // ë‚´ë¶€ í…Œë‘ë¦¬ (ì–‡ì€ ì„ ìœ¼ë¡œ ê°•ì¡°)
        this.ctx.strokeStyle = '#ffffff'; // í°ìƒ‰
        this.ctx.lineWidth = 1;
        this.ctx.strokeRect(1, 1, width - 2, height - 2);
        
        // ì½”ë„ˆ ë§ˆì»¤ ì¶”ê°€ (ë” ëª…í™•í•˜ê²Œ)
        const cornerSize = 20;
        this.ctx.fillStyle = '#00d4ff';
        // ì¢Œìƒë‹¨
        this.ctx.fillRect(0, 0, cornerSize, 4);
        this.ctx.fillRect(0, 0, 4, cornerSize);
        // ìš°ìƒë‹¨
        this.ctx.fillRect(width - cornerSize, 0, cornerSize, 4);
        this.ctx.fillRect(width - 4, 0, 4, cornerSize);
        // ì¢Œí•˜ë‹¨
        this.ctx.fillRect(0, height - 4, cornerSize, 4);
        this.ctx.fillRect(0, height - cornerSize, 4, cornerSize);
        // ìš°í•˜ë‹¨
        this.ctx.fillRect(width - cornerSize, height - 4, cornerSize, 4);
        this.ctx.fillRect(width - 4, height - cornerSize, 4, cornerSize);

        if (this.previewMode && this.points.length >= 2) {
          // ë¶€ë“œëŸ¬ìš´ ì¤‘ì•™ì„  ê²½ë¡œ ìƒì„± (ê²Œì„ê³¼ ë™ì¼í•œ ë°©ì‹)
          const smoothCenterPath = this.getSmoothPath(this.points, 200);
          
          // íŠ¸ë™ì˜ ì‹¤ì œ í¬ê¸°ëŠ” ê³ ì •ë˜ì–´ì•¼ í•˜ë¯€ë¡œ, ì¤Œì„ ì ìš©í•˜ê¸° ì „ì— lineWidthë¥¼ ì„¤ì •
          // ì¤Œì´ ì ìš©ë˜ë©´ lineWidthë„ ìŠ¤ì¼€ì¼ë§ë˜ë¯€ë¡œ, ì›í•˜ëŠ” í¬ê¸°ë¥¼ ì¤Œìœ¼ë¡œ ë‚˜ëˆ ì„œ ì„¤ì •
          // í•˜ì§€ë§Œ íŠ¸ë™ í¬ê¸°ë¥¼ ê³ ì •í•˜ë ¤ë©´ lineWidthë¥¼ ì¤Œê³¼ ê´€ê³„ì—†ì´ ê³ ì •ê°’ìœ¼ë¡œ ì„¤ì •
          
          // ê²Œì„ê³¼ ë™ì¼í•œ ë Œë”ë§ ë°©ì‹: stroke ê¸°ë°˜
          // íŠ¸ë™ ì™¸ê³½ì„  (ì§„í•œ íšŒìƒ‰ í…Œë‘ë¦¬) - íŠ¸ë™ í¬ê¸° ê³ ì •
          this.ctx.strokeStyle = '#333';
          this.ctx.lineWidth = (trackWidth + 20); // ì¤Œìœ¼ë¡œ ë‚˜ëˆ„ì§€ ì•ŠìŒ
          this.ctx.lineCap = 'round';
          this.ctx.lineJoin = 'round';
          this.drawSmoothPath(this.ctx, smoothCenterPath, this.points.length > 2);
          this.ctx.stroke();
          
          // íŠ¸ë™ ë³¸ì²´ (ì•„ìŠ¤íŒ”íŠ¸) - íŠ¸ë™ í¬ê¸° ê³ ì •
          const trackGradient = this.ctx.createLinearGradient(0, 0, width, height);
          trackGradient.addColorStop(0, '#3d3d3d');
          trackGradient.addColorStop(0.5, '#4a4a4a');
          trackGradient.addColorStop(1, '#3d3d3d');
          
          this.ctx.strokeStyle = trackGradient;
          this.ctx.lineWidth = trackWidth; // ì¤Œìœ¼ë¡œ ë‚˜ëˆ„ì§€ ì•ŠìŒ
          this.drawSmoothPath(this.ctx, smoothCenterPath, this.points.length > 2);
          this.ctx.stroke();
          
          // íŠ¸ë™ ì¤‘ì•™ì„  (ì ì„ ) - íŠ¸ë™ í¬ê¸° ê³ ì •
          this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
          this.ctx.lineWidth = 2; // ì¤Œìœ¼ë¡œ ë‚˜ëˆ„ì§€ ì•ŠìŒ
          this.ctx.setLineDash([20, 20]); // ì¤Œìœ¼ë¡œ ë‚˜ëˆ„ì§€ ì•ŠìŒ
          this.drawSmoothPath(this.ctx, smoothCenterPath, this.points.length > 2);
          this.ctx.stroke();
          this.ctx.setLineDash([]);
        } else {
          // í¸ì§‘ ëª¨ë“œ: ê²½ë¡œë§Œ í‘œì‹œ (ì¤Œê³¼ ê´€ê³„ì—†ì´ ê³ ì •ëœ ë‘ê»˜)
          if (this.points.length >= 2) {
            // í¸ì§‘ ëª¨ë“œì—ì„œë„ ë¶€ë“œëŸ¬ìš´ ê²½ë¡œ í‘œì‹œ
            const smoothPath = this.getSmoothPath(this.points, 200);
            this.ctx.strokeStyle = '#00ff88';
            this.ctx.lineWidth = 2; // ì¤Œìœ¼ë¡œ ë‚˜ëˆ„ì§€ ì•ŠìŒ
            this.ctx.setLineDash([5, 5]); // ì¤Œìœ¼ë¡œ ë‚˜ëˆ„ì§€ ì•ŠìŒ
            this.drawSmoothPath(this.ctx, smoothPath, this.points.length > 2);
            this.ctx.stroke();
            this.ctx.setLineDash([]);
          }
        }

        // í¬ì¸íŠ¸ ê·¸ë¦¬ê¸° (ì¤Œê³¼ ê´€ê³„ì—†ì´ ê³ ì •ëœ í¬ê¸°)
        this.points.forEach((p, i) => {
          const isSelected = i === this.selectedPointIndex;
          const isHovered = i === this.hoveredPointIndex && (this.mode === 'delete' || this.mode === 'move');
          const radius = isSelected ? 8 : (isHovered ? 10 : 6); // í˜¸ë²„ ì‹œ ë” í¬ê²Œ
          
          // í¬ì¸íŠ¸ íƒ€ì…ì— ë”°ë¼ ìƒ‰ìƒ ë³€ê²½
          const pointColor = p.type === 'curve' ? '#ff6b6b' : '#4ecdc4';
          
          // ì‚­ì œ/ì´ë™ ëª¨ë“œì—ì„œ í˜¸ë²„ ì‹œ ê°•ì¡°
          if (isHovered && this.mode === 'delete') {
            // ë¹¨ê°„ìƒ‰ ì™¸ê³½ ì› (ì‚­ì œ ê°€ëŠ¥ í‘œì‹œ)
            this.ctx.fillStyle = '#ff0000';
            this.ctx.beginPath();
            this.ctx.arc(p.x, p.y, radius + 2, 0, Math.PI * 2);
            this.ctx.fill();
          } else if (isHovered && this.mode === 'move') {
            // ì´ë™ ëª¨ë“œì—ì„œ í˜¸ë²„ ì‹œ ì´ˆë¡ìƒ‰ ì™¸ê³½ ì› (ì´ë™ ê°€ëŠ¥ í‘œì‹œ)
            this.ctx.fillStyle = '#00ff88';
            this.ctx.beginPath();
            this.ctx.arc(p.x, p.y, radius + 2, 0, Math.PI * 2);
            this.ctx.fill();
          }
          
          // ì™¸ê³½ ì›
          this.ctx.fillStyle = isSelected ? '#00ff88' : (isHovered && this.mode === 'delete' ? '#ff6666' : (isHovered && this.mode === 'move' ? '#66ff88' : pointColor));
          this.ctx.beginPath();
          this.ctx.arc(p.x, p.y, radius, 0, Math.PI * 2);
          this.ctx.fill();
          
          // ë‚´ë¶€ ì›
          this.ctx.fillStyle = isSelected ? '#000' : '#333';
          this.ctx.beginPath();
          this.ctx.arc(p.x, p.y, radius - 2, 0, Math.PI * 2); // ì¤Œìœ¼ë¡œ ë‚˜ëˆ„ì§€ ì•ŠìŒ
          this.ctx.fill();
        });
        
        // ì²´í¬í¬ì¸íŠ¸ ê·¸ë¦¬ê¸° (ì¤Œê³¼ ê´€ê³„ì—†ì´ ê³ ì •ëœ í¬ê¸°)
        this.checkpoints.forEach((cp, i) => {
          const isSelected = i === this.selectedCheckpointIndex;
          const isHovered = i === this.hoveredCheckpointIndex && (this.mode === 'deleteCheckpoint' || this.mode === 'moveCheckpoint');
          const radius = isSelected ? 12 : (isHovered ? 14 : 10); // í˜¸ë²„ ì‹œ ë” í¬ê²Œ
          
          // ì‚­ì œ ëª¨ë“œì—ì„œ í˜¸ë²„ ì‹œ ë¹¨ê°„ìƒ‰ ê°•ì¡°
          if (isHovered && this.mode === 'deleteCheckpoint') {
            // ë¹¨ê°„ìƒ‰ ì™¸ê³½ ì› (ì‚­ì œ ê°€ëŠ¥ í‘œì‹œ)
            this.ctx.fillStyle = '#ff0000';
            this.ctx.beginPath();
            this.ctx.arc(cp.x, cp.y, radius + 2, 0, Math.PI * 2);
            this.ctx.fill();
          } else if (isHovered && this.mode === 'moveCheckpoint') {
            // ì´ë™ ëª¨ë“œì—ì„œ í˜¸ë²„ ì‹œ ì´ˆë¡ìƒ‰ ì™¸ê³½ ì› (ì´ë™ ê°€ëŠ¥ í‘œì‹œ)
            this.ctx.fillStyle = '#00ff88';
            this.ctx.beginPath();
            this.ctx.arc(cp.x, cp.y, radius + 2, 0, Math.PI * 2);
            this.ctx.fill();
          }
          
          // ì²´í¬í¬ì¸íŠ¸ëŠ” ê¸ˆìƒ‰ìœ¼ë¡œ í‘œì‹œ
          this.ctx.fillStyle = isSelected ? '#00ff88' : (isHovered && this.mode === 'deleteCheckpoint' ? '#ff6666' : (isHovered && this.mode === 'moveCheckpoint' ? '#66ff88' : '#ffd700'));
          this.ctx.beginPath();
          this.ctx.arc(cp.x, cp.y, radius, 0, Math.PI * 2);
          this.ctx.fill();
          
          // ë‚´ë¶€ ì›
          this.ctx.fillStyle = isSelected ? '#000' : '#333';
          this.ctx.beginPath();
          this.ctx.arc(cp.x, cp.y, radius - 3, 0, Math.PI * 2);
          this.ctx.fill();
          
          // ê°ë„ í‘œì‹œ (í™”ì‚´í‘œ)
          const arrowLength = 20;
          const arrowX = cp.x + Math.cos(cp.angle) * arrowLength;
          const arrowY = cp.y + Math.sin(cp.angle) * arrowLength;
          
          this.ctx.strokeStyle = isSelected ? '#00ff88' : (isHovered && this.mode === 'deleteCheckpoint' ? '#ff6666' : (isHovered && this.mode === 'moveCheckpoint' ? '#66ff88' : '#ffd700'));
          this.ctx.lineWidth = 2;
          this.ctx.beginPath();
          this.ctx.moveTo(cp.x, cp.y);
          this.ctx.lineTo(arrowX, arrowY);
          this.ctx.stroke();
          
          // í™”ì‚´í‘œ ë¨¸ë¦¬
          const arrowAngle1 = cp.angle + Math.PI * 0.8;
          const arrowAngle2 = cp.angle - Math.PI * 0.8;
          const arrowHeadSize = 6;
          this.ctx.beginPath();
          this.ctx.moveTo(arrowX, arrowY);
          this.ctx.lineTo(
            arrowX + Math.cos(arrowAngle1) * arrowHeadSize,
            arrowY + Math.sin(arrowAngle1) * arrowHeadSize
          );
          this.ctx.moveTo(arrowX, arrowY);
          this.ctx.lineTo(
            arrowX + Math.cos(arrowAngle2) * arrowHeadSize,
            arrowY + Math.sin(arrowAngle2) * arrowHeadSize
          );
          this.ctx.stroke();
        });

        // ì¢Œí‘œ í‘œì‹œ (ì¤Œê³¼ ê´€ê³„ì—†ì´ ê³ ì •ëœ í¬ê¸°)
        this.points.forEach((p, i) => {
          if (i === this.selectedPointIndex) {
            this.ctx.fillStyle = '#00ff88';
            this.ctx.font = `12px monospace`; // ì¤Œìœ¼ë¡œ ë‚˜ëˆ„ì§€ ì•ŠìŒ
            this.ctx.fillText(`(${p.x}, ${p.y})`, p.x + 12, p.y - 12); // ì¤Œìœ¼ë¡œ ë‚˜ëˆ„ì§€ ì•ŠìŒ
          }
        });
        
        // ì²´í¬í¬ì¸íŠ¸ ì¢Œí‘œ í‘œì‹œ
        this.checkpoints.forEach((cp, i) => {
          if (i === this.selectedCheckpointIndex) {
            this.ctx.fillStyle = '#ffd700';
            this.ctx.font = `12px monospace`;
            const angleDeg = (cp.angle * 180 / Math.PI).toFixed(0);
            this.ctx.fillText(`CP${i + 1}: (${cp.x}, ${cp.y}) ${angleDeg}Â°`, cp.x + 12, cp.y - 12);
          }
        });
        
        // ì—°ì„ ê·¸ë¦¬ê¸° - ê²½ë¡œ ê¸°ë°˜ (ì¤Œê³¼ ê´€ê³„ì—†ì´ ê³ ì •ëœ í¬ê¸°)
        this.curbs.forEach((kerb, i) => {
          const isSelected = i === this.selectedKerbIndex;
          const isHovered = i === this.hoveredKerbIndex && (this.mode === 'deleteKerb' || this.mode === 'moveKerb');
          
          // ìƒˆë¡œìš´ ê²½ë¡œ ê¸°ë°˜ ì—°ì„
          if (kerb.centerPath && kerb.centerPath.length >= 2) {
            const kerbWidth = kerb.width || 20;
            const trackSide = kerb.trackSide || 'outer';
            
            // ì—°ì„ì„ ê²½ë¡œë¥¼ ë”°ë¼ í•˜ë‚˜ì˜ ì—°ì†ëœ í˜•íƒœë¡œ ê·¸ë¦¬ê¸° (íŠ¸ë™ ë°”ê¹¥ìª½ìœ¼ë¡œë§Œ)
            this.drawPathBasedKerb(kerb.centerPath, kerbWidth, trackSide);
            
            // í˜¸ë²„ ì‹œì—ë§Œ ì „ì²´ í…Œë‘ë¦¬ í‘œì‹œ
            if (isHovered) {
              this.ctx.save();
              let strokeColor = '#00ff88'; // ê¸°ë³¸ ìƒ‰ìƒ (ì´ˆë¡ìƒ‰)
              if (this.mode === 'deleteKerb') {
                strokeColor = '#ff0000'; // ì‚­ì œ ëª¨ë“œ (ë¹¨ê°„ìƒ‰)
              }
              this.ctx.strokeStyle = strokeColor;
              this.ctx.lineWidth = 3;
              
              // ëˆ„ì  ê¸¸ì´ í…Œì´ë¸” ê³„ì‚°
              const cumulative = [0];
              for (let i = 1; i < kerb.centerPath.length; i++) {
                const p1 = kerb.centerPath[i - 1];
                const p2 = kerb.centerPath[i];
                const dx = p2.x - p1.x;
                const dy = p2.y - p1.y;
                cumulative.push(cumulative[i - 1] + Math.hypot(dx, dy));
              }
              const totalLength = cumulative[cumulative.length - 1];
              
              // ê²½ë¡œìƒì˜ íŠ¹ì • ê±°ë¦¬ì—ì„œ ìœ„ì¹˜ì™€ ë²•ì„ ì„ ê³„ì‚°í•˜ëŠ” í•¨ìˆ˜
              const getPointAt = (dist) => {
                const clamped = Math.min(Math.max(dist, 0), totalLength);
                let idx = cumulative.findIndex((len) => len >= clamped);
                if (idx === -1) idx = cumulative.length - 1;
                if (idx === 0) idx = 1;
                
                const p1 = kerb.centerPath[idx - 1];
                const p2 = kerb.centerPath[idx];
                const segLen = cumulative[idx] - cumulative[idx - 1] || 1;
                const t = (clamped - cumulative[idx - 1]) / segLen;
                
                const x = p1.x + (p2.x - p1.x) * t;
                const y = p1.y + (p2.y - p1.y) * t;
                
                const dx = p2.x - p1.x;
                const dy = p2.y - p1.y;
                const len = Math.hypot(dx, dy) || 1;
                
                const nx = -dy / len;
                const ny = dx / len;
                const sign = trackSide === 'inner' ? 1 : -1;
                
                return {
                  track: { x, y },
                  outer: { x: x + nx * kerbWidth * sign, y: y + ny * kerbWidth * sign }
                };
              };
              
              const strokeStep = 0.5; // ë¶€ë“œëŸ¬ìš´ ê³¡ì„ ì„ ìœ„í•œ ê°„ê²©
              
              // íŠ¸ë™ ê²½ê³„ì„  (ì™„ì „íˆ ë¶€ë“œëŸ¬ìš´ ê³¡ì„ )
              this.ctx.beginPath();
              const first = getPointAt(0);
              this.ctx.moveTo(first.track.x, first.track.y);
              for (let d = strokeStep; d <= totalLength; d += strokeStep) {
                const pt = getPointAt(Math.min(d, totalLength));
                this.ctx.lineTo(pt.track.x, pt.track.y);
              }
              const lastTrack = getPointAt(totalLength);
              this.ctx.lineTo(lastTrack.track.x, lastTrack.track.y);
              this.ctx.stroke();
              
              // ë°”ê¹¥ìª½ ê²½ê³„ì„  (ì™„ì „íˆ ë¶€ë“œëŸ¬ìš´ ê³¡ì„ )
              this.ctx.beginPath();
              this.ctx.moveTo(first.outer.x, first.outer.y);
              for (let d = strokeStep; d <= totalLength; d += strokeStep) {
                const pt = getPointAt(Math.min(d, totalLength));
                this.ctx.lineTo(pt.outer.x, pt.outer.y);
              }
              const lastOuter = getPointAt(totalLength);
              this.ctx.lineTo(lastOuter.outer.x, lastOuter.outer.y);
              this.ctx.stroke();
              
              // ì–‘ ë ì—°ê²°ì„ 
              this.ctx.beginPath();
              this.ctx.moveTo(first.track.x, first.track.y);
              this.ctx.lineTo(first.outer.x, first.outer.y);
              this.ctx.moveTo(lastTrack.track.x, lastTrack.track.y);
              this.ctx.lineTo(lastOuter.outer.x, lastOuter.outer.y);
              this.ctx.stroke();
              
              this.ctx.restore();
            }
          }
          // êµ¬í˜• í¬ë§· (í•˜ìœ„ í˜¸í™˜ì„±)
          else if (kerb.x !== undefined && kerb.y !== undefined) {
            const width = kerb.width || 200;
            const height = kerb.height || 20;
            
            // í˜¸ë²„ ì‹œì—ë§Œ ì™¸ê³½ì„  í‘œì‹œ
            if (isHovered) {
              let strokeColor = '#00ff88'; // ê¸°ë³¸ ìƒ‰ìƒ (ì´ˆë¡ìƒ‰)
              if (this.mode === 'deleteKerb') {
                strokeColor = '#ff0000'; // ì‚­ì œ ëª¨ë“œ (ë¹¨ê°„ìƒ‰)
              }
              this.ctx.strokeStyle = strokeColor;
              this.ctx.lineWidth = 3;
              this.ctx.save();
              this.ctx.translate(kerb.x, kerb.y);
              this.ctx.rotate(kerb.angle || 0);
              this.ctx.strokeRect(-width / 2 - 2, -height / 2 - 2, width + 4, height + 4);
              this.ctx.restore();
            }
            
            // ì§ì„  ì—°ì„ ê·¸ë¦¬ê¸°
            this.ctx.save();
            this.ctx.globalCompositeOperation = 'source-over';
            this.ctx.translate(kerb.x, kerb.y);
            this.ctx.rotate(kerb.angle || 0);
            
            const blockWidth = 20;
            const blockCount = Math.floor(width / blockWidth);
            for (let j = 0; j < blockCount; j++) {
              const isRed = j % 2 === 0;
              const color = isRed ? '#ff0000' : '#ffffff';
              this.ctx.fillStyle = color;
              this.ctx.fillRect(-width / 2 + j * blockWidth, -height / 2, blockWidth, height);
            }
            
            // ê²€ì€ìƒ‰ í…Œë‘ë¦¬ ì œê±°ë¨
            this.ctx.restore();
          }
        });
        
        // ì—°ì„ ì •ë³´ í‘œì‹œ
        this.curbs.forEach((kerb, i) => {
          if (i === this.selectedKerbIndex) {
            this.ctx.fillStyle = '#ff9500';
            this.ctx.font = `12px monospace`;
            let displayText = `ì—°ì„${i + 1}`;
            let displayX = 0, displayY = 0;
            
            if (kerb.centerPath && kerb.centerPath.length > 0) {
              // ê²½ë¡œ ê¸°ë°˜: ì¤‘ì‹¬ì  í‘œì‹œ
              const midIdx = Math.floor(kerb.centerPath.length / 2);
              displayX = kerb.centerPath[midIdx].x;
              displayY = kerb.centerPath[midIdx].y;
              displayText += `: ${kerb.length || 300}px`;
            } else if (kerb.x !== undefined) {
              // êµ¬í˜• í¬ë§·
              displayX = kerb.x;
              displayY = kerb.y;
              const angleDeg = ((kerb.angle || 0) * 180 / Math.PI).toFixed(0);
              displayText += `: (${kerb.x}, ${kerb.y}) ${angleDeg}Â° ${kerb.width || 200}px`;
            }
            
            this.ctx.fillText(displayText, displayX + 12, displayY - 12);
          }
        });
        
        this.ctx.restore();
        
        // ë¯¸ë‹ˆë§µ ë Œë”ë§
        this.renderMinimap();
      }

      updateCodeOutput() {
        const trackName = document.getElementById('trackName').value;
        const trackId = document.getElementById('trackId').value;
        const mapWidth = parseInt(document.getElementById('mapWidth').value) || 4500;
        const mapHeight = parseInt(document.getElementById('mapHeight').value) || 3000;
        const trackWidth = parseInt(document.getElementById('trackWidth').value) || 120;

        if (this.points.length < 2) {
          document.getElementById('codeOutput').value = '// ìµœì†Œ 2ê°œì˜ í¬ì¸íŠ¸ê°€ í•„ìš”í•©ë‹ˆë‹¤.';
          return;
        }

        const pointsStr = this.points.map(p => `{ x: ${p.x}, y: ${p.y}${p.type ? `, type: '${p.type}'` : ''} }`).join(',\n    ');

        const code = `const ${trackId}Track = {
  name: '${trackName}',
  id: '${trackId}',
  width: ${mapWidth},
  height: ${mapHeight},
  
  centerPath: [
    ${pointsStr}
  ],
  
  trackWidth: ${trackWidth},
  
  checkpoints: [
${this.checkpoints.length > 0 ? this.checkpoints.map(cp => `    { x: ${cp.x}, y: ${cp.y}, angle: ${cp.angle.toFixed(3)} }`).join(',\n') : '    // ì²´í¬í¬ì¸íŠ¸ë¥¼ ì¶”ê°€í•˜ì„¸ìš”'}
  ],
  
  curbs: [
${this.curbs.length > 0 ? this.curbs.map(kerb => {
  if (kerb.centerPath && kerb.centerPath.length > 0) {
    // ê²½ë¡œ ê¸°ë°˜ ì—°ì„
    const pathStr = kerb.centerPath.map(p => `{ x: ${p.x}, y: ${p.y} }`).join(', ');
    return `    { centerPath: [${pathStr}], width: ${kerb.width || 20}, length: ${kerb.length || 300}, trackSide: '${kerb.trackSide || 'outer'}' }`;
  } else {
    // êµ¬í˜• í¬ë§·
    return `    { x: ${kerb.x}, y: ${kerb.y}, angle: ${(kerb.angle || 0).toFixed(3)}, width: ${kerb.width || 200}, height: ${kerb.height || 20} }`;
  }
}).join(',\n') : '    // ì—°ì„ì„ ì¶”ê°€í•˜ì„¸ìš”'}
  ],
  
  startLine: {
    x: ${this.points[0]?.x || 0},
    y: ${this.points[0]?.y || 0},
    width: ${trackWidth},
    angle: 0
  },
  
  serverConfig: {
    buildCenterPath: function() {
      return [
        ${pointsStr}
      ];
    },
    
    spawnPositions: [
      { x: ${this.points[0]?.x || 0}, y: ${this.points[0]?.y || 0} }
    ],
    
    spawnAngle: 0,
    checkpoints: [
${this.checkpoints.map(cp => `      { x: ${cp.x}, y: ${cp.y}, angle: ${cp.angle.toFixed(3)} }`).join(',\n')}
    ],
    startLine: {
      x: ${this.points[0]?.x || 0},
      y: ${this.points[0]?.y || 0},
      angle: 0
    },
    trackWidth: ${trackWidth}
  }
};`;

        document.getElementById('codeOutput').value = code;
      }

      copyCode() {
        const code = document.getElementById('codeOutput').value;
        navigator.clipboard.writeText(code).then(() => {
          alert('ì½”ë“œê°€ í´ë¦½ë³´ë“œì— ë³µì‚¬ë˜ì—ˆìŠµë‹ˆë‹¤!');
        });
      }

      newTrack() {
        // í˜„ì¬ ì‘ì—…ì´ ìˆìœ¼ë©´ í™•ì¸
        if (this.points.length > 0 || this.checkpoints.length > 0) {
          if (!confirm('ìƒˆ íŠ¸ë™ì„ ë§Œë“¤ë©´ í˜„ì¬ íŠ¸ë™ ë°ì´í„°ê°€ ëª¨ë‘ ì´ˆê¸°í™”ë©ë‹ˆë‹¤.\nê³„ì†í•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) {
            return;
          }
        }
        
        // í¬ì¸íŠ¸ ì´ˆê¸°í™”
        this.points = [];
        this.selectedPointIndex = -1;
        
        // ì²´í¬í¬ì¸íŠ¸ ì´ˆê¸°í™”
        this.checkpoints = [];
        this.selectedCheckpointIndex = -1;
        
        // íŠ¸ë™ ì •ë³´ ì´ˆê¸°í™”
        document.getElementById('trackName').value = 'ìƒˆ íŠ¸ë™';
        document.getElementById('trackId').value = 'new-track';
        document.getElementById('mapWidth').value = '4500';
        document.getElementById('mapHeight').value = '3000';
        
        // ëª¨ë“œë¥¼ í¬ì¸íŠ¸ ì¶”ê°€ ëª¨ë“œë¡œ ë³€ê²½
        this.setMode('add');
        
        // ë·° ì´ˆê¸°í™”
        this.resetView();
        
        // UI ì—…ë°ì´íŠ¸
        this.updatePointList();
        this.updateSelectedPointInfo();
        this.updateCheckpointList();
        this.updateSelectedCheckpointInfo();
        this.updateKerbList();
        this.updateSelectedKerbInfo();
        this.updateCodeOutput();
        this.saveToStorage(); // ì €ì¥
        this.render();
      }
      
      newTrack() {
        // í˜„ì¬ ì‘ì—…ì´ ìˆìœ¼ë©´ í™•ì¸
        if (this.points.length > 0 || this.checkpoints.length > 0 || this.curbs.length > 0 || document.getElementById('trackId').value !== 'new-track') {
          if (!confirm('í˜„ì¬ ì‘ì—… ì¤‘ì¸ íŠ¸ë™ì´ ìˆìŠµë‹ˆë‹¤. ìƒˆ íŠ¸ë™ì„ ë§Œë“¤ë©´ ëª¨ë“  ë°ì´í„°ê°€ ì´ˆê¸°í™”ë©ë‹ˆë‹¤. ê³„ì†í•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) {
            return;
          }
        }
        
        // í¬ì¸íŠ¸ ì´ˆê¸°í™”
        this.points = [];
        this.selectedPointIndex = -1;
        
        // ì²´í¬í¬ì¸íŠ¸ ì´ˆê¸°í™”
        this.checkpoints = [];
        this.selectedCheckpointIndex = -1;
        
        // ì—°ì„ ì´ˆê¸°í™”
        this.curbs = [];
        this.selectedKerbIndex = -1;
        
        // íŠ¸ë™ ì •ë³´ ì´ˆê¸°í™”
        document.getElementById('trackName').value = 'ìƒˆ íŠ¸ë™';
        document.getElementById('trackId').value = 'new-track';
        document.getElementById('mapWidth').value = '4500';
        document.getElementById('mapHeight').value = '3000';
        
        // ëª¨ë“œë¥¼ í¬ì¸íŠ¸ ì¶”ê°€ ëª¨ë“œë¡œ ë³€ê²½
        this.setMode('add');
        
        // ë·° ì´ˆê¸°í™”
        this.resetView();
        
        // UI ì—…ë°ì´íŠ¸
        this.updatePointList();
        this.updateSelectedPointInfo();
        this.updateCheckpointList();
        this.updateSelectedCheckpointInfo();
        this.updateCodeOutput();
        this.saveToStorage(); // ì €ì¥
        this.render();
      }
      
      clearTrack() {
        if (confirm('ëª¨ë“  íŠ¸ë™ ë°ì´í„°ë¥¼ ì´ˆê¸°í™”í•˜ì‹œê² ìŠµë‹ˆê¹Œ?\n(í¬ì¸íŠ¸, ì²´í¬í¬ì¸íŠ¸, ì—°ì„, íŠ¸ë™ ì •ë³´ê°€ ëª¨ë‘ ì´ˆê¸°í™”ë©ë‹ˆë‹¤)')) {
          // í¬ì¸íŠ¸ ì´ˆê¸°í™”
          this.points = [];
          this.selectedPointIndex = -1;
          
          // ì²´í¬í¬ì¸íŠ¸ ì´ˆê¸°í™”
          this.checkpoints = [];
          this.selectedCheckpointIndex = -1;
          
          // ì—°ì„ ì´ˆê¸°í™”
          this.curbs = [];
          this.selectedKerbIndex = -1;
          
          // íŠ¸ë™ ì •ë³´ ì´ˆê¸°í™”
          document.getElementById('trackName').value = 'ìƒˆ íŠ¸ë™';
          document.getElementById('trackId').value = 'new-track';
          document.getElementById('mapWidth').value = '4500';
          document.getElementById('mapHeight').value = '3000';
          
          // ë·° ì´ˆê¸°í™”
          this.resetView();
          
          // UI ì—…ë°ì´íŠ¸
          this.updatePointList();
          this.updateSelectedPointInfo();
          this.updateCheckpointList();
          this.updateSelectedCheckpointInfo();
          this.updateKerbList();
          this.updateSelectedKerbInfo();
          this.updateCodeOutput();
          this.saveToStorage(); // ì €ì¥
          this.render();
        }
      }

      async loadTrack() {
        const trackId = prompt('ë¡œë“œí•  íŠ¸ë™ IDë¥¼ ì…ë ¥í•˜ì„¸ìš” (basic-circuit ë˜ëŠ” monza):');
        if (!trackId) return;

        // íŠ¸ë™ íŒŒì¼ì´ ì•„ì§ ë¡œë“œë˜ì§€ ì•Šì•˜ë‹¤ë©´ ë¡œë“œ ì‹œë„
        if (typeof window.getTrack === 'undefined' || typeof window.TRACKS === 'undefined') {
          const loadScript = (src) => {
            return new Promise((resolve, reject) => {
              // ì´ë¯¸ ë¡œë“œëœ ìŠ¤í¬ë¦½íŠ¸ì¸ì§€ í™•ì¸
              const existingScript = document.querySelector(`script[src="${src}"]`);
              if (existingScript) {
                resolve();
                return;
              }
              
              const script = document.createElement('script');
              script.src = src;
              script.onload = resolve;
              script.onerror = reject;
              document.body.appendChild(script);
            });
          };
          
          try {
            await Promise.all([
              loadScript('/js/track.js'),
              loadScript('/js/tracks/basic-circuit.js'),
              loadScript('/js/tracks/monza.js')
            ]);
            // ìŠ¤í¬ë¦½íŠ¸ ë¡œë“œ í›„ ì•½ê°„ì˜ ì‹œê°„ì„ ë‘ì–´ registerTrack í˜¸ì¶œ ì™„ë£Œ ëŒ€ê¸°
            await new Promise(resolve => setTimeout(resolve, 200));
          } catch (error) {
            alert('íŠ¸ë™ íŒŒì¼ ë¡œë“œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤: ' + error);
            return;
          }
        }

        // ë””ë²„ê¹…: TRACKS ìƒíƒœ í™•ì¸
        console.log('TRACKS:', window.TRACKS);
        console.log('getTrack í•¨ìˆ˜:', typeof window.getTrack);
        
        // ì „ì—­ getTrack í•¨ìˆ˜ ì‚¬ìš© ë˜ëŠ” ì§ì ‘ TRACKSì—ì„œ ê°€ì ¸ì˜¤ê¸°
        let trackData = null;
        if (typeof window.getTrack === 'function') {
          trackData = window.getTrack(trackId);
          console.log('getTrack ê²°ê³¼:', trackData);
        }
        
        // getTrackì´ ì‹¤íŒ¨í–ˆê±°ë‚˜ nullì„ ë°˜í™˜í•œ ê²½ìš° ì§ì ‘ TRACKSì—ì„œ í™•ì¸
        if (!trackData && typeof window.TRACKS !== 'undefined') {
          const trackInfo = window.TRACKS[trackId];
          console.log('TRACKSì—ì„œ ì§ì ‘ ê°€ì ¸ì˜¤ê¸°:', trackInfo);
          if (trackInfo) {
            trackData = trackInfo.data;
          }
        }

        if (!trackData) {
          const availableTracks = typeof window.TRACKS !== 'undefined' 
            ? Object.keys(window.TRACKS).join(', ') 
            : 'ì—†ìŒ';
          alert(`íŠ¸ë™ '${trackId}'ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.\n\nì‚¬ìš© ê°€ëŠ¥í•œ íŠ¸ë™: ${availableTracks}\n\níŠ¸ë™ì´ ë¡œë“œë˜ì§€ ì•Šì•˜ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì½˜ì†”ì„ í™•ì¸í•˜ì„¸ìš”.`);
          console.error('íŠ¸ë™ ë¡œë“œ ì‹¤íŒ¨:', {
            trackId,
            TRACKS: window.TRACKS,
            getTrack: typeof window.getTrack,
            trackData: trackData
          });
          return;
        }

        // íŠ¸ë™ ë°ì´í„°ë¥¼ í¸ì§‘ê¸°ì— ë¡œë“œ
        let centerPath = trackData.centerPath;
        
        // centerPathê°€ í•¨ìˆ˜ì¸ ê²½ìš° í˜¸ì¶œ
        if (typeof centerPath === 'function') {
          centerPath = centerPath();
        }
        
        if (centerPath && Array.isArray(centerPath) && centerPath.length > 0) {
          this.points = centerPath.map(p => ({ 
            x: p.x, 
            y: p.y, 
            type: p.type || 'straight' 
          }));
          
          // ì²´í¬í¬ì¸íŠ¸ ë¡œë“œ
          if (trackData.checkpoints && Array.isArray(trackData.checkpoints)) {
            this.checkpoints = trackData.checkpoints.map(cp => ({
              x: cp.x,
              y: cp.y,
              angle: cp.angle || 0
            }));
          }
          
          // ì—°ì„ ë¡œë“œ
          if (trackData.curbs && Array.isArray(trackData.curbs)) {
            this.curbs = trackData.curbs.map(kerb => ({
              x: kerb.x,
              y: kerb.y,
              angle: kerb.angle || 0,
              width: kerb.width || 200,
              height: kerb.height || 20
            }));
          } else {
            this.curbs = [];
          }
          
          // íŠ¸ë™ ì •ë³´ ì—…ë°ì´íŠ¸
          if (trackData.width) {
            document.getElementById('mapWidth').value = trackData.width;
          }
          if (trackData.height) {
            document.getElementById('mapHeight').value = trackData.height;
          }
          if (trackData.trackWidth) {
            document.getElementById('trackWidth').value = trackData.trackWidth;
          }
          if (trackData.name) {
            document.getElementById('trackName').value = trackData.name;
          }
          if (trackData.id) {
            document.getElementById('trackId').value = trackData.id;
          }
          
          this.selectedPointIndex = -1;
          this.selectedCheckpointIndex = -1;
          this.updatePointList();
          this.updateSelectedPointInfo();
          this.updateCheckpointList();
          this.updateSelectedCheckpointInfo();
          this.updateCodeOutput();
          this.saveToStorage(); // ì €ì¥
          this.render();
          
          alert(`íŠ¸ë™ '${trackData.name || trackId}'ê°€ ë¡œë“œë˜ì—ˆìŠµë‹ˆë‹¤. (${this.points.length}ê°œ í¬ì¸íŠ¸, ${this.checkpoints.length}ê°œ ì²´í¬í¬ì¸íŠ¸)`);
        } else {
          alert('íŠ¸ë™ ë°ì´í„° í˜•ì‹ì´ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤. centerPathê°€ ì—†ìŠµë‹ˆë‹¤.');
        }
      }

      updateStatus() {
        const modeNames = { 
          add: 'í¬ì¸íŠ¸ ì¶”ê°€', 
          move: 'í¬ì¸íŠ¸ ì´ë™', 
          delete: 'í¬ì¸íŠ¸ ì‚­ì œ',
          addCheckpoint: 'ì²´í¬í¬ì¸íŠ¸ ì¶”ê°€',
          moveCheckpoint: 'ì²´í¬í¬ì¸íŠ¸ ì´ë™',
          deleteCheckpoint: 'ì²´í¬í¬ì¸íŠ¸ ì‚­ì œ'
        };
        const statusEl = document.getElementById('status');
        if (statusEl) {
          const modeName = modeNames[this.mode] || this.mode;
          statusEl.textContent = `ëª¨ë“œ: ${modeName} | í¬ì¸íŠ¸: ${this.points.length}ê°œ | ì²´í¬í¬ì¸íŠ¸: ${this.checkpoints.length}ê°œ`;
        }
      }
    }

    // í¸ì§‘ê¸° ì´ˆê¸°í™”
    let editor;
    
    // íŠ¸ë™ ê´€ë ¨ í•¨ìˆ˜ê°€ í•„ìš”í•˜ë©´ ë¡œë“œ
    function getTrack(trackId) {
      // ì „ì—­ TRACKS ê°ì²´ì—ì„œ íŠ¸ë™ ê°€ì ¸ì˜¤ê¸°
      if (typeof window.TRACKS !== 'undefined' && window.TRACKS[trackId]) {
        return window.TRACKS[trackId].data;
      }
      return null;
    }
    
    window.addEventListener('load', async () => {
      // íŠ¸ë™ íŒŒì¼ì„ ë¨¼ì € ë¡œë“œ
      const loadScript = (src) => {
        return new Promise((resolve, reject) => {
          // ì´ë¯¸ ë¡œë“œëœ ìŠ¤í¬ë¦½íŠ¸ì¸ì§€ í™•ì¸
          const existingScript = document.querySelector(`script[src="${src}"]`);
          if (existingScript) {
            resolve();
            return;
          }
          
          const script = document.createElement('script');
          script.src = src;
          script.onload = resolve;
          script.onerror = reject;
          document.body.appendChild(script);
        });
      };
      
      // track.jsì™€ íŠ¸ë™ íŒŒì¼ë“¤ì„ ë¡œë“œ
      try {
        await Promise.all([
          loadScript('/js/track.js'),
          loadScript('/js/tracks/basic-circuit.js'),
          loadScript('/js/tracks/monza.js')
        ]);
        // registerTrack í˜¸ì¶œ ì™„ë£Œ ëŒ€ê¸°
        await new Promise(resolve => setTimeout(resolve, 200));
        console.log('íŠ¸ë™ íŒŒì¼ë“¤ì´ ë¡œë“œë˜ì—ˆìŠµë‹ˆë‹¤.', window.TRACKS);
      } catch (error) {
        console.warn('íŠ¸ë™ íŒŒì¼ ë¡œë“œ ì‹¤íŒ¨ (íŠ¸ë™ ë¡œë“œ ê¸°ëŠ¥ ì‚¬ìš© ë¶ˆê°€):', error);
      }
      
      // í¸ì§‘ê¸° ì´ˆê¸°í™”
      editor = new TrackEditor();
    });
  </script>
</body>
</html>

