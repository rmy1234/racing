<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>νΈλ™ νΈμ§‘κΈ° - κ°λ°μ©</title>
  <link rel="stylesheet" href="/css/track-editor.css">
  <!-- νΈλ™ νμΌ λ―Έλ¦¬ λ΅λ“ -->
  <script src="/js/track.js"></script>
  <script src="/js/tracks/basic-circuit.js"></script>
  <script src="/js/tracks/monza.js"></script>
  <!-- TrackEditor μ ν‹Έλ¦¬ν‹° ν•¨μ -->
  <script src="/js/track-editor/utils.js"></script>
  <!-- TrackEditor λ λ”λ§ ν•¨μ -->
  <script src="/js/track-editor/renderer.js"></script>
  <!-- TrackEditor ν¬μΈνΈ κ΄€λ¦¬ ν•¨μ -->
  <script src="/js/track-editor/point-manager.js"></script>
  <!-- TrackEditor μ²΄ν¬ν¬μΈνΈ κ΄€λ¦¬ ν•¨μ -->
  <script src="/js/track-editor/checkpoint-manager.js"></script>
  <!-- TrackEditor μ—°μ„ κ΄€λ¦¬ ν•¨μ -->
  <script src="/js/track-editor/kerb-manager.js"></script>
  <!-- TrackEditor μ¶λ° μ„μΉ κ΄€λ¦¬ ν•¨μ -->
  <script src="/js/track-editor/spawn-manager.js"></script>
  <!-- TrackEditor μ½”λ“ μƒμ„± ν•¨μ -->
  <script src="/js/track-editor/code-generator.js"></script>
  <!-- TrackEditor νΈλ™ κ΄€λ¦¬ ν•¨μ -->
  <script src="/js/track-editor/track-manager.js"></script>
  <!-- TrackEditor μ΄λ²¤νΈ ν•Έλ“¤λ¬ ν•¨μ -->
  <script src="/js/track-editor/event-handler.js"></script>
  <!-- TrackEditor UI κ΄€λ¦¬ ν•¨μ -->
  <script src="/js/track-editor/ui-manager.js"></script>
</head>
<body>
    <div class="header">
      <h1>π νΈλ™ νΈμ§‘κΈ° (κ°λ°μ©)</h1>
      <div class="controls">
        <button id="backToGameBtn" onclick="window.location.href='/'">β† κ²μ„μΌλ΅</button>
        <button id="newTrackBtn" style="background: #00d4ff; color: #000;">μƒ νΈλ™</button>
        <button id="loadTrackBtn">νΈλ™ λ΅λ“</button>
        <button id="saveTrackBtn">μ½”λ“ λ³µμ‚¬</button>
        <button id="clearBtn" class="danger">μ΄κΈ°ν™”</button>
      </div>
    </div>

  <div class="main-container">
    <div class="canvas-container">
      <div class="toolbar">
        <button id="addModeBtn" class="active">β• ν¬μΈνΈ μ¶”κ°€</button>
        <button id="moveModeBtn">β†”οΈ ν¬μΈνΈ μ΄λ™</button>
        <button id="deleteModeBtn">β–οΈ ν¬μΈνΈ μ‚­μ </button>
        <button id="addCheckpointBtn">π μ²΄ν¬ν¬μΈνΈ μ¶”κ°€</button>
        <button id="moveCheckpointBtn">β†”οΈ μ²΄ν¬ν¬μΈνΈ μ΄λ™</button>
        <button id="deleteCheckpointBtn">β–οΈ μ²΄ν¬ν¬μΈνΈ μ‚­μ </button>
        <button id="addKerbBtn">π¦ μ—°μ„ μ¶”κ°€</button>
        <button id="moveKerbBtn">β†”οΈ μ—°μ„ μ΄λ™</button>
        <button id="deleteKerbBtn">β–οΈ μ—°μ„ μ‚­μ </button>
        <button id="addSpawnBtn">π— μ¶λ° μ„μΉ μ¶”κ°€</button>
        <button id="moveSpawnBtn">β†”οΈ μ¶λ° μ„μΉ μ΄λ™</button>
        <button id="deleteSpawnBtn">β–οΈ μ¶λ° μ„μΉ μ‚­μ </button>
        <button id="setStartLineBtn">π μ‹μ‘μ„  μ„¤μ •</button>
        <button id="moveStartLineBtn">β†”οΈ μ‹μ‘μ„  μ΄λ™</button>
        <button id="deleteStartLineBtn">β–οΈ μ‹μ‘μ„  μ‚­μ </button>
        <button id="previewBtn">π‘οΈ λ―Έλ¦¬λ³΄κΈ°</button>
      </div>
      <canvas id="editorCanvas" width="1200" height="800"></canvas>
      <div class="status" id="status">λ¨λ“: ν¬μΈνΈ μ¶”κ°€ | ν¬μΈνΈ: 0κ°</div>
      <div class="minimap">
        <canvas id="minimapCanvas"></canvas>
      </div>
      <div class="zoom-controls">
        <button id="zoomInBtn" title="ν™•λ€">+</button>
        <button id="zoomOutBtn" title="μ¶•μ†">-</button>
        <button id="resetViewBtn" title="λ·° λ¦¬μ…‹">β‚</button>
      </div>
    </div>

    <div class="sidebar">
      <div class="section">
        <h3>νΈλ™ μ •λ³΄</h3>
        <div class="input-group">
          <label>νΈλ™ μ΄λ¦„</label>
          <input type="text" id="trackName" value="μƒ νΈλ™">
        </div>
        <div class="input-group">
          <label>νΈλ™ ID</label>
          <input type="text" id="trackId" value="new-track">
        </div>
        <div class="input-group">
          <label>λ§µ λ„λΉ„</label>
          <input type="number" id="mapWidth" value="4500">
        </div>
        <div class="input-group">
          <label>λ§µ λ†’μ΄</label>
          <input type="number" id="mapHeight" value="3000">
        </div>
        <div class="input-group">
          <label>νΈλ™ ν­</label>
          <input type="number" id="trackWidth" value="120" readonly>
        </div>
      </div>

      <div class="section">
        <h3>ν¬μΈνΈ λ©λ΅</h3>
        <div class="point-list" id="pointList">
          <div style="color: #666; font-size: 11px; text-align: center; padding: 20px;">
            ν¬μΈνΈλ¥Ό μ¶”κ°€ν•λ ¤λ©΄ μΊ”λ²„μ¤λ¥Ό ν΄λ¦­ν•μ„Έμ”
          </div>
        </div>
      </div>

      <div class="section">
        <h3>μ„ νƒλ ν¬μΈνΈ</h3>
        <div id="selectedPointInfo" style="color: #666; font-size: 11px;">
          ν¬μΈνΈλ¥Ό μ„ νƒν•μ„Έμ”
        </div>
        <div class="input-group" id="pointEditGroup" style="display: none; margin-top: 10px;">
          <label>X μΆν‘</label>
          <input type="number" id="pointX" step="1">
        </div>
        <div class="input-group" id="pointEditGroup2" style="display: none;">
          <label>Y μΆν‘</label>
          <input type="number" id="pointY" step="1">
        </div>
        <div class="input-group" id="pointEditGroup3" style="display: none; margin-top: 10px;">
          <label>ν¬μΈνΈ νƒ€μ…</label>
          <div style="display: flex; gap: 5px;">
            <button id="setStraightBtn" style="flex: 1; font-size: 11px;">μ§μ„ </button>
            <button id="setCurveBtn" style="flex: 1; font-size: 11px;">κ³΅μ„ </button>
          </div>
        </div>
      </div>

      <div class="section">
        <h3>μ²΄ν¬ν¬μΈνΈ λ©λ΅</h3>
        <div class="point-list" id="checkpointList">
          <div style="color: #666; font-size: 11px; text-align: center; padding: 20px;">
            μ²΄ν¬ν¬μΈνΈλ¥Ό μ¶”κ°€ν•λ ¤λ©΄ μ²΄ν¬ν¬μΈνΈ μ¶”κ°€ λ¨λ“λ¥Ό μ„ νƒν•μ„Έμ”
          </div>
        </div>
      </div>

      <div class="section">
        <h3>μ„ νƒλ μ²΄ν¬ν¬μΈνΈ</h3>
        <div id="selectedCheckpointInfo" style="color: #666; font-size: 11px;">
          μ²΄ν¬ν¬μΈνΈλ¥Ό μ„ νƒν•μ„Έμ”
        </div>
        <div class="input-group" id="checkpointEditGroup" style="display: none; margin-top: 10px;">
          <label>X μΆν‘</label>
          <input type="number" id="checkpointX" step="1">
        </div>
        <div class="input-group" id="checkpointEditGroup2" style="display: none;">
          <label>Y μΆν‘</label>
          <input type="number" id="checkpointY" step="1">
        </div>
        <div class="input-group" id="checkpointEditGroup3" style="display: none;">
          <label>κ°λ„ (λΌλ””μ•)</label>
          <input type="number" id="checkpointAngle" step="0.1">
        </div>
        <div class="input-group" id="checkpointEditGroup4" style="display: none; margin-top: 5px;">
          <label>κ°λ„ (λ„)</label>
          <input type="number" id="checkpointAngleDeg" step="1" min="0" max="360">
        </div>
      </div>

      <div class="section">
        <h3>μ¶λ° μ„μΉ λ©λ΅</h3>
        <div class="point-list" id="spawnList">
          <div style="color: #666; font-size: 11px; text-align: center; padding: 20px;">
            μ¶λ° μ„μΉλ¥Ό μ¶”κ°€ν•λ ¤λ©΄ μ¶λ° μ„μΉ μ¶”κ°€ λ¨λ“λ¥Ό μ„ νƒν•μ„Έμ”
          </div>
        </div>
      </div>

      <div class="section">
        <h3>μ„ νƒλ μ¶λ° μ„μΉ</h3>
        <div id="selectedSpawnInfo" style="color: #666; font-size: 11px;">
          μ¶λ° μ„μΉλ¥Ό μ„ νƒν•μ„Έμ”
        </div>
        <div class="input-group" id="spawnEditGroup" style="display: none; margin-top: 10px;">
          <label>X μΆν‘</label>
          <input type="number" id="spawnX" step="1">
        </div>
        <div class="input-group" id="spawnEditGroup2" style="display: none;">
          <label>Y μΆν‘</label>
          <input type="number" id="spawnY" step="1">
        </div>
      </div>

      <div class="section">
        <h3>μ¶λ° λ°©ν–¥ μ„¤μ •</h3>
        <div class="input-group">
          <label>μ¶λ° λ°©ν–¥ (λΌλ””μ•)</label>
          <input type="number" id="spawnAngle" step="0.1" value="0">
        </div>
        <div class="input-group" style="margin-top: 5px;">
          <label>μ¶λ° λ°©ν–¥ (λ„)</label>
          <input type="number" id="spawnAngleDeg" step="1" min="0" max="360" value="0">
        </div>
      </div>

      <div class="section">
        <h3>μ‹μ‘μ„  μ„¤μ •</h3>
        <div class="input-group">
          <label>X μΆν‘</label>
          <input type="number" id="startLineX" step="1">
        </div>
        <div class="input-group">
          <label>Y μΆν‘</label>
          <input type="number" id="startLineY" step="1">
        </div>
        <div class="input-group">
          <label>κ°λ„ (λΌλ””μ•)</label>
          <input type="number" id="startLineAngle" step="0.1" value="0">
        </div>
        <div class="input-group" style="margin-top: 5px;">
          <label>κ°λ„ (λ„)</label>
          <input type="number" id="startLineAngleDeg" step="1" min="0" max="360" value="0">
        </div>
      </div>

      <div class="section">
        <h3>μƒμ„±λ μ½”λ“</h3>
        <button id="copyCodeBtn" style="width: 100%; margin-bottom: 10px;">μ½”λ“ λ³µμ‚¬</button>
        <textarea id="codeOutput" class="code-output" readonly></textarea>
      </div>

      <div class="info">
        <strong>μ‚¬μ©λ²•:</strong><br>
        β€Ά ν¬μΈνΈ μ¶”κ°€ λ¨λ“: μΊ”λ²„μ¤ ν΄λ¦­μΌλ΅ ν¬μΈνΈ μ¶”κ°€<br>
        β€Ά ν¬μΈνΈ μ΄λ™ λ¨λ“: ν¬μΈνΈλ¥Ό λ“λκ·Έν•μ—¬ μ΄λ™<br>
        β€Ά ν¬μΈνΈ μ‚­μ  λ¨λ“: ν¬μΈνΈ ν΄λ¦­μΌλ΅ μ‚­μ <br>
        β€Ά λ―Έλ¦¬λ³΄κΈ°: νΈλ™ λ λ”λ§ λ―Έλ¦¬λ³΄κΈ°
      </div>
    </div>
  </div>

  <script>
    class TrackEditor {
      constructor() {
        this.canvas = document.getElementById('editorCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.minimapCanvas = document.getElementById('minimapCanvas');
        this.minimapCtx = this.minimapCanvas.getContext('2d');
        this.points = [];
        this.checkpoints = []; // μ²΄ν¬ν¬μΈνΈ λ°°μ—΄
        this.curbs = []; // μ—°μ„ λ°°μ—΄ { x, y, angle, length }
        this.spawnPositions = []; // μ¶λ° μ„μΉ λ°°μ—΄ { x, y }
        this.spawnAngle = 0; // μ¶λ° λ°©ν–¥ (λΌλ””μ•)
        this.startLine = { x: 0, y: 0, angle: 0 }; // μ‹μ‘μ„  { x, y, angle }
        this.selectedPointIndex = -1;
        this.selectedCheckpointIndex = -1; // μ„ νƒλ μ²΄ν¬ν¬μΈνΈ μΈλ±μ¤
        this.selectedKerbIndex = -1; // μ„ νƒλ μ—°μ„ μΈλ±μ¤
        this.selectedSpawnIndex = -1; // μ„ νƒλ μ¶λ° μ„μΉ μΈλ±μ¤
        this.draggingPointIndex = -1;
        this.draggingCheckpointIndex = -1; // λ“λκ·Έ μ¤‘μΈ μ²΄ν¬ν¬μΈνΈ μΈλ±μ¤
        this.draggingCheckpointAngleIndex = -1; // λ“λκ·Έ μ¤‘μΈ μ²΄ν¬ν¬μΈνΈ ν™”μ‚΄ν‘ μΈλ±μ¤
        this.draggingKerbIndex = -1; // λ“λκ·Έ μ¤‘μΈ μ—°μ„ μΈλ±μ¤
        this.draggingSpawnIndex = -1; // λ“λκ·Έ μ¤‘μΈ μ¶λ° μ„μΉ μΈλ±μ¤
        this.draggingSpawnAngleIndex = -1; // λ“λκ·Έ μ¤‘μΈ μ¶λ° μ„μΉ ν™”μ‚΄ν‘ μΈλ±μ¤
        this.draggingStartLine = false; // λ“λκ·Έ μ¤‘μΈ μ‹μ‘μ„ 
        this.hoveredPointIndex = -1; // νΈλ²„ μ¤‘μΈ ν¬μΈνΈ μΈλ±μ¤
        this.hoveredCheckpointIndex = -1; // νΈλ²„ μ¤‘μΈ μ²΄ν¬ν¬μΈνΈ μΈλ±μ¤
        this.hoveredKerbIndex = -1; // νΈλ²„ μ¤‘μΈ μ—°μ„ μΈλ±μ¤
        this.hoveredSpawnIndex = -1; // νΈλ²„ μ¤‘μΈ μ¶λ° μ„μΉ μΈλ±μ¤
        this.hoveredStartLine = false; // νΈλ²„ μ¤‘μΈ μ‹μ‘μ„ 
        this.mode = 'add'; // 'add', 'move', 'delete', 'addCheckpoint', 'moveCheckpoint', 'deleteCheckpoint', 'addKerb', 'moveKerb', 'deleteKerb', 'addSpawn', 'moveSpawn', 'deleteSpawn', 'setStartLine', 'moveStartLine', 'deleteStartLine'
        this.zoom = 1;
        this.offsetX = 0;
        this.offsetY = 0;
        this.previewMode = false;
        
        // ν¬(μ΄λ™) κ΄€λ ¨ λ³€μ
        this.isPanning = false;
        this.panStartX = 0;
        this.panStartY = 0;
        this.panStartOffsetX = 0;
        this.panStartOffsetY = 0;
        
        // λ―Έλ‹λ§µ λ“λκ·Έ κ΄€λ ¨ λ³€μ
        this.isMinimapDragging = false;
        this.minimapDragStartX = 0;
        this.minimapDragStartY = 0;
        
        // λ λ”λ§ μµμ ν™”λ¥Ό μ„ν• λ³€μ
        this.animationFrameId = null;
        this.pendingRender = false;
        
        // μ—°μ„ μ΄λ™ μ„±λ¥ μµμ ν™”λ¥Ό μ„ν• μΊμ‹
        this._smoothPathCache = null;
        this._trackBoundsCache = null;
        this._pointsHash = null; // ν¬μΈνΈ λ°°μ—΄ ν•΄μ‹ (μΊμ‹ λ¬΄ν¨ν™”μ©)

        // μΊ”λ²„μ¤ ν¬κΈ° μ΅°μ •
        this.resizeCanvas();
        window.addEventListener('resize', () => this.resizeCanvas());

        // localStorageμ—μ„ λ°μ΄ν„° λ³µμ›
        this.loadFromStorage();
        
        this.setupEventListeners();
        
        // λ¨λ“ λ³µμ› (λ²„νΌμ΄ μƒμ„±λ ν›„μ— μ‹¤ν–‰)
        const savedMode = localStorage.getItem('trackEditor_mode');
        if (savedMode) {
          this.setMode(savedMode);
        }
        
        this.updateCodeOutput();
        
        // μ΄κΈ° λ λ”λ§μ€ μ•½κ°„ μ§€μ—°ν•μ—¬ DOMμ΄ μ™„μ „ν λ΅λ“λ ν›„ μν–‰
        // requestAnimationFrameμ„ μ‚¬μ©ν•μ—¬ λΈλΌμ°μ €κ°€ μ¤€λΉ„λ ν›„ λ λ”λ§
        requestAnimationFrame(() => {
          // μΊ”λ²„μ¤ ν¬κΈ° μ¬ν™•μΈ
          this.resizeCanvas();
          
          // μ €μ¥λ μ¤ μƒνƒκ°€ μμΌλ©΄ λ³µμ›, μ—†μΌλ©΄ resetView νΈμ¶
          // (loadFromStorageμ—μ„ μ΄λ―Έ λ³µμ›λμ—μ„ μ μμ§€λ§, μΊ”λ²„μ¤ ν¬κΈ°κ°€ μ¤€λΉ„λ ν›„ λ‹¤μ‹ ν™•μΈ)
          const savedZoom = localStorage.getItem('trackEditor_zoom');
          const savedOffsetX = localStorage.getItem('trackEditor_offsetX');
          const savedOffsetY = localStorage.getItem('trackEditor_offsetY');
          if (savedZoom && savedOffsetX !== null && savedOffsetY !== null) {
            // μ €μ¥λ μΉ΄λ©”λΌ μ„μΉμ™€ μ¤ λ³µμ›
            this.zoom = parseFloat(savedZoom);
            this.offsetX = parseFloat(savedOffsetX);
            this.offsetY = parseFloat(savedOffsetY);
          } else {
            // μ €μ¥λ μƒνƒκ°€ μ—†μΌλ©΄ μ΄κΈ° λ·°λ΅ λ¦¬μ…‹ (μ΄κΈ° λ΅λ“ μ‹μ—λ” μ €μ¥ν•μ§€ μ•μ)
            this.resetView(true);
          }
          
          // μ¦‰μ‹ λ λ”λ§
          this.render();
          
          // μ¶”κ°€λ΅ ν• λ² λ” λ λ”λ§ (μΊ”λ²„μ¤κ°€ μ™„μ „ν μ¤€λΉ„λ ν›„)
          setTimeout(() => {
            // μΊ”λ²„μ¤ ν¬κΈ°κ°€ λ³€κ²½λμ—μ„ μ μμΌλ―€λ΅ μ¬ν™•μΈ
            const prevCanvasWidth = this.canvas.width;
            const prevCanvasHeight = this.canvas.height;
            this.resizeCanvas();
            
            // μΊ”λ²„μ¤ ν¬κΈ°κ°€ λ³€κ²½λ κ²½μ° μ €μ¥λ μ¤ν”„μ…‹ κ°’ μ΅°μ •
            if (prevCanvasWidth !== this.canvas.width || prevCanvasHeight !== this.canvas.height) {
              const savedZoom2 = localStorage.getItem('trackEditor_zoom');
              const savedOffsetX2 = localStorage.getItem('trackEditor_offsetX');
              const savedOffsetY2 = localStorage.getItem('trackEditor_offsetY');
              if (savedZoom2 && savedOffsetX2 && savedOffsetY2) {
                // μ €μ¥λ κ°’μ„ λ‹¤μ‹ λ³µμ› (μΊ”λ²„μ¤ ν¬κΈ° λ³€κ²½ ν›„)
                this.zoom = parseFloat(savedZoom2);
                this.offsetX = parseFloat(savedOffsetX2);
                this.offsetY = parseFloat(savedOffsetY2);
              }
            }
            
            this.render();
          }, 50);
        });
      }
      
      // localStorageμ— μ €μ¥
      saveToStorage() {
        window.TrackEditorTrackManager.saveToStorage(this);
      }
      
      // localStorageμ—μ„ λ³µμ›
      loadFromStorage() {
        window.TrackEditorTrackManager.loadFromStorage(this);
      }

      resizeCanvas() {
        const container = this.canvas.parentElement;
        const rect = container.getBoundingClientRect();
        this.canvas.width = rect.width;
        this.canvas.height = rect.height;
        
        // λ―Έλ‹λ§µ μΊ”λ²„μ¤ ν¬κΈ° μ„¤μ •
        if (this.minimapCanvas) {
          this.minimapCanvas.width = 200;
          this.minimapCanvas.height = 150;
        }
      }

      setupEventListeners() {
        window.TrackEditorEventHandler.setupEventListeners(this);
      }

      setMode(mode) {
        window.TrackEditorUIManager.setMode(this, mode);
      }

      togglePreview() {
        window.TrackEditorUIManager.togglePreview(this);
      }

      // μΊ”λ²„μ¤ μΆν‘λ¥Ό μ›”λ“ μΆν‘λ΅ λ³€ν™
      canvasToWorld(canvasX, canvasY) {
        return window.TrackEditorUtils.canvasToWorld(canvasX, canvasY, this.offsetX, this.offsetY, this.zoom);
      }
      
      // μ›”λ“ μΆν‘λ¥Ό μΊ”λ²„μ¤ μΆν‘λ΅ λ³€ν™
      worldToCanvas(worldX, worldY) {
        return window.TrackEditorUtils.worldToCanvas(worldX, worldY, this.offsetX, this.offsetY, this.zoom);
      }
      
      getCanvasPoint(e, round = true) {
        return window.TrackEditorUtils.getCanvasPoint(e, this.canvas, this.offsetX, this.offsetY, this.zoom, round);
      }

      findPointAt(x, y, radius = 10) {
        return window.TrackEditorUtils.findPointAt(x, y, this.points, radius);
      }
      
      // νΈλ™ μ¤‘μ‹¬μ„ μ— κ°€μ¥ κ°€κΉμ΄ μ  μ°ΎκΈ° (μ¤λƒ…μ©)
      snapToTrackCenter(x, y) {
        return window.TrackEditorUtils.snapToTrackCenter(x, y, this.points);
      }
      
      // μ²΄ν¬ν¬μΈνΈ κ°λ„ κ³„μ‚° (κ°€μ¥ κ°€κΉμ΄ νΈλ™ ν¬μΈνΈμ λ°©ν–¥)
      calculateCheckpointAngle(x, y) {
        return window.TrackEditorUtils.calculateCheckpointAngle(x, y, this.points);
      }
      
      // μ²΄ν¬ν¬μΈνΈ μ°ΎκΈ°
      findCheckpointAt(x, y, radius = 15) {
        return window.TrackEditorUtils.findCheckpointAt(x, y, this.checkpoints, radius);
      }
      
      // μ¶λ° μ„μΉ μ°ΎκΈ°
      findSpawnAt(x, y, radius = 15) {
        return window.TrackEditorUtils.findSpawnAt(x, y, this.spawnPositions, radius);
      }
      
      // μ²΄ν¬ν¬μΈνΈ ν™”μ‚΄ν‘ λ λ¶€λ¶„ μ°ΎκΈ°
      findCheckpointArrowAt(x, y, radius = 10) {
        for (let i = this.checkpoints.length - 1; i >= 0; i--) {
          const cp = this.checkpoints[i];
          const arrowLength = 20;
          const arrowX = cp.x + Math.cos(cp.angle) * arrowLength;
          const arrowY = cp.y + Math.sin(cp.angle) * arrowLength;
          const dx = x - arrowX;
          const dy = y - arrowY;
          if (dx * dx + dy * dy < radius * radius) {
            return i;
          }
        }
        return -1;
      }
      
      // μ¶λ° μ„μΉ ν™”μ‚΄ν‘ λ λ¶€λ¶„ μ°ΎκΈ°
      findSpawnArrowAt(x, y, radius = 10) {
        for (let i = this.spawnPositions.length - 1; i >= 0; i--) {
          const spawn = this.spawnPositions[i];
          const arrowLength = 20;
          const arrowX = spawn.x + Math.cos(this.spawnAngle) * arrowLength;
          const arrowY = spawn.y + Math.sin(this.spawnAngle) * arrowLength;
          const dx = x - arrowX;
          const dy = y - arrowY;
          if (dx * dx + dy * dy < radius * radius) {
            return i;
          }
        }
        return -1;
      }
      
    // μ‹μ‘μ„  μ°ΎκΈ° (νΈλ™ μ „μ²΄λ¥Ό κ°€λ΅μ§€λ¥΄λ” μ‹μ‘μ„ )
    findStartLineAt(x, y, threshold = 30) {
        const trackWidth = parseInt(document.getElementById('trackWidth')?.value || '120') || 120;
        return window.TrackEditorUtils.findStartLineAt(x, y, this.startLine, trackWidth, threshold, this.points);
    }

      
      // μ—°μ„ μ°ΎκΈ°
      // μ—°μ„ κ°μ§€ - κ²½λ΅ κΈ°λ°
      findKerbAt(x, y, threshold = 30) {
        return window.TrackEditorUtils.findKerbAt(x, y, this.curbs, threshold);
      }
      
      // κ°€μ¥ κ°€κΉμ΄ νΈλ™ κ²½κ³„ μ°ΎκΈ° (μ—°μ„ λ°°μΉμ©) - κ°μ„ λ λ²„μ „
      findNearestTrackBoundary(x, y, kerbLength = 300, isDragging = false) {
        const trackWidth = parseInt(document.getElementById('trackWidth')?.value || '120') || 120;
        return window.TrackEditorUtils.findNearestTrackBoundary(x, y, this.points, trackWidth, kerbLength, isDragging, this);
      }
      
      // μΊμ‹ λ¬΄ν¨ν™” (ν¬μΈνΈ λ³€κ²½ μ‹ νΈμ¶)
      invalidatePathCache() {
        this._smoothPathCache = null;
        this._trackBoundsCache = null;
        this._pointsHash = null;
      }
      
      // κ²½λ΅μ—μ„ μ§€μ •λ κΈΈμ΄λ§νΌμ μ„Έκ·Έλ¨ΌνΈ μ¶”μ¶ (μ„Έλ°€ν• μ„μΉ κ³ λ ¤)
      extractPathSegment(path, startIndex, targetLength, t = 0) {
        return window.TrackEditorUtils.extractPathSegment(path, startIndex, targetLength, t);
      }

      handleCanvasClick(e) {
        const point = this.getCanvasPoint(e);
        
        if (this.mode === 'add') {
          this.addPoint(point.x, point.y);
        } else if (this.mode === 'delete') {
          const index = this.findPointAt(point.x, point.y);
          if (index >= 0) {
            this.deletePoint(index);
          }
        } else if (this.mode === 'addCheckpoint') {
          // κ°€μ¥ κ°€κΉμ΄ ν¬μΈνΈμ κ°λ„ κ³„μ‚°
          const angle = this.calculateCheckpointAngle(point.x, point.y);
          this.addCheckpoint(point.x, point.y, angle);
        } else if (this.mode === 'deleteCheckpoint') {
          const index = this.findCheckpointAt(point.x, point.y);
          if (index >= 0) {
            this.deleteCheckpoint(index);
          }
        } else if (this.mode === 'addKerb') {
          console.log('addKerb mode, point:', point);
          // κΈ°λ³Έ μ—°μ„ κΈΈμ΄ 300
          const kerbLength = 300;
          this.addKerb(point.x, point.y, kerbLength);
        } else if (this.mode === 'deleteKerb') {
          const index = this.findKerbAt(point.x, point.y);
          if (index >= 0) {
            this.deleteKerb(index);
          }
        } else if (this.mode === 'addSpawn') {
          this.addSpawn(point.x, point.y);
        } else if (this.mode === 'deleteSpawn') {
          const index = this.findSpawnAt(point.x, point.y);
          if (index >= 0) {
            this.deleteSpawn(index);
          }
        } else if (this.mode === 'setStartLine') {
          // μ‹μ‘μ„  μ„¤μ •: ν΄λ¦­ν• μ„μΉλ¥Ό νΈλ™ μ¤‘μ‹¬μ„ μ— μ¤λƒ…, κ°λ„λ” κ°€μ¥ κ°€κΉμ΄ νΈλ™ ν¬μΈνΈμ λ°©ν–¥μΌλ΅ κ³„μ‚°
          const snappedPoint = this.snapToTrackCenter(point.x, point.y);
          const angle = this.calculateCheckpointAngle(snappedPoint.x, snappedPoint.y);
          this.startLine = { x: snappedPoint.x, y: snappedPoint.y, angle: angle };
          if (document.getElementById('startLineX')) document.getElementById('startLineX').value = snappedPoint.x;
          if (document.getElementById('startLineY')) document.getElementById('startLineY').value = snappedPoint.y;
          if (document.getElementById('startLineAngle')) document.getElementById('startLineAngle').value = angle.toFixed(3);
          if (document.getElementById('startLineAngleDeg')) document.getElementById('startLineAngleDeg').value = Math.round(angle * 180 / Math.PI);
          this.updateCodeOutput();
          this.saveToStorage();
          this.render();
        } else if (this.mode === 'deleteStartLine') {
          if (this.findStartLineAt(point.x, point.y)) {
            this.startLine = { x: 0, y: 0, angle: 0 };
            if (document.getElementById('startLineX')) document.getElementById('startLineX').value = 0;
            if (document.getElementById('startLineY')) document.getElementById('startLineY').value = 0;
            if (document.getElementById('startLineAngle')) document.getElementById('startLineAngle').value = '0.000';
            if (document.getElementById('startLineAngleDeg')) document.getElementById('startLineAngleDeg').value = '0';
            this.updateCodeOutput();
            this.saveToStorage();
            this.render();
          }
        }
      }

      handleMouseDown(e) {
        // μ°ν΄λ¦­ λλ” μ¤νμ΄μ¤λ°” + λ“λκ·Έλ΅ ν¬
        if (e.button === 2 || (e.button === 0 && e.spaceKey)) {
          this.isPanning = true;
          this.panStartX = e.clientX;
          this.panStartY = e.clientY;
          this.panStartOffsetX = this.offsetX;
          this.panStartOffsetY = this.offsetY;
          this.canvas.style.cursor = 'grabbing';
          return;
        }
        
        const point = this.getCanvasPoint(e, false); // ν™”μ‚΄ν‘ λ“λκ·Έλ” λ¶€λ“λ¬μ΄ μ΄λ™μ„ μ„ν•΄ λ°μ¬λ¦Όν•μ§€ μ•μ
        
        // ν™”μ‚΄ν‘ λ“λκ·Έ κ°μ§€ (μ²΄ν¬ν¬μΈνΈλ‚ μ¶λ° μ„μΉκ°€ μ„ νƒλ μƒνƒμ—μ„ ν™”μ‚΄ν‘ λ λ¶€λ¶„ ν΄λ¦­)
        if (this.selectedCheckpointIndex >= 0) {
          const arrowIndex = this.findCheckpointArrowAt(point.x, point.y);
          if (arrowIndex >= 0 && arrowIndex === this.selectedCheckpointIndex) {
            this.draggingCheckpointAngleIndex = arrowIndex;
            return; // ν™”μ‚΄ν‘ λ“λκ·Έ μ‹μ‘
          }
        }
        if (this.selectedSpawnIndex >= 0) {
          const arrowIndex = this.findSpawnArrowAt(point.x, point.y);
          if (arrowIndex >= 0 && arrowIndex === this.selectedSpawnIndex) {
            this.draggingSpawnAngleIndex = arrowIndex;
            return; // ν™”μ‚΄ν‘ λ“λκ·Έ μ‹μ‘
          }
        }
        
        if (this.mode === 'move') {
          this.draggingPointIndex = this.findPointAt(point.x, point.y);
          if (this.draggingPointIndex >= 0) {
            this.selectedPointIndex = this.draggingPointIndex;
            this.selectedCheckpointIndex = -1;
            this.updatePointList();
            this.updateSelectedPointInfo();
            this.updateCheckpointList();
            this.updateSelectedCheckpointInfo();
          }
        } else if (this.mode === 'moveCheckpoint') {
          this.draggingCheckpointIndex = this.findCheckpointAt(point.x, point.y);
          if (this.draggingCheckpointIndex >= 0) {
            this.selectedCheckpointIndex = this.draggingCheckpointIndex;
            this.selectedPointIndex = -1;
            this.selectedKerbIndex = -1;
            this.updatePointList();
            this.updateSelectedPointInfo();
            this.updateCheckpointList();
            this.updateSelectedCheckpointInfo();
            this.updateKerbList();
            this.updateSelectedKerbInfo();
          }
        } else if (this.mode === 'moveKerb') {
          this.draggingKerbIndex = this.findKerbAt(point.x, point.y);
          if (this.draggingKerbIndex >= 0) {
            this.selectedKerbIndex = this.draggingKerbIndex;
            this.selectedPointIndex = -1;
            this.selectedCheckpointIndex = -1;
            this.updatePointList();
            this.updateSelectedPointInfo();
            this.updateCheckpointList();
            this.updateSelectedCheckpointInfo();
            this.updateKerbList();
            this.updateSelectedKerbInfo();
          }
        } else if (this.mode === 'moveSpawn') {
          this.draggingSpawnIndex = this.findSpawnAt(point.x, point.y);
          if (this.draggingSpawnIndex >= 0) {
            this.selectedSpawnIndex = this.draggingSpawnIndex;
            this.selectedPointIndex = -1;
            this.selectedCheckpointIndex = -1;
            this.selectedKerbIndex = -1;
            this.updatePointList();
            this.updateSelectedPointInfo();
            this.updateCheckpointList();
            this.updateSelectedCheckpointInfo();
            this.updateKerbList();
            this.updateSelectedKerbInfo();
            this.updateSpawnList();
            this.updateSelectedSpawnInfo();
          }
        } else if (this.mode === 'moveStartLine') {
          if (this.findStartLineAt(point.x, point.y)) {
            this.draggingStartLine = true;
          }
        }
      }

      handleMouseMove(e) {
        // ν¬ μ¤‘μΌ λ•
        if (this.isPanning) {
          const deltaX = e.clientX - this.panStartX;
          const deltaY = e.clientY - this.panStartY;
          this.offsetX = this.panStartOffsetX + deltaX;
          this.offsetY = this.panStartOffsetY + deltaY;
          this.saveToStorage(); // μ €μ¥ (throttle ν•„μ”ν•  μ μμ)
          this.render();
          return;
        }
        
        // μ‚­μ /μ΄λ™ λ¨λ“μΌ λ• νΈλ²„ κ°€λ¥ν• ν•­λ© κ°μ§€ λ° μ»¤μ„ λ³€κ²½
        const point = this.getCanvasPoint(e);
        let cursorChanged = false;
        
        if (this.mode === 'delete' || this.mode === 'move') {
          const pointIndex = this.findPointAt(point.x, point.y);
          if (pointIndex >= 0) {
            if (this.hoveredPointIndex !== pointIndex) {
              this.hoveredPointIndex = pointIndex;
              this.canvas.style.cursor = this.mode === 'delete' ? 'pointer' : 'move';
              cursorChanged = true;
              this.render();
            }
          } else if (this.hoveredPointIndex >= 0) {
            this.hoveredPointIndex = -1;
            this.canvas.style.cursor = this.mode === 'delete' ? 'not-allowed' : 'move';
            cursorChanged = true;
            this.render();
          }
        } else if (this.mode === 'deleteCheckpoint' || this.mode === 'moveCheckpoint') {
          // λ¨Όμ € ν™”μ‚΄ν‘ κ°μ§€ (μ„ νƒλ μ²΄ν¬ν¬μΈνΈκ°€ μμ„ λ•)
          if (this.selectedCheckpointIndex >= 0) {
            const arrowIndex = this.findCheckpointArrowAt(point.x, point.y);
            if (arrowIndex >= 0 && arrowIndex === this.selectedCheckpointIndex) {
              this.canvas.style.cursor = 'grab';
              return; // ν™”μ‚΄ν‘ μ„μ— μμΌλ©΄ μ²΄ν¬ν¬μΈνΈ κ°μ§€ν•μ§€ μ•μ
            }
          }
          
          const checkpointIndex = this.findCheckpointAt(point.x, point.y);
          if (checkpointIndex >= 0) {
            if (this.hoveredCheckpointIndex !== checkpointIndex) {
              this.hoveredCheckpointIndex = checkpointIndex;
              this.canvas.style.cursor = this.mode === 'deleteCheckpoint' ? 'pointer' : 'move';
              cursorChanged = true;
              this.render();
            }
          } else if (this.hoveredCheckpointIndex >= 0) {
            this.hoveredCheckpointIndex = -1;
            this.canvas.style.cursor = this.mode === 'deleteCheckpoint' ? 'not-allowed' : 'move';
            cursorChanged = true;
            this.render();
          }
        } else if (this.mode === 'deleteKerb' || this.mode === 'moveKerb') {
          const kerbIndex = this.findKerbAt(point.x, point.y);
          if (kerbIndex >= 0) {
            if (this.hoveredKerbIndex !== kerbIndex) {
              this.hoveredKerbIndex = kerbIndex;
              this.canvas.style.cursor = this.mode === 'deleteKerb' ? 'pointer' : 'move';
              cursorChanged = true;
              this.render();
            }
          } else if (this.hoveredKerbIndex >= 0) {
            this.hoveredKerbIndex = -1;
            this.canvas.style.cursor = this.mode === 'deleteKerb' ? 'not-allowed' : 'move';
            cursorChanged = true;
            this.render();
          }
        } else if (this.mode === 'deleteSpawn' || this.mode === 'moveSpawn') {
          // λ¨Όμ € ν™”μ‚΄ν‘ κ°μ§€ (μ„ νƒλ μ¶λ° μ„μΉκ°€ μμ„ λ•)
          if (this.selectedSpawnIndex >= 0) {
            const arrowIndex = this.findSpawnArrowAt(point.x, point.y);
            if (arrowIndex >= 0 && arrowIndex === this.selectedSpawnIndex) {
              this.canvas.style.cursor = 'grab';
              return; // ν™”μ‚΄ν‘ μ„μ— μμΌλ©΄ μ¶λ° μ„μΉ κ°μ§€ν•μ§€ μ•μ
            }
          }
          
          const spawnIndex = this.findSpawnAt(point.x, point.y);
          if (spawnIndex >= 0) {
            if (this.hoveredSpawnIndex !== spawnIndex) {
              this.hoveredSpawnIndex = spawnIndex;
              this.canvas.style.cursor = this.mode === 'deleteSpawn' ? 'pointer' : 'move';
              cursorChanged = true;
              this.render();
            }
          } else if (this.hoveredSpawnIndex >= 0) {
            this.hoveredSpawnIndex = -1;
            this.canvas.style.cursor = this.mode === 'deleteSpawn' ? 'not-allowed' : 'move';
            cursorChanged = true;
            this.render();
          }
        } else if (this.mode === 'deleteStartLine' || this.mode === 'moveStartLine') {
          const isHovered = this.findStartLineAt(point.x, point.y);
          if (isHovered !== this.hoveredStartLine) {
            this.hoveredStartLine = isHovered;
            this.canvas.style.cursor = this.mode === 'deleteStartLine' ? 'pointer' : 'move';
            cursorChanged = true;
            this.render();
          }
        } else {
          // λ‹¤λ¥Έ λ¨λ“μΌ λ•λ„ μ„ νƒλ μ²΄ν¬ν¬μΈνΈλ‚ μ¶λ° μ„μΉμ ν™”μ‚΄ν‘ λ“λκ·Έ κ°€λ¥
          if (this.selectedCheckpointIndex >= 0) {
            const arrowIndex = this.findCheckpointArrowAt(point.x, point.y);
            if (arrowIndex >= 0 && arrowIndex === this.selectedCheckpointIndex) {
              this.canvas.style.cursor = 'grab';
              return;
            }
          }
          if (this.selectedSpawnIndex >= 0) {
            const arrowIndex = this.findSpawnArrowAt(point.x, point.y);
            if (arrowIndex >= 0 && arrowIndex === this.selectedSpawnIndex) {
              this.canvas.style.cursor = 'grab';
              return;
            }
          }
          
          // νΈλ²„ μƒνƒ μ΄κΈ°ν™”
          if (this.hoveredPointIndex >= 0 || this.hoveredCheckpointIndex >= 0 || this.hoveredKerbIndex >= 0 || this.hoveredSpawnIndex >= 0 || this.hoveredStartLine) {
            this.hoveredPointIndex = -1;
            this.hoveredCheckpointIndex = -1;
            this.hoveredKerbIndex = -1;
            this.hoveredSpawnIndex = -1;
            this.hoveredStartLine = false;
            this.render();
          }
        }
        
        if (cursorChanged) {
          return; // μ»¤μ„ λ³€κ²½λ§ ν–μΌλ©΄ λ“λκ·Έ μ²λ¦¬ν•μ§€ μ•μ
        }
        
        if (this.draggingPointIndex >= 0 && this.mode === 'move') {
          const point = this.getCanvasPoint(e);
          const currentPoint = this.points[this.draggingPointIndex];
          this.points[this.draggingPointIndex] = { 
            x: point.x, 
            y: point.y, 
            type: currentPoint.type || 'straight' 
          };
          // κ²½λ΅ μΊμ‹ λ¬΄ν¨ν™” (ν¬μΈνΈ μΆν‘κ°€ λ³€κ²½λ¨)
          this.invalidatePathCache();
          this.updateSelectedPointInfo();
          this.updateCodeOutput();
          this.saveToStorage(); // μ €μ¥
          this.render();
        } else if (this.draggingCheckpointAngleIndex >= 0) {
          // μ²΄ν¬ν¬μΈνΈ ν™”μ‚΄ν‘ λ“λκ·Έ - κ°λ„ λ³€κ²½
          const point = this.getCanvasPoint(e, false);
          const cp = this.checkpoints[this.draggingCheckpointAngleIndex];
          const angle = Math.atan2(point.y - cp.y, point.x - cp.x);
          this.checkpoints[this.draggingCheckpointAngleIndex].angle = angle;
          this.updateSelectedCheckpointInfo();
          this.updateCheckpointList();
          this.canvas.style.cursor = 'grabbing';
          this.render();
        } else if (this.draggingSpawnAngleIndex >= 0) {
          // μ¶λ° μ„μΉ ν™”μ‚΄ν‘ λ“λκ·Έ - κ°λ„ λ³€κ²½
          const point = this.getCanvasPoint(e, false);
          const spawn = this.spawnPositions[this.draggingSpawnAngleIndex];
          const angle = Math.atan2(point.y - spawn.y, point.x - spawn.x);
          this.spawnAngle = angle;
          if (document.getElementById('spawnAngle')) document.getElementById('spawnAngle').value = angle.toFixed(3);
          if (document.getElementById('spawnAngleDeg')) document.getElementById('spawnAngleDeg').value = Math.round(angle * 180 / Math.PI);
          this.updateSelectedSpawnInfo();
          this.updateSpawnList();
          this.canvas.style.cursor = 'grabbing';
          this.render();
        } else if (this.draggingCheckpointIndex >= 0 && this.mode === 'moveCheckpoint') {
          const point = this.getCanvasPoint(e);
          const currentCheckpoint = this.checkpoints[this.draggingCheckpointIndex];
          this.checkpoints[this.draggingCheckpointIndex] = {
            x: point.x,
            y: point.y,
            angle: currentCheckpoint.angle || 0
          };
          this.updateSelectedCheckpointInfo();
          this.updateCodeOutput();
          this.saveToStorage(); // μ €μ¥
          this.render();
        } else if (this.draggingKerbIndex >= 0 && this.mode === 'moveKerb') {
          // μ—°μ„ μ΄λ™ μ‹ λ¶€λ“λ¬μ΄ μ΄λ™μ„ μ„ν•΄ λ°μ¬λ¦Όν•μ§€ μ•μ
          const point = this.getCanvasPoint(e, false);
          const currentKerb = this.curbs[this.draggingKerbIndex];
          // νΈλ™ κ²½κ³„λ¥Ό λ”°λΌ μƒλ΅μ΄ κ²½λ΅ μƒμ„±
          const kerbLength = currentKerb.length || 300;
          // λ“λκ·Έ μ¤‘μ—λ” μƒν”λ§ κ°μλ¥Ό μ¤„μ—¬μ„ λ¶€λ“λ¬μ΄ μ΄λ™ (true = isDragging)
          const boundary = this.findNearestTrackBoundary(point.x, point.y, kerbLength, true);
          
          if (boundary && boundary.kerbPath && boundary.kerbPath.length >= 2) {
            this.curbs[this.draggingKerbIndex] = {
              centerPath: boundary.kerbPath,
              width: currentKerb.width || 20,
              length: kerbLength,
              trackSide: boundary.isInner ? 'inner' : 'outer'
            };
            this.updateSelectedKerbInfo();
            // λ¶€λ“λ¬μ΄ μ΄λ™μ„ μ„ν•΄ requestAnimationFrame μ‚¬μ©
            this.scheduleRender();
            // μ €μ¥μ€ λ“λκ·Έ μΆ…λ£ μ‹μ—λ§ μν–‰ (μ„±λ¥ μµμ ν™”)
          }
        } else if (this.draggingSpawnIndex >= 0 && this.mode === 'moveSpawn') {
          const point = this.getCanvasPoint(e, false);
          this.spawnPositions[this.draggingSpawnIndex] = {
            x: point.x,
            y: point.y
          };
          this.updateSelectedSpawnInfo();
          this.updateCodeOutput();
          this.saveToStorage();
          this.render();
        } else if (this.draggingStartLine && this.mode === 'moveStartLine') {
          const point = this.getCanvasPoint(e, false);
          // νΈλ™ μ¤‘μ‹¬μ„ μ— μ¤λƒ…
          const snappedPoint = this.snapToTrackCenter(point.x, point.y);
          // κ°λ„λ” κ°€μ¥ κ°€κΉμ΄ νΈλ™ ν¬μΈνΈμ λ°©ν–¥μΌλ΅ κ³„μ‚°
          const angle = this.calculateCheckpointAngle(snappedPoint.x, snappedPoint.y);
          this.startLine = { x: snappedPoint.x, y: snappedPoint.y, angle: angle };
          if (document.getElementById('startLineX')) document.getElementById('startLineX').value = snappedPoint.x;
          if (document.getElementById('startLineY')) document.getElementById('startLineY').value = snappedPoint.y;
          if (document.getElementById('startLineAngle')) document.getElementById('startLineAngle').value = angle.toFixed(3);
          if (document.getElementById('startLineAngleDeg')) document.getElementById('startLineAngleDeg').value = Math.round(angle * 180 / Math.PI);
          this.updateCodeOutput();
          this.saveToStorage();
          this.render();
        }
      }

      handleMouseUp(e) {
        if (this.isPanning) {
          this.isPanning = false;
          const cursorMap = {
            'add': 'crosshair',
            'addCheckpoint': 'crosshair',
            'move': 'move',
            'moveCheckpoint': 'move',
            'delete': 'pointer',
            'deleteCheckpoint': 'pointer'
          };
          this.canvas.style.cursor = cursorMap[this.mode] || 'default';
          this.saveToStorage(); // ν¬ μΆ…λ£ μ‹ μ €μ¥
        }
        
        if (this.draggingPointIndex >= 0) {
          this.draggingPointIndex = -1;
        }
        
        if (this.draggingCheckpointAngleIndex >= 0) {
          // μ²΄ν¬ν¬μΈνΈ ν™”μ‚΄ν‘ λ“λκ·Έ μΆ…λ£
          this.updateCodeOutput();
          this.saveToStorage();
          this.draggingCheckpointAngleIndex = -1;
          this.canvas.style.cursor = 'default';
        }
        
        if (this.draggingSpawnAngleIndex >= 0) {
          // μ¶λ° μ„μΉ ν™”μ‚΄ν‘ λ“λκ·Έ μΆ…λ£
          this.updateCodeOutput();
          this.saveToStorage();
          this.draggingSpawnAngleIndex = -1;
          this.canvas.style.cursor = 'default';
        }
        
        if (this.draggingCheckpointIndex >= 0) {
          this.draggingCheckpointIndex = -1;
        }
        
        if (this.draggingKerbIndex >= 0) {
          this.draggingKerbIndex = -1;
          // λ“λκ·Έ μΆ…λ£ μ‹ μ •λ°€ν• μ„μΉλ΅ μ¬κ³„μ‚° (isDragging=falseλ΅ μƒν”λ§ κ°μ 20)
          const point = this.getCanvasPoint(e, false);
          const currentKerb = this.curbs[this.selectedKerbIndex];
          if (currentKerb) {
            const kerbLength = currentKerb.length || 300;
            const boundary = this.findNearestTrackBoundary(point.x, point.y, kerbLength, false);
            if (boundary && boundary.kerbPath && boundary.kerbPath.length >= 2) {
              this.curbs[this.selectedKerbIndex] = {
                centerPath: boundary.kerbPath,
                width: currentKerb.width || 20,
                length: kerbLength,
                trackSide: boundary.isInner ? 'inner' : 'outer'
              };
            }
          }
          this.updateSelectedKerbInfo();
          this.updateCodeOutput();
          this.saveToStorage(); // λ“λκ·Έ μΆ…λ£ μ‹ μ €μ¥
          this.render(); // μµμΆ… λ λ”λ§
        }
        
        if (this.draggingSpawnIndex >= 0) {
          this.draggingSpawnIndex = -1;
          this.updateCodeOutput();
          this.saveToStorage(); // λ“λκ·Έ μΆ…λ£ μ‹ μ €μ¥
          this.render(); // μµμΆ… λ λ”λ§
        }
        
        if (this.draggingStartLine) {
          this.draggingStartLine = false;
          this.updateCodeOutput();
          this.saveToStorage(); // λ“λκ·Έ μΆ…λ£ μ‹ μ €μ¥
          this.render(); // μµμΆ… λ λ”λ§
        }
      }
      
      handleWheel(e) {
        e.preventDefault();
        
        const rect = this.canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;
        
        // λ§μ°μ¤ μ»¤μ„ μ„μΉμ μ›”λ“ μΆν‘ κ³„μ‚° (μ¤ λ³€κ²½ μ „)
        // canvasToWorld: (canvasX - offsetX) / zoom
        const worldX = (mouseX - this.offsetX) / this.zoom;
        const worldY = (mouseY - this.offsetY) / this.zoom;
        
        // μ¤ λ³€κ²½
        const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
        const newZoom = Math.max(0.1, Math.min(5, this.zoom * zoomFactor));
        
        // λ§μ°μ¤ μ»¤μ„κ°€ κ°€λ¦¬ν‚¤λ” μ›”λ“ μΆν‘κ°€ κ°™μ€ ν™”λ©΄ μ„μΉμ— μλ„λ΅ μ¤ν”„μ…‹ μ΅°μ •
        // μƒλ΅μ΄ μ¤ν”„μ…‹ = λ§μ°μ¤ μ„μΉ - (μ›”λ“ μΆν‘ * μƒλ΅μ΄ μ¤)
        this.offsetX = mouseX - worldX * newZoom;
        this.offsetY = mouseY - worldY * newZoom;
        this.zoom = newZoom;
        
        this.saveToStorage(); // μ €μ¥
        this.render();
      }
      
      zoomIn() {
        window.TrackEditorUIManager.zoomIn(this);
      }
      
      zoomOut() {
        window.TrackEditorUIManager.zoomOut(this);
      }
      
      resetView() {
        window.TrackEditorTrackManager.resetView(this);
      }
      
      handleMinimapMouseDown(e) {
        e.preventDefault();
        this.isMinimapDragging = true;
        const rect = this.minimapCanvas.getBoundingClientRect();
        this.minimapDragStartX = e.clientX - rect.left;
        this.minimapDragStartY = e.clientY - rect.top;
        this.minimapCanvas.style.cursor = 'grabbing';
        this.updateMinimapView(this.minimapDragStartX, this.minimapDragStartY);
      }
      
      handleMinimapMouseMove(e) {
        if (!this.isMinimapDragging) return;
        e.preventDefault();
        const rect = this.minimapCanvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        this.updateMinimapView(x, y);
      }
      
      handleMinimapMouseUp(e) {
        if (!this.isMinimapDragging) return;
        this.isMinimapDragging = false;
        this.minimapCanvas.style.cursor = 'pointer';
        this.saveToStorage(); // μ €μ¥
      }
      
      updateMinimapView(x, y) {
        const width = parseInt(document.getElementById('mapWidth')?.value || '4500') || 4500;
        const height = parseInt(document.getElementById('mapHeight')?.value || '3000') || 3000;
        
        // λ―Έλ‹λ§µ μ¤μΌ€μΌ κ³„μ‚°
        const minimapScaleX = this.minimapCanvas.width / width;
        const minimapScaleY = this.minimapCanvas.height / height;
        const minimapScale = Math.min(minimapScaleX, minimapScaleY);
        
        const mapWidthOnMinimap = width * minimapScale;
        const mapHeightOnMinimap = height * minimapScale;
        const mapOffsetX = (this.minimapCanvas.width - mapWidthOnMinimap) / 2;
        const mapOffsetY = (this.minimapCanvas.height - mapHeightOnMinimap) / 2;
        
        // λ―Έλ‹λ§µ μΆν‘λ¥Ό μ›”λ“ μΆν‘λ΅ λ³€ν™
        const worldX = (x - mapOffsetX) / minimapScale;
        const worldY = (y - mapOffsetY) / minimapScale;
        
        // ν΄λ¦­ν• μ„μΉκ°€ ν™”λ©΄ μ¤‘μ•™μ— μ¤λ„λ΅ μ¤ν”„μ…‹ μ΅°μ •
        this.offsetX = this.canvas.width / 2 - worldX * this.zoom;
        this.offsetY = this.canvas.height / 2 - worldY * this.zoom;
        
        this.render();
      }
      
      renderMinimap() {
        if (!this.minimapCanvas || !this.minimapCtx) return;
        
        const width = parseInt(document.getElementById('mapWidth')?.value || '4500') || 4500;
        const height = parseInt(document.getElementById('mapHeight')?.value || '3000') || 3000;
        const trackWidth = parseInt(document.getElementById('trackWidth')?.value || '120') || 120;
        
        const minimapScaleX = this.minimapCanvas.width / width;
        const minimapScaleY = this.minimapCanvas.height / height;
        const minimapScale = Math.min(minimapScaleX, minimapScaleY);
        
        // λ―Έλ‹λ§µ μ΄κΈ°ν™”
        this.minimapCtx.clearRect(0, 0, this.minimapCanvas.width, this.minimapCanvas.height);
        
        // λ°°κ²½
        this.minimapCtx.fillStyle = '#1e4620';
        this.minimapCtx.fillRect(0, 0, this.minimapCanvas.width, this.minimapCanvas.height);
        
        // λ§µ μμ—­ ν‘μ‹
        const mapWidthOnMinimap = width * minimapScale;
        const mapHeightOnMinimap = height * minimapScale;
        const mapOffsetX = (this.minimapCanvas.width - mapWidthOnMinimap) / 2;
        const mapOffsetY = (this.minimapCanvas.height - mapHeightOnMinimap) / 2;
        
        // λ―Έλ‹λ§µμ—μ„λ„ κ²½κ³„μ„ μ„ λ” λμ— λ„κ²
        this.minimapCtx.strokeStyle = '#00d4ff'; // λ°μ€ νλ€μƒ‰
        this.minimapCtx.lineWidth = 2;
        this.minimapCtx.strokeRect(mapOffsetX, mapOffsetY, mapWidthOnMinimap, mapHeightOnMinimap);
        
        // νΈλ™ κ·Έλ¦¬κΈ°
        if (this.previewMode && this.points.length >= 2) {
          const smoothCenterPath = this.getSmoothPath(this.points, 100);
          const { innerPath, outerPath } = this.getTrackBounds(smoothCenterPath, trackWidth);
          const smoothInnerPath = this.getSmoothPath(innerPath, 100);
          const smoothOuterPath = this.getSmoothPath(outerPath, 100);
          
          // νΈλ™ μ±„μ°κΈ°
          this.minimapCtx.fillStyle = '#4a4a4a';
          this.minimapCtx.beginPath();
          if (smoothOuterPath.length > 0) {
            const p0 = smoothOuterPath[0];
            this.minimapCtx.moveTo(mapOffsetX + p0.x * minimapScale, mapOffsetY + p0.y * minimapScale);
            for (let i = 1; i < smoothOuterPath.length; i++) {
              const p = smoothOuterPath[i];
              this.minimapCtx.lineTo(mapOffsetX + p.x * minimapScale, mapOffsetY + p.y * minimapScale);
            }
            if (this.points.length > 2) {
              this.minimapCtx.closePath();
            }
          }
          if (smoothInnerPath.length > 0 && this.points.length > 2) {
            const p0 = smoothInnerPath[0];
            this.minimapCtx.moveTo(mapOffsetX + p0.x * minimapScale, mapOffsetY + p0.y * minimapScale);
            for (let i = smoothInnerPath.length - 1; i >= 0; i--) {
              const p = smoothInnerPath[i];
              this.minimapCtx.lineTo(mapOffsetX + p.x * minimapScale, mapOffsetY + p.y * minimapScale);
            }
            this.minimapCtx.closePath();
          }
          this.minimapCtx.fill('evenodd');
          
          // μ¤‘μ•™μ„ 
          this.minimapCtx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
          this.minimapCtx.lineWidth = 1;
          this.minimapCtx.beginPath();
          if (smoothCenterPath.length > 0) {
            const p0 = smoothCenterPath[0];
            this.minimapCtx.moveTo(mapOffsetX + p0.x * minimapScale, mapOffsetY + p0.y * minimapScale);
            for (let i = 1; i < smoothCenterPath.length; i++) {
              const p = smoothCenterPath[i];
              this.minimapCtx.lineTo(mapOffsetX + p.x * minimapScale, mapOffsetY + p.y * minimapScale);
            }
            if (this.points.length > 2) {
              this.minimapCtx.closePath();
            }
          }
          this.minimapCtx.stroke();
        } else if (this.points.length >= 2) {
          // νΈμ§‘ λ¨λ“: ν¬μΈνΈλ§ ν‘μ‹
          this.minimapCtx.strokeStyle = '#00ff88';
          this.minimapCtx.lineWidth = 1;
          this.minimapCtx.beginPath();
          const p0 = this.points[0];
          this.minimapCtx.moveTo(mapOffsetX + p0.x * minimapScale, mapOffsetY + p0.y * minimapScale);
          for (let i = 1; i < this.points.length; i++) {
            const p = this.points[i];
            this.minimapCtx.lineTo(mapOffsetX + p.x * minimapScale, mapOffsetY + p.y * minimapScale);
          }
          if (this.points.length > 2) {
            this.minimapCtx.closePath();
          }
          this.minimapCtx.stroke();
        }
        
        // ν¬μΈνΈ ν‘μ‹
        this.points.forEach((p, i) => {
          const x = mapOffsetX + p.x * minimapScale;
          const y = mapOffsetY + p.y * minimapScale;
          this.minimapCtx.fillStyle = i === this.selectedPointIndex ? '#00ff88' : '#fff';
          this.minimapCtx.beginPath();
          this.minimapCtx.arc(x, y, 2, 0, Math.PI * 2);
          this.minimapCtx.fill();
        });
        
        // ν„μ¬ λ·°ν¬νΈ ν‘μ‹
        const viewportWorldLeft = -this.offsetX / this.zoom;
        const viewportWorldTop = -this.offsetY / this.zoom;
        const viewportWorldRight = (this.canvas.width - this.offsetX) / this.zoom;
        const viewportWorldBottom = (this.canvas.height - this.offsetY) / this.zoom;
        
        const viewportMinimapX = mapOffsetX + viewportWorldLeft * minimapScale;
        const viewportMinimapY = mapOffsetY + viewportWorldTop * minimapScale;
        const viewportMinimapWidth = (viewportWorldRight - viewportWorldLeft) * minimapScale;
        const viewportMinimapHeight = (viewportWorldBottom - viewportWorldTop) * minimapScale;
        
        this.minimapCtx.strokeStyle = '#00ff88';
        this.minimapCtx.lineWidth = 2;
        this.minimapCtx.strokeRect(viewportMinimapX, viewportMinimapY, viewportMinimapWidth, viewportMinimapHeight);
      }

      addPoint(x, y) {
        window.TrackEditorPointManager.addPoint(this, x, y);
      }
      
      addCheckpoint(x, y, angle = 0) {
        window.TrackEditorCheckpointManager.addCheckpoint(this, x, y, angle);
      }
      
      deleteCheckpoint(index) {
        window.TrackEditorCheckpointManager.deleteCheckpoint(this, index);
      }
      
      addKerb(x, y, length = 300) {
        window.TrackEditorKerbManager.addKerb(this, x, y, length);
      }
      
      deleteKerb(index) {
        window.TrackEditorKerbManager.deleteKerb(this, index);
      }
      
      addSpawn(x, y) {
        window.TrackEditorSpawnManager.addSpawn(this, x, y);
      }
      
      deleteSpawn(index) {
        window.TrackEditorSpawnManager.deleteSpawn(this, index);
      }
      
      selectSpawn(index) {
        window.TrackEditorSpawnManager.selectSpawn(this, index);
      }
      
      updateSpawnList() {
        window.TrackEditorSpawnManager.updateSpawnList(this);
      }
      
      updateSelectedSpawnInfo() {
        window.TrackEditorSpawnManager.updateSelectedSpawnInfo(this);
      }
      
      updateSelectedSpawn() {
        window.TrackEditorSpawnManager.updateSelectedSpawn(this);
      }
      
      selectKerb(index) {
        window.TrackEditorKerbManager.selectKerb(this, index);
      }
      
      updateKerbList() {
        window.TrackEditorKerbManager.updateKerbList(this);
      }
      
      updateSelectedKerbInfo() {
        window.TrackEditorKerbManager.updateSelectedKerbInfo(this);
      }
      
      updateSelectedKerb() {
        window.TrackEditorKerbManager.updateSelectedKerb(this);
      }

      deletePoint(index) {
        window.TrackEditorPointManager.deletePoint(this, index);
      }

      updateSelectedPoint() {
        window.TrackEditorPointManager.updateSelectedPoint(this);
      }

      updateSelectedPointInfo() {
        window.TrackEditorPointManager.updateSelectedPointInfo(this);
      }
      
      setPointType(type) {
        window.TrackEditorPointManager.setPointType(this, type);
      }

      updatePointList() {
        window.TrackEditorPointManager.updatePointList(this);
      }

      selectPoint(index) {
        window.TrackEditorPointManager.selectPoint(this, index);
      }
      
      selectCheckpoint(index) {
        window.TrackEditorCheckpointManager.selectCheckpoint(this, index);
      }
      
      updateCheckpointList() {
        window.TrackEditorCheckpointManager.updateCheckpointList(this);
      }
      
      updateSelectedCheckpointInfo() {
        window.TrackEditorCheckpointManager.updateSelectedCheckpointInfo(this);
      }
      
      updateSelectedCheckpoint() {
        window.TrackEditorCheckpointManager.updateSelectedCheckpoint(this);
      }

      // μ§μ„ κ³Ό κ³΅μ„ μ„ κµ¬λ¶„ν•μ—¬ κ²½λ΅ μƒμ„± (μ „ν™ μ§€μ  λ¶€λ“λ½κ² μ²λ¦¬)
      getSmoothPath(points, targetPoints = 400) {
        return window.TrackEditorUtils.getSmoothPath(points, targetPoints);
      }
      
      // κ³΅μ„  μ—°μ„ κ·Έλ¦¬κΈ°
      // κ²½λ΅ κΈ°λ° μ—°μ„ κ·Έλ¦¬κΈ° - ν•λ‚μ μ—°μ†λ ν•νƒλ΅ (νΈλ™ λ°”κΉ¥μ½μ—λ§ λ°°μΉ)
      drawPathBasedKerb(centerPath, kerbWidth, trackSide = 'outer') {
        window.TrackEditorRenderer.drawPathBasedKerb(this.ctx, centerPath, kerbWidth, trackSide);
      }
      
      // κµ¬ν• κ³΅μ„  μ—°μ„ κ·Έλ¦¬κΈ° (ν•μ„ νΈν™μ„±)
      drawCurvedKerb(pathSegment, height, isSelected) {
        window.TrackEditorRenderer.drawCurvedKerb(this.ctx, pathSegment, height, isSelected);
      }

      // νΈλ™ κ²½κ³„ μƒμ„± (μ¤‘μ•™μ„ μ—μ„ μΆμ°λ΅ ν™•μ¥)
      getTrackBounds(centerPath, trackWidth) {
        return window.TrackEditorUtils.getTrackBounds(centerPath, trackWidth);
      }

      // λ¶€λ“λ¬μ΄ κ²½λ΅ κ·Έλ¦¬κΈ°
      drawSmoothPath(ctx, path, closed = false) {
        window.TrackEditorRenderer.drawSmoothPath(ctx, path, closed);
      }

      // λ λ”λ§ μ¤μΌ€μ¤„λ§ (λ¶€λ“λ¬μ΄ μ• λ‹λ©”μ΄μ…μ„ μ„ν•΄)
      scheduleRender() {
        window.TrackEditorRenderer.scheduleRender(this);
      }

      render() {
        if (!this.canvas || !this.ctx) return;
        
        const width = parseInt(document.getElementById('mapWidth')?.value || '4500') || 4500;
        const height = parseInt(document.getElementById('mapHeight')?.value || '3000') || 3000;
        const trackWidth = parseInt(document.getElementById('trackWidth')?.value || '120') || 120;

        // μΊ”λ²„μ¤ μ΄κΈ°ν™”
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

        // λ°°κ²½ (μ „μ²΄ μΊ”λ²„μ¤ μ±„μ°κΈ°)
        this.ctx.fillStyle = '#1e4620';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        
        // μ¤κ³Ό μ¤ν”„μ…‹ μ μ©
        this.ctx.save();
        this.ctx.translate(this.offsetX, this.offsetY);
        this.ctx.scale(this.zoom, this.zoom);

        // λ§µ μμ—­ ν‘μ‹ (μ¤κ³Ό κ΄€κ³„μ—†μ΄ κ³ μ •λ λ‘κ») - λ” λμ— λ„κ²
        // μ™Έκ³½ ν…λ‘λ¦¬ (λ‘κΊΌμ΄ μ„ )
        this.ctx.strokeStyle = '#00d4ff'; // λ°μ€ νλ€μƒ‰
        this.ctx.lineWidth = 4; // λ” λ‘κ»κ²
        this.ctx.setLineDash([]); // μ‹¤μ„ 
        this.ctx.strokeRect(0, 0, width, height);
        
        // λ‚΄λ¶€ ν…λ‘λ¦¬ (μ–‡μ€ μ„ μΌλ΅ κ°•μ΅°)
        this.ctx.strokeStyle = '#ffffff'; // ν°μƒ‰
        this.ctx.lineWidth = 1;
        this.ctx.strokeRect(1, 1, width - 2, height - 2);
        
        // μ½”λ„ λ§μ»¤ μ¶”κ°€ (λ” λ…ν™•ν•κ²)
        const cornerSize = 20;
        this.ctx.fillStyle = '#00d4ff';
        // μΆμƒλ‹¨
        this.ctx.fillRect(0, 0, cornerSize, 4);
        this.ctx.fillRect(0, 0, 4, cornerSize);
        // μ°μƒλ‹¨
        this.ctx.fillRect(width - cornerSize, 0, cornerSize, 4);
        this.ctx.fillRect(width - 4, 0, 4, cornerSize);
        // μΆν•λ‹¨
        this.ctx.fillRect(0, height - 4, cornerSize, 4);
        this.ctx.fillRect(0, height - cornerSize, 4, cornerSize);
        // μ°ν•λ‹¨
        this.ctx.fillRect(width - cornerSize, height - 4, cornerSize, 4);
        this.ctx.fillRect(width - 4, height - cornerSize, 4, cornerSize);

        if (this.previewMode && this.points.length >= 2) {
          // λ¶€λ“λ¬μ΄ μ¤‘μ•™μ„  κ²½λ΅ μƒμ„± (κ²μ„κ³Ό λ™μΌν• λ°©μ‹)
          const smoothCenterPath = this.getSmoothPath(this.points, 200);
          
          // νΈλ™μ μ‹¤μ  ν¬κΈ°λ” κ³ μ •λμ–΄μ•Ό ν•λ―€λ΅, μ¤μ„ μ μ©ν•κΈ° μ „μ— lineWidthλ¥Ό μ„¤μ •
          // μ¤μ΄ μ μ©λλ©΄ lineWidthλ„ μ¤μΌ€μΌλ§λλ―€λ΅, μ›ν•λ” ν¬κΈ°λ¥Ό μ¤μΌλ΅ λ‚λ μ„ μ„¤μ •
          // ν•μ§€λ§ νΈλ™ ν¬κΈ°λ¥Ό κ³ μ •ν•λ ¤λ©΄ lineWidthλ¥Ό μ¤κ³Ό κ΄€κ³„μ—†μ΄ κ³ μ •κ°’μΌλ΅ μ„¤μ •
          
          // κ²μ„κ³Ό λ™μΌν• λ λ”λ§ λ°©μ‹: stroke κΈ°λ°
          // νΈλ™ μ™Έκ³½μ„  (μ§„ν• νμƒ‰ ν…λ‘λ¦¬) - νΈλ™ ν¬κΈ° κ³ μ •
          this.ctx.strokeStyle = '#333';
          this.ctx.lineWidth = (trackWidth + 20); // μ¤μΌλ΅ λ‚λ„μ§€ μ•μ
          this.ctx.lineCap = 'round';
          this.ctx.lineJoin = 'round';
          this.drawSmoothPath(this.ctx, smoothCenterPath, this.points.length > 2);
          this.ctx.stroke();
          
          // νΈλ™ λ³Έμ²΄ (μ•„μ¤ν”νΈ) - νΈλ™ ν¬κΈ° κ³ μ •
          const trackGradient = this.ctx.createLinearGradient(0, 0, width, height);
          trackGradient.addColorStop(0, '#3d3d3d');
          trackGradient.addColorStop(0.5, '#4a4a4a');
          trackGradient.addColorStop(1, '#3d3d3d');
          
          this.ctx.strokeStyle = trackGradient;
          this.ctx.lineWidth = trackWidth; // μ¤μΌλ΅ λ‚λ„μ§€ μ•μ
          this.drawSmoothPath(this.ctx, smoothCenterPath, this.points.length > 2);
          this.ctx.stroke();
          
          // νΈλ™ μ¤‘μ•™μ„  (μ μ„ ) - νΈλ™ ν¬κΈ° κ³ μ •
          this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
          this.ctx.lineWidth = 2; // μ¤μΌλ΅ λ‚λ„μ§€ μ•μ
          this.ctx.setLineDash([20, 20]); // μ¤μΌλ΅ λ‚λ„μ§€ μ•μ
          this.drawSmoothPath(this.ctx, smoothCenterPath, this.points.length > 2);
          this.ctx.stroke();
          this.ctx.setLineDash([]);
        } else {
          // νΈμ§‘ λ¨λ“: κ²½λ΅λ§ ν‘μ‹ (μ¤κ³Ό κ΄€κ³„μ—†μ΄ κ³ μ •λ λ‘κ»)
          if (this.points.length >= 2) {
            // νΈμ§‘ λ¨λ“μ—μ„λ„ λ¶€λ“λ¬μ΄ κ²½λ΅ ν‘μ‹
            const smoothPath = this.getSmoothPath(this.points, 200);
            this.ctx.strokeStyle = '#00ff88';
            this.ctx.lineWidth = 2; // μ¤μΌλ΅ λ‚λ„μ§€ μ•μ
            this.ctx.setLineDash([5, 5]); // μ¤μΌλ΅ λ‚λ„μ§€ μ•μ
            this.drawSmoothPath(this.ctx, smoothPath, this.points.length > 2);
            this.ctx.stroke();
            this.ctx.setLineDash([]);
          }
        }

        // ν¬μΈνΈ κ·Έλ¦¬κΈ° (μ¤κ³Ό κ΄€κ³„μ—†μ΄ κ³ μ •λ ν¬κΈ°)
        this.points.forEach((p, i) => {
          const isSelected = i === this.selectedPointIndex;
          const isHovered = i === this.hoveredPointIndex && (this.mode === 'delete' || this.mode === 'move');
          const radius = isSelected ? 8 : (isHovered ? 10 : 6); // νΈλ²„ μ‹ λ” ν¬κ²
          
          // ν¬μΈνΈ νƒ€μ…μ— λ”°λΌ μƒ‰μƒ λ³€κ²½
          const pointColor = p.type === 'curve' ? '#ff6b6b' : '#4ecdc4';
          
          // μ‚­μ /μ΄λ™ λ¨λ“μ—μ„ νΈλ²„ μ‹ κ°•μ΅°
          if (isHovered && this.mode === 'delete') {
            // λΉ¨κ°„μƒ‰ μ™Έκ³½ μ› (μ‚­μ  κ°€λ¥ ν‘μ‹)
            this.ctx.fillStyle = '#ff0000';
            this.ctx.beginPath();
            this.ctx.arc(p.x, p.y, radius + 2, 0, Math.PI * 2);
            this.ctx.fill();
          } else if (isHovered && this.mode === 'move') {
            // μ΄λ™ λ¨λ“μ—μ„ νΈλ²„ μ‹ μ΄λ΅μƒ‰ μ™Έκ³½ μ› (μ΄λ™ κ°€λ¥ ν‘μ‹)
            this.ctx.fillStyle = '#00ff88';
            this.ctx.beginPath();
            this.ctx.arc(p.x, p.y, radius + 2, 0, Math.PI * 2);
            this.ctx.fill();
          }
          
          // μ™Έκ³½ μ›
          this.ctx.fillStyle = isSelected ? '#00ff88' : (isHovered && this.mode === 'delete' ? '#ff6666' : (isHovered && this.mode === 'move' ? '#66ff88' : pointColor));
          this.ctx.beginPath();
          this.ctx.arc(p.x, p.y, radius, 0, Math.PI * 2);
          this.ctx.fill();
          
          // λ‚΄λ¶€ μ›
          this.ctx.fillStyle = isSelected ? '#000' : '#333';
          this.ctx.beginPath();
          this.ctx.arc(p.x, p.y, radius - 2, 0, Math.PI * 2); // μ¤μΌλ΅ λ‚λ„μ§€ μ•μ
          this.ctx.fill();
        });
        
        // μ²΄ν¬ν¬μΈνΈ κ·Έλ¦¬κΈ° (μ¤κ³Ό κ΄€κ³„μ—†μ΄ κ³ μ •λ ν¬κΈ°)
        this.checkpoints.forEach((cp, i) => {
          const isSelected = i === this.selectedCheckpointIndex;
          const isHovered = i === this.hoveredCheckpointIndex && (this.mode === 'deleteCheckpoint' || this.mode === 'moveCheckpoint');
          const radius = isSelected ? 12 : (isHovered ? 14 : 10); // νΈλ²„ μ‹ λ” ν¬κ²
          
          // μ‚­μ  λ¨λ“μ—μ„ νΈλ²„ μ‹ λΉ¨κ°„μƒ‰ κ°•μ΅°
          if (isHovered && this.mode === 'deleteCheckpoint') {
            // λΉ¨κ°„μƒ‰ μ™Έκ³½ μ› (μ‚­μ  κ°€λ¥ ν‘μ‹)
            this.ctx.fillStyle = '#ff0000';
            this.ctx.beginPath();
            this.ctx.arc(cp.x, cp.y, radius + 2, 0, Math.PI * 2);
            this.ctx.fill();
          } else if (isHovered && this.mode === 'moveCheckpoint') {
            // μ΄λ™ λ¨λ“μ—μ„ νΈλ²„ μ‹ μ΄λ΅μƒ‰ μ™Έκ³½ μ› (μ΄λ™ κ°€λ¥ ν‘μ‹)
            this.ctx.fillStyle = '#00ff88';
            this.ctx.beginPath();
            this.ctx.arc(cp.x, cp.y, radius + 2, 0, Math.PI * 2);
            this.ctx.fill();
          }
          
          // μ²΄ν¬ν¬μΈνΈλ” κΈμƒ‰μΌλ΅ ν‘μ‹
          this.ctx.fillStyle = isSelected ? '#00ff88' : (isHovered && this.mode === 'deleteCheckpoint' ? '#ff6666' : (isHovered && this.mode === 'moveCheckpoint' ? '#66ff88' : '#ffd700'));
          this.ctx.beginPath();
          this.ctx.arc(cp.x, cp.y, radius, 0, Math.PI * 2);
          this.ctx.fill();
          
          // λ‚΄λ¶€ μ›
          this.ctx.fillStyle = isSelected ? '#000' : '#333';
          this.ctx.beginPath();
          this.ctx.arc(cp.x, cp.y, radius - 3, 0, Math.PI * 2);
          this.ctx.fill();
          
          // κ°λ„ ν‘μ‹ (ν™”μ‚΄ν‘)
          const arrowLength = 20;
          const arrowX = cp.x + Math.cos(cp.angle) * arrowLength;
          const arrowY = cp.y + Math.sin(cp.angle) * arrowLength;
          
          this.ctx.strokeStyle = isSelected ? '#00ff88' : (isHovered && this.mode === 'deleteCheckpoint' ? '#ff6666' : (isHovered && this.mode === 'moveCheckpoint' ? '#66ff88' : '#ffd700'));
          this.ctx.lineWidth = 2;
          this.ctx.beginPath();
          this.ctx.moveTo(cp.x, cp.y);
          this.ctx.lineTo(arrowX, arrowY);
          this.ctx.stroke();
          
          // ν™”μ‚΄ν‘ λ¨Έλ¦¬
          const arrowAngle1 = cp.angle + Math.PI * 0.8;
          const arrowAngle2 = cp.angle - Math.PI * 0.8;
          const arrowHeadSize = 6;
          this.ctx.beginPath();
          this.ctx.moveTo(arrowX, arrowY);
          this.ctx.lineTo(
            arrowX + Math.cos(arrowAngle1) * arrowHeadSize,
            arrowY + Math.sin(arrowAngle1) * arrowHeadSize
          );
          this.ctx.moveTo(arrowX, arrowY);
          this.ctx.lineTo(
            arrowX + Math.cos(arrowAngle2) * arrowHeadSize,
            arrowY + Math.sin(arrowAngle2) * arrowHeadSize
          );
          this.ctx.stroke();
        });

        // μΆν‘ ν‘μ‹ (μ¤κ³Ό κ΄€κ³„μ—†μ΄ κ³ μ •λ ν¬κΈ°)
        this.points.forEach((p, i) => {
          if (i === this.selectedPointIndex) {
            this.ctx.fillStyle = '#00ff88';
            this.ctx.font = `12px monospace`; // μ¤μΌλ΅ λ‚λ„μ§€ μ•μ
            this.ctx.fillText(`(${p.x}, ${p.y})`, p.x + 12, p.y - 12); // μ¤μΌλ΅ λ‚λ„μ§€ μ•μ
          }
        });
        
        // μ²΄ν¬ν¬μΈνΈ μΆν‘ ν‘μ‹
        this.checkpoints.forEach((cp, i) => {
          if (i === this.selectedCheckpointIndex) {
            this.ctx.fillStyle = '#ffd700';
            this.ctx.font = `12px monospace`;
            const angleDeg = (cp.angle * 180 / Math.PI).toFixed(0);
            this.ctx.fillText(`CP${i + 1}: (${cp.x}, ${cp.y}) ${angleDeg}Β°`, cp.x + 12, cp.y - 12);
          }
        });
        
        // μ—°μ„ κ·Έλ¦¬κΈ° - κ²½λ΅ κΈ°λ° (μ¤κ³Ό κ΄€κ³„μ—†μ΄ κ³ μ •λ ν¬κΈ°)
        this.curbs.forEach((kerb, i) => {
          const isSelected = i === this.selectedKerbIndex;
          const isHovered = i === this.hoveredKerbIndex && (this.mode === 'deleteKerb' || this.mode === 'moveKerb');
          
          // μƒλ΅μ΄ κ²½λ΅ κΈ°λ° μ—°μ„
          if (kerb.centerPath && kerb.centerPath.length >= 2) {
            const kerbWidth = kerb.width || 20;
            const trackSide = kerb.trackSide || 'outer';
            
            // μ—°μ„μ„ κ²½λ΅λ¥Ό λ”°λΌ ν•λ‚μ μ—°μ†λ ν•νƒλ΅ κ·Έλ¦¬κΈ° (νΈλ™ λ°”κΉ¥μ½μΌλ΅λ§)
            this.drawPathBasedKerb(kerb.centerPath, kerbWidth, trackSide);
            
            // νΈλ²„ μ‹μ—λ§ μ „μ²΄ ν…λ‘λ¦¬ ν‘μ‹
            if (isHovered) {
              this.ctx.save();
              let strokeColor = '#00ff88'; // κΈ°λ³Έ μƒ‰μƒ (μ΄λ΅μƒ‰)
              if (this.mode === 'deleteKerb') {
                strokeColor = '#ff0000'; // μ‚­μ  λ¨λ“ (λΉ¨κ°„μƒ‰)
              }
              this.ctx.strokeStyle = strokeColor;
              this.ctx.lineWidth = 3;
              
              // λ„μ  κΈΈμ΄ ν…μ΄λΈ” κ³„μ‚°
              const cumulative = [0];
              for (let i = 1; i < kerb.centerPath.length; i++) {
                const p1 = kerb.centerPath[i - 1];
                const p2 = kerb.centerPath[i];
                const dx = p2.x - p1.x;
                const dy = p2.y - p1.y;
                cumulative.push(cumulative[i - 1] + Math.hypot(dx, dy));
              }
              const totalLength = cumulative[cumulative.length - 1];
              
              // κ²½λ΅μƒμ νΉμ • κ±°λ¦¬μ—μ„ μ„μΉμ™€ λ²•μ„ μ„ κ³„μ‚°ν•λ” ν•¨μ
              const getPointAt = (dist) => {
                const clamped = Math.min(Math.max(dist, 0), totalLength);
                let idx = cumulative.findIndex((len) => len >= clamped);
                if (idx === -1) idx = cumulative.length - 1;
                if (idx === 0) idx = 1;
                
                const p1 = kerb.centerPath[idx - 1];
                const p2 = kerb.centerPath[idx];
                const segLen = cumulative[idx] - cumulative[idx - 1] || 1;
                const t = (clamped - cumulative[idx - 1]) / segLen;
                
                const x = p1.x + (p2.x - p1.x) * t;
                const y = p1.y + (p2.y - p1.y) * t;
                
                const dx = p2.x - p1.x;
                const dy = p2.y - p1.y;
                const len = Math.hypot(dx, dy) || 1;
                
                const nx = -dy / len;
                const ny = dx / len;
                const sign = trackSide === 'inner' ? 1 : -1;
                
                return {
                  track: { x, y },
                  outer: { x: x + nx * kerbWidth * sign, y: y + ny * kerbWidth * sign }
                };
              };
              
              const strokeStep = 0.5; // λ¶€λ“λ¬μ΄ κ³΅μ„ μ„ μ„ν• κ°„κ²©
              
              // νΈλ™ κ²½κ³„μ„  (μ™„μ „ν λ¶€λ“λ¬μ΄ κ³΅μ„ )
              this.ctx.beginPath();
              const first = getPointAt(0);
              this.ctx.moveTo(first.track.x, first.track.y);
              for (let d = strokeStep; d <= totalLength; d += strokeStep) {
                const pt = getPointAt(Math.min(d, totalLength));
                this.ctx.lineTo(pt.track.x, pt.track.y);
              }
              const lastTrack = getPointAt(totalLength);
              this.ctx.lineTo(lastTrack.track.x, lastTrack.track.y);
              this.ctx.stroke();
              
              // λ°”κΉ¥μ½ κ²½κ³„μ„  (μ™„μ „ν λ¶€λ“λ¬μ΄ κ³΅μ„ )
              this.ctx.beginPath();
              this.ctx.moveTo(first.outer.x, first.outer.y);
              for (let d = strokeStep; d <= totalLength; d += strokeStep) {
                const pt = getPointAt(Math.min(d, totalLength));
                this.ctx.lineTo(pt.outer.x, pt.outer.y);
              }
              const lastOuter = getPointAt(totalLength);
              this.ctx.lineTo(lastOuter.outer.x, lastOuter.outer.y);
              this.ctx.stroke();
              
              // μ–‘ λ μ—°κ²°μ„ 
              this.ctx.beginPath();
              this.ctx.moveTo(first.track.x, first.track.y);
              this.ctx.lineTo(first.outer.x, first.outer.y);
              this.ctx.moveTo(lastTrack.track.x, lastTrack.track.y);
              this.ctx.lineTo(lastOuter.outer.x, lastOuter.outer.y);
              this.ctx.stroke();
              
              this.ctx.restore();
            }
          }
          // κµ¬ν• ν¬λ§· (ν•μ„ νΈν™μ„±)
          else if (kerb.x !== undefined && kerb.y !== undefined) {
            const width = kerb.width || 200;
            const height = kerb.height || 20;
            
            // νΈλ²„ μ‹μ—λ§ μ™Έκ³½μ„  ν‘μ‹
            if (isHovered) {
              let strokeColor = '#00ff88'; // κΈ°λ³Έ μƒ‰μƒ (μ΄λ΅μƒ‰)
              if (this.mode === 'deleteKerb') {
                strokeColor = '#ff0000'; // μ‚­μ  λ¨λ“ (λΉ¨κ°„μƒ‰)
              }
              this.ctx.strokeStyle = strokeColor;
              this.ctx.lineWidth = 3;
              this.ctx.save();
              this.ctx.translate(kerb.x, kerb.y);
              this.ctx.rotate(kerb.angle || 0);
              this.ctx.strokeRect(-width / 2 - 2, -height / 2 - 2, width + 4, height + 4);
              this.ctx.restore();
            }
            
            // μ§μ„  μ—°μ„ κ·Έλ¦¬κΈ°
            this.ctx.save();
            this.ctx.globalCompositeOperation = 'source-over';
            this.ctx.translate(kerb.x, kerb.y);
            this.ctx.rotate(kerb.angle || 0);
            
            const blockWidth = 20;
            const blockCount = Math.floor(width / blockWidth);
            for (let j = 0; j < blockCount; j++) {
              const isRed = j % 2 === 0;
              const color = isRed ? '#ff0000' : '#ffffff';
              this.ctx.fillStyle = color;
              this.ctx.fillRect(-width / 2 + j * blockWidth, -height / 2, blockWidth, height);
            }
            
            // κ²€μ€μƒ‰ ν…λ‘λ¦¬ μ κ±°λ¨
            this.ctx.restore();
          }
        });
        
// μ‹μ‘μ„  κ·Έλ¦¬κΈ° (μ²΄μ»¤ν”λκ·Έ ν¨ν„΄ - νΈλ™ μ „μ²΄)
if (this.startLine && (this.startLine.x !== 0 || this.startLine.y !== 0)) {
  const isHovered =
    this.hoveredStartLine &&
    (this.mode === 'deleteStartLine' || this.mode === 'moveStartLine');

  const trackWidth =
    parseInt(document.getElementById('trackWidth')?.value || '120') || 120;
  const halfTrackWidth = trackWidth / 2;

  const perpAngle = this.startLine.angle + Math.PI / 2;
  const cos = Math.cos(perpAngle);
  const sin = Math.sin(perpAngle);

  // μ²΄μ»¤ ν”λκ·Έ ν¬κΈ° κ³„μ‚° (νΈλ²„ μ™Έκ³½μ„ κ³Ό μ²΄μ»¤ ν”λκ·Έ λ¨λ‘μ— μ‚¬μ©)
  const thickness = 24; // μ‹μ‘μ„  λ‘κ» (μ²΄μ»¤ ν”λκ·Έ κΈΈμ΄)
  const blockSize = 14; // μ²΄μ»¤ λΈ”λ΅ ν¬κΈ° (λ” μ‘κ² ν•μ—¬ μ •κµν• μ΅°μ • κ°€λ¥)
  // νΈλ™ μ „μ²΄ λ„λΉ„λ³΄λ‹¤ μ΅°κΈ λ” κΈΈκ² (κ°€λ΅ κΈΈμ΄ ν™•μ¥)
  const extendedWidth = trackWidth * 0.98; // νΈλ™ λ„λΉ„μ 104%
  const blockCount = Math.round(extendedWidth / blockSize, 5);
  const actualWidth = blockCount * blockSize; // μ‹¤μ  κ·Έλ ¤μ§ λ„λΉ„ (blockSize λ‹¨μ„λ΅ μ •κµν•κ² μ΅°μ •)
  const halfActualWidth = actualWidth / 2;

  // === νΈλ²„ μ™Έκ³½μ„  === (μ²΄μ»¤ ν”λκ·Έ μ‚¬κ°ν• μμ—­)
  if (isHovered) {
    this.ctx.save();
    this.ctx.translate(this.startLine.x, this.startLine.y);
    this.ctx.rotate(this.startLine.angle + Math.PI / 2);
    
    this.ctx.strokeStyle =
      this.mode === 'deleteStartLine' ? '#ff0000' : '#00ff88';
    this.ctx.lineWidth = 4;
    this.ctx.setLineDash([]);
    this.ctx.beginPath();
    // μ²΄μ»¤ ν”λκ·Έμ μ‚¬κ°ν• μ™Έκ³½μ„  κ·Έλ¦¬κΈ°
    this.ctx.rect(-halfActualWidth, -thickness / 2, actualWidth, thickness);
    this.ctx.stroke();
    
    this.ctx.restore();
  }

  // === μ²΄μ»¤ν”λκ·Έ === (νΈλ™ μ „μ²΄, μ‹μ‘μ„  μ¤‘μ‹¬μ΄ νΈλ™ μ¤‘μ‹¬)
  this.ctx.save();
  this.ctx.translate(this.startLine.x, this.startLine.y);
  this.ctx.rotate(this.startLine.angle + Math.PI / 2);

  const startX = -halfActualWidth; // μ¤‘μ‹¬μ—μ„ μ‹μ‘ν•μ—¬ μ–‘μ½μΌλ΅ κ·Έλ¦¬κΈ°
  
  // 2ν–‰μΌλ΅ κ·Έλ¦¬κΈ°
  const rowHeight = thickness / 2;
  
  // μ¤‘μ‹¬μ—μ„ μ–‘μ½μΌλ΅ νΈλ™ μ „μ²΄ ν­ κ·Έλ¦¬κΈ°
  for (let row = 0; row < 2; row++) {
    for (let i = 0; i < blockCount; i++) {
      const x = startX + i * blockSize;
      const y = -thickness / 2 + row * rowHeight;
      // ν–‰κ³Ό μ—΄μ ν•©μ΄ μ§μλ©΄ κ²€μ€μƒ‰, ν™€μλ©΄ ν°μƒ‰
      const isBlack = (i + row) % 2 === 0;
      this.ctx.fillStyle = isBlack ? '#000' : '#fff';
      this.ctx.fillRect(x, y, blockSize, rowHeight);
    }
  }

  this.ctx.restore();
}

        
        // μ¶λ° μ„μΉ κ·Έλ¦¬κΈ° (μ¤κ³Ό κ΄€κ³„μ—†μ΄ κ³ μ •λ ν¬κΈ°) - μ²΄ν¬ν¬μΈνΈμ™€ λ™μΌν• μ¤νƒ€μΌ
        this.spawnPositions.forEach((spawn, i) => {
          const isSelected = i === this.selectedSpawnIndex;
          const isHovered = i === this.hoveredSpawnIndex && (this.mode === 'deleteSpawn' || this.mode === 'moveSpawn');
          const radius = isSelected ? 12 : (isHovered ? 14 : 10); // μ²΄ν¬ν¬μΈνΈμ™€ λ™μΌν• ν¬κΈ°
          
          // μ‚­μ  λ¨λ“μ—μ„ νΈλ²„ μ‹ λΉ¨κ°„μƒ‰ κ°•μ΅°
          if (isHovered && this.mode === 'deleteSpawn') {
            // λΉ¨κ°„μƒ‰ μ™Έκ³½ μ› (μ‚­μ  κ°€λ¥ ν‘μ‹)
            this.ctx.fillStyle = '#ff0000';
            this.ctx.beginPath();
            this.ctx.arc(spawn.x, spawn.y, radius + 2, 0, Math.PI * 2);
            this.ctx.fill();
          } else if (isHovered && this.mode === 'moveSpawn') {
            // μ΄λ™ λ¨λ“μ—μ„ νΈλ²„ μ‹ μ΄λ΅μƒ‰ μ™Έκ³½ μ› (μ΄λ™ κ°€λ¥ ν‘μ‹)
            this.ctx.fillStyle = '#00ff88';
            this.ctx.beginPath();
            this.ctx.arc(spawn.x, spawn.y, radius + 2, 0, Math.PI * 2);
            this.ctx.fill();
          }
          
          // μ¶λ° μ„μΉλ” νλ€μƒ‰μΌλ΅ ν‘μ‹
          this.ctx.fillStyle = isSelected ? '#00ff88' : (isHovered && this.mode === 'deleteSpawn' ? '#ff6666' : (isHovered && this.mode === 'moveSpawn' ? '#66ff88' : '#4a9eff'));
          this.ctx.beginPath();
          this.ctx.arc(spawn.x, spawn.y, radius, 0, Math.PI * 2);
          this.ctx.fill();
          
          // λ‚΄λ¶€ μ› (μ²΄ν¬ν¬μΈνΈμ™€ λ™μΌν•κ² μ–‡μ€ κ°€μ¥μλ¦¬)
          this.ctx.fillStyle = isSelected ? '#000' : '#333';
          this.ctx.beginPath();
          this.ctx.arc(spawn.x, spawn.y, radius - 3, 0, Math.PI * 2);
          this.ctx.fill();
          
          // μ¶λ° λ°©ν–¥ ν‘μ‹ (ν™”μ‚΄ν‘)
          const arrowLength = 20;
          const arrowX = spawn.x + Math.cos(this.spawnAngle) * arrowLength;
          const arrowY = spawn.y + Math.sin(this.spawnAngle) * arrowLength;
          
          this.ctx.strokeStyle = isSelected ? '#00ff88' : (isHovered && this.mode === 'deleteSpawn' ? '#ff6666' : (isHovered && this.mode === 'moveSpawn' ? '#66ff88' : '#4a9eff'));
          this.ctx.lineWidth = 2;
          this.ctx.beginPath();
          this.ctx.moveTo(spawn.x, spawn.y);
          this.ctx.lineTo(arrowX, arrowY);
          this.ctx.stroke();
          
          // ν™”μ‚΄ν‘ λ¨Έλ¦¬
          const arrowAngle1 = this.spawnAngle + Math.PI * 0.8;
          const arrowAngle2 = this.spawnAngle - Math.PI * 0.8;
          const arrowHeadSize = 6;
          this.ctx.beginPath();
          this.ctx.moveTo(arrowX, arrowY);
          this.ctx.lineTo(
            arrowX + Math.cos(arrowAngle1) * arrowHeadSize,
            arrowY + Math.sin(arrowAngle1) * arrowHeadSize
          );
          this.ctx.moveTo(arrowX, arrowY);
          this.ctx.lineTo(
            arrowX + Math.cos(arrowAngle2) * arrowHeadSize,
            arrowY + Math.sin(arrowAngle2) * arrowHeadSize
          );
          this.ctx.stroke();
        });
        
        // μ¶λ° μ„μΉ μΆν‘ ν‘μ‹
        this.spawnPositions.forEach((spawn, i) => {
          if (i === this.selectedSpawnIndex) {
            this.ctx.fillStyle = '#4a9eff';
            this.ctx.font = `12px monospace`;
            this.ctx.fillText(`μ¶λ°${i + 1}: (${Math.round(spawn.x)}, ${Math.round(spawn.y)})`, spawn.x + 12, spawn.y - 12);
          }
        });
        
        // μ—°μ„ μ •λ³΄ ν‘μ‹
        this.curbs.forEach((kerb, i) => {
          if (i === this.selectedKerbIndex) {
            this.ctx.fillStyle = '#ff9500';
            this.ctx.font = `12px monospace`;
            let displayText = `μ—°μ„${i + 1}`;
            let displayX = 0, displayY = 0;
            
            if (kerb.centerPath && kerb.centerPath.length > 0) {
              // κ²½λ΅ κΈ°λ°: μ¤‘μ‹¬μ  ν‘μ‹
              const midIdx = Math.floor(kerb.centerPath.length / 2);
              displayX = kerb.centerPath[midIdx].x;
              displayY = kerb.centerPath[midIdx].y;
              displayText += `: ${kerb.length || 300}px`;
            } else if (kerb.x !== undefined) {
              // κµ¬ν• ν¬λ§·
              displayX = kerb.x;
              displayY = kerb.y;
              const angleDeg = ((kerb.angle || 0) * 180 / Math.PI).toFixed(0);
              displayText += `: (${kerb.x}, ${kerb.y}) ${angleDeg}Β° ${kerb.width || 200}px`;
            }
            
            this.ctx.fillText(displayText, displayX + 12, displayY - 12);
          }
        });
        
        this.ctx.restore();
        
        // λ―Έλ‹λ§µ λ λ”λ§
        this.renderMinimap();
      }

      updateCodeOutput() {
        window.TrackEditorCodeGenerator.updateCodeOutput(this);
      }

      copyCode() {
        window.TrackEditorCodeGenerator.copyCode();
      }

      newTrack() {
        window.TrackEditorTrackManager.newTrack(this);
      }
      
      clearTrack() {
        window.TrackEditorTrackManager.clearTrack(this);
      }

      async loadTrack() {
        await window.TrackEditorTrackManager.loadTrack(this);
      }

      updateStatus() {
        window.TrackEditorUIManager.updateStatus(this);
      }
    }

    // νΈμ§‘κΈ° μ΄κΈ°ν™”
    let editor;
    
    // νΈλ™ κ΄€λ ¨ ν•¨μκ°€ ν•„μ”ν•λ©΄ λ΅λ“
    function getTrack(trackId) {
      // μ „μ—­ TRACKS κ°μ²΄μ—μ„ νΈλ™ κ°€μ Έμ¤κΈ°
      if (typeof window.TRACKS !== 'undefined' && window.TRACKS[trackId]) {
        return window.TRACKS[trackId].data;
      }
      return null;
    }
    
    window.addEventListener('load', async () => {
      // νΈλ™ νμΌμ„ λ¨Όμ € λ΅λ“
      const loadScript = (src) => {
        return new Promise((resolve, reject) => {
          // μ΄λ―Έ λ΅λ“λ μ¤ν¬λ¦½νΈμΈμ§€ ν™•μΈ
          const existingScript = document.querySelector(`script[src="${src}"]`);
          if (existingScript) {
            resolve();
            return;
          }
          
          const script = document.createElement('script');
          script.src = src;
          script.onload = resolve;
          script.onerror = reject;
          document.body.appendChild(script);
        });
      };
      
      // track.jsμ™€ νΈλ™ νμΌλ“¤μ„ λ΅λ“
      try {
        await Promise.all([
          loadScript('/js/track.js'),
          loadScript('/js/tracks/basic-circuit.js'),
          loadScript('/js/tracks/monza.js')
        ]);
        // registerTrack νΈμ¶ μ™„λ£ λ€κΈ°
        await new Promise(resolve => setTimeout(resolve, 200));
        console.log('νΈλ™ νμΌλ“¤μ΄ λ΅λ“λμ—μµλ‹λ‹¤.', window.TRACKS);
      } catch (error) {
        console.warn('νΈλ™ νμΌ λ΅λ“ μ‹¤ν¨ (νΈλ™ λ΅λ“ κΈ°λ¥ μ‚¬μ© λ¶κ°€):', error);
      }
      
      // νΈμ§‘κΈ° μ΄κΈ°ν™”
      editor = new TrackEditor();
    });
  </script>
</body>
</html>

