<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>íŠ¸ë™ í¸ì§‘ê¸° - ê°œë°œìš©</title>
  <link rel="stylesheet" href="/css/track-editor.css">
  <!-- íŠ¸ë™ íŒŒì¼ ë¯¸ë¦¬ ë¡œë“œ -->
  <script src="/js/track.js"></script>
  <script src="/js/tracks/basic-circuit.js"></script>
  <script src="/js/tracks/monza.js"></script>
  <!-- TrackEditor ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜ -->
  <script src="/js/track-editor/utils.js"></script>
  <!-- TrackEditor ë Œë”ë§ í•¨ìˆ˜ -->
  <script src="/js/track-editor/renderer.js"></script>
  <!-- TrackEditor í¬ì¸íŠ¸ ê´€ë¦¬ í•¨ìˆ˜ -->
  <script src="/js/track-editor/point-manager.js"></script>
  <!-- TrackEditor ì²´í¬í¬ì¸íŠ¸ ê´€ë¦¬ í•¨ìˆ˜ -->
  <script src="/js/track-editor/checkpoint-manager.js"></script>
  <!-- TrackEditor ì—°ì„ ê´€ë¦¬ í•¨ìˆ˜ -->
  <script src="/js/track-editor/kerb-manager.js"></script>
  <!-- TrackEditor ì¶œë°œ ìœ„ì¹˜ ê´€ë¦¬ í•¨ìˆ˜ -->
  <script src="/js/track-editor/spawn-manager.js"></script>
  <!-- TrackEditor ì½”ë“œ ìƒì„± í•¨ìˆ˜ -->
  <script src="/js/track-editor/code-generator.js"></script>
  <!-- TrackEditor íŠ¸ë™ ê´€ë¦¬ í•¨ìˆ˜ -->
  <script src="/js/track-editor/track-manager.js"></script>
  <!-- TrackEditor ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ í•¨ìˆ˜ -->
  <script src="/js/track-editor/event-handler.js"></script>
  <!-- TrackEditor UI ê´€ë¦¬ í•¨ìˆ˜ -->
  <script src="/js/track-editor/ui-manager.js"></script>
</head>
<body>
    <div class="header">
      <h1>ğŸ íŠ¸ë™ í¸ì§‘ê¸° (ê°œë°œìš©)</h1>
      <div class="controls">
        <button id="backToGameBtn" onclick="window.location.href='/'">â† ê²Œì„ìœ¼ë¡œ</button>
        <button id="newTrackBtn" style="background: #00d4ff; color: #000;">ìƒˆ íŠ¸ë™</button>
        <button id="loadTrackBtn">íŠ¸ë™ ë¡œë“œ</button>
        <button id="saveTrackBtn">ì½”ë“œ ë³µì‚¬</button>
        <button id="clearBtn" class="danger">ì´ˆê¸°í™”</button>
      </div>
    </div>

  <div class="main-container">
    <div class="canvas-container">
      <div class="toolbar">
        <button id="addModeBtn" class="active">â• í¬ì¸íŠ¸ ì¶”ê°€</button>
        <button id="moveModeBtn">â†”ï¸ í¬ì¸íŠ¸ ì´ë™</button>
        <button id="deleteModeBtn">âœ–ï¸ í¬ì¸íŠ¸ ì‚­ì œ</button>
        <button id="addCheckpointBtn">ğŸ ì²´í¬í¬ì¸íŠ¸ ì¶”ê°€</button>
        <button id="moveCheckpointBtn">â†”ï¸ ì²´í¬í¬ì¸íŠ¸ ì´ë™</button>
        <button id="deleteCheckpointBtn">âœ–ï¸ ì²´í¬í¬ì¸íŠ¸ ì‚­ì œ</button>
        <button id="addKerbBtn">ğŸŸ¦ ì—°ì„ ì¶”ê°€</button>
        <button id="moveKerbBtn">â†”ï¸ ì—°ì„ ì´ë™</button>
        <button id="deleteKerbBtn">âœ–ï¸ ì—°ì„ ì‚­ì œ</button>
        <button id="addSpawnBtn">ğŸš— ì¶œë°œ ìœ„ì¹˜ ì¶”ê°€</button>
        <button id="moveSpawnBtn">â†”ï¸ ì¶œë°œ ìœ„ì¹˜ ì´ë™</button>
        <button id="deleteSpawnBtn">âœ–ï¸ ì¶œë°œ ìœ„ì¹˜ ì‚­ì œ</button>
        <button id="setStartLineBtn">ğŸ ì‹œì‘ì„  ì„¤ì •</button>
        <button id="moveStartLineBtn">â†”ï¸ ì‹œì‘ì„  ì´ë™</button>
        <button id="deleteStartLineBtn">âœ–ï¸ ì‹œì‘ì„  ì‚­ì œ</button>
        <button id="previewBtn">ğŸ‘ï¸ ë¯¸ë¦¬ë³´ê¸°</button>
      </div>
      <canvas id="editorCanvas" width="1200" height="800"></canvas>
      <div class="status" id="status">ëª¨ë“œ: í¬ì¸íŠ¸ ì¶”ê°€ | í¬ì¸íŠ¸: 0ê°œ</div>
      <div class="minimap">
        <canvas id="minimapCanvas"></canvas>
      </div>
      <div class="zoom-controls">
        <button id="zoomInBtn" title="í™•ëŒ€">+</button>
        <button id="zoomOutBtn" title="ì¶•ì†Œ">-</button>
        <button id="resetViewBtn" title="ë·° ë¦¬ì…‹">âŒ‚</button>
      </div>
    </div>

    <div class="sidebar">
      <div class="section">
        <h3>íŠ¸ë™ ì •ë³´</h3>
        <div class="input-group">
          <label>íŠ¸ë™ ì´ë¦„</label>
          <input type="text" id="trackName" value="ìƒˆ íŠ¸ë™">
        </div>
        <div class="input-group">
          <label>íŠ¸ë™ ID</label>
          <input type="text" id="trackId" value="new-track">
        </div>
        <div class="input-group">
          <label>ë§µ ë„ˆë¹„</label>
          <input type="number" id="mapWidth" value="4500">
        </div>
        <div class="input-group">
          <label>ë§µ ë†’ì´</label>
          <input type="number" id="mapHeight" value="3000">
        </div>
        <div class="input-group">
          <label>íŠ¸ë™ í­</label>
          <input type="number" id="trackWidth" value="120" readonly>
        </div>
      </div>

      <div class="section">
        <h3>í¬ì¸íŠ¸ ëª©ë¡</h3>
        <div class="point-list" id="pointList">
          <div style="color: #666; font-size: 11px; text-align: center; padding: 20px;">
            í¬ì¸íŠ¸ë¥¼ ì¶”ê°€í•˜ë ¤ë©´ ìº”ë²„ìŠ¤ë¥¼ í´ë¦­í•˜ì„¸ìš”
          </div>
        </div>
      </div>

      <div class="section">
        <h3>ì„ íƒëœ í¬ì¸íŠ¸</h3>
        <div id="selectedPointInfo" style="color: #666; font-size: 11px;">
          í¬ì¸íŠ¸ë¥¼ ì„ íƒí•˜ì„¸ìš”
        </div>
        <div class="input-group" id="pointEditGroup" style="display: none; margin-top: 10px;">
          <label>X ì¢Œí‘œ</label>
          <input type="number" id="pointX" step="1">
        </div>
        <div class="input-group" id="pointEditGroup2" style="display: none;">
          <label>Y ì¢Œí‘œ</label>
          <input type="number" id="pointY" step="1">
        </div>
        <div class="input-group" id="pointEditGroup3" style="display: none; margin-top: 10px;">
          <label>í¬ì¸íŠ¸ íƒ€ì…</label>
          <div style="display: flex; gap: 5px;">
            <button id="setStraightBtn" style="flex: 1; font-size: 11px;">ì§ì„ </button>
            <button id="setCurveBtn" style="flex: 1; font-size: 11px;">ê³¡ì„ </button>
          </div>
        </div>
      </div>

      <div class="section">
        <h3>ì²´í¬í¬ì¸íŠ¸ ëª©ë¡</h3>
        <div class="point-list" id="checkpointList">
          <div style="color: #666; font-size: 11px; text-align: center; padding: 20px;">
            ì²´í¬í¬ì¸íŠ¸ë¥¼ ì¶”ê°€í•˜ë ¤ë©´ ì²´í¬í¬ì¸íŠ¸ ì¶”ê°€ ëª¨ë“œë¥¼ ì„ íƒí•˜ì„¸ìš”
          </div>
        </div>
      </div>

      <div class="section">
        <h3>ì„ íƒëœ ì²´í¬í¬ì¸íŠ¸</h3>
        <div id="selectedCheckpointInfo" style="color: #666; font-size: 11px;">
          ì²´í¬í¬ì¸íŠ¸ë¥¼ ì„ íƒí•˜ì„¸ìš”
        </div>
        <div class="input-group" id="checkpointEditGroup" style="display: none; margin-top: 10px;">
          <label>X ì¢Œí‘œ</label>
          <input type="number" id="checkpointX" step="1">
        </div>
        <div class="input-group" id="checkpointEditGroup2" style="display: none;">
          <label>Y ì¢Œí‘œ</label>
          <input type="number" id="checkpointY" step="1">
        </div>
        <div class="input-group" id="checkpointEditGroup3" style="display: none;">
          <label>ê°ë„ (ë¼ë””ì•ˆ)</label>
          <input type="number" id="checkpointAngle" step="0.1">
        </div>
        <div class="input-group" id="checkpointEditGroup4" style="display: none; margin-top: 5px;">
          <label>ê°ë„ (ë„)</label>
          <input type="number" id="checkpointAngleDeg" step="1" min="0" max="360">
        </div>
      </div>

      <div class="section">
        <h3>ì¶œë°œ ìœ„ì¹˜ ëª©ë¡</h3>
        <div class="point-list" id="spawnList">
          <div style="color: #666; font-size: 11px; text-align: center; padding: 20px;">
            ì¶œë°œ ìœ„ì¹˜ë¥¼ ì¶”ê°€í•˜ë ¤ë©´ ì¶œë°œ ìœ„ì¹˜ ì¶”ê°€ ëª¨ë“œë¥¼ ì„ íƒí•˜ì„¸ìš”
          </div>
        </div>
      </div>

      <div class="section">
        <h3>ì„ íƒëœ ì¶œë°œ ìœ„ì¹˜</h3>
        <div id="selectedSpawnInfo" style="color: #666; font-size: 11px;">
          ì¶œë°œ ìœ„ì¹˜ë¥¼ ì„ íƒí•˜ì„¸ìš”
        </div>
        <div class="input-group" id="spawnEditGroup" style="display: none; margin-top: 10px;">
          <label>X ì¢Œí‘œ</label>
          <input type="number" id="spawnX" step="1">
        </div>
        <div class="input-group" id="spawnEditGroup2" style="display: none;">
          <label>Y ì¢Œí‘œ</label>
          <input type="number" id="spawnY" step="1">
        </div>
      </div>

      <div class="section">
        <h3>ì¶œë°œ ë°©í–¥ ì„¤ì •</h3>
        <div class="input-group">
          <label>ì¶œë°œ ë°©í–¥ (ë¼ë””ì•ˆ)</label>
          <input type="number" id="spawnAngle" step="0.1" value="0">
        </div>
        <div class="input-group" style="margin-top: 5px;">
          <label>ì¶œë°œ ë°©í–¥ (ë„)</label>
          <input type="number" id="spawnAngleDeg" step="1" min="0" max="360" value="0">
        </div>
      </div>

      <div class="section">
        <h3>ì‹œì‘ì„  ì„¤ì •</h3>
        <div class="input-group">
          <label>X ì¢Œí‘œ</label>
          <input type="number" id="startLineX" step="1">
        </div>
        <div class="input-group">
          <label>Y ì¢Œí‘œ</label>
          <input type="number" id="startLineY" step="1">
        </div>
        <div class="input-group">
          <label>ê°ë„ (ë¼ë””ì•ˆ)</label>
          <input type="number" id="startLineAngle" step="0.1" value="0">
        </div>
        <div class="input-group" style="margin-top: 5px;">
          <label>ê°ë„ (ë„)</label>
          <input type="number" id="startLineAngleDeg" step="1" min="0" max="360" value="0">
        </div>
      </div>

      <div class="section">
        <h3>ìƒì„±ëœ ì½”ë“œ</h3>
        <button id="copyCodeBtn" style="width: 100%; margin-bottom: 10px;">ì½”ë“œ ë³µì‚¬</button>
        <textarea id="codeOutput" class="code-output" readonly></textarea>
      </div>

      <div class="info">
        <strong>ì‚¬ìš©ë²•:</strong><br>
        â€¢ í¬ì¸íŠ¸ ì¶”ê°€ ëª¨ë“œ: ìº”ë²„ìŠ¤ í´ë¦­ìœ¼ë¡œ í¬ì¸íŠ¸ ì¶”ê°€<br>
        â€¢ í¬ì¸íŠ¸ ì´ë™ ëª¨ë“œ: í¬ì¸íŠ¸ë¥¼ ë“œë˜ê·¸í•˜ì—¬ ì´ë™<br>
        â€¢ í¬ì¸íŠ¸ ì‚­ì œ ëª¨ë“œ: í¬ì¸íŠ¸ í´ë¦­ìœ¼ë¡œ ì‚­ì œ<br>
        â€¢ ë¯¸ë¦¬ë³´ê¸°: íŠ¸ë™ ë Œë”ë§ ë¯¸ë¦¬ë³´ê¸°
      </div>
    </div>
  </div>

  <script>
    class TrackEditor {
      constructor() {
        this.canvas = document.getElementById('editorCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.minimapCanvas = document.getElementById('minimapCanvas');
        this.minimapCtx = this.minimapCanvas.getContext('2d');
        this.points = [];
        this.checkpoints = []; // ì²´í¬í¬ì¸íŠ¸ ë°°ì—´
        this.curbs = []; // ì—°ì„ ë°°ì—´ { x, y, angle, length }
        this.spawnPositions = []; // ì¶œë°œ ìœ„ì¹˜ ë°°ì—´ { x, y }
        this.spawnAngle = 0; // ì¶œë°œ ë°©í–¥ (ë¼ë””ì•ˆ)
        this.startLine = { x: 0, y: 0, angle: 0 }; // ì‹œì‘ì„  { x, y, angle }
        this.selectedPointIndex = -1;
        this.selectedCheckpointIndex = -1; // ì„ íƒëœ ì²´í¬í¬ì¸íŠ¸ ì¸ë±ìŠ¤
        this.selectedKerbIndex = -1; // ì„ íƒëœ ì—°ì„ ì¸ë±ìŠ¤
        this.selectedSpawnIndex = -1; // ì„ íƒëœ ì¶œë°œ ìœ„ì¹˜ ì¸ë±ìŠ¤
        this.draggingPointIndex = -1;
        this.draggingCheckpointIndex = -1; // ë“œë˜ê·¸ ì¤‘ì¸ ì²´í¬í¬ì¸íŠ¸ ì¸ë±ìŠ¤
        this.draggingKerbIndex = -1; // ë“œë˜ê·¸ ì¤‘ì¸ ì—°ì„ ì¸ë±ìŠ¤
        this.draggingSpawnIndex = -1; // ë“œë˜ê·¸ ì¤‘ì¸ ì¶œë°œ ìœ„ì¹˜ ì¸ë±ìŠ¤
        this.draggingStartLine = false; // ë“œë˜ê·¸ ì¤‘ì¸ ì‹œì‘ì„ 
        this.hoveredPointIndex = -1; // í˜¸ë²„ ì¤‘ì¸ í¬ì¸íŠ¸ ì¸ë±ìŠ¤
        this.hoveredCheckpointIndex = -1; // í˜¸ë²„ ì¤‘ì¸ ì²´í¬í¬ì¸íŠ¸ ì¸ë±ìŠ¤
        this.hoveredKerbIndex = -1; // í˜¸ë²„ ì¤‘ì¸ ì—°ì„ ì¸ë±ìŠ¤
        this.hoveredSpawnIndex = -1; // í˜¸ë²„ ì¤‘ì¸ ì¶œë°œ ìœ„ì¹˜ ì¸ë±ìŠ¤
        this.hoveredStartLine = false; // í˜¸ë²„ ì¤‘ì¸ ì‹œì‘ì„ 
        this.mode = 'add'; // 'add', 'move', 'delete', 'addCheckpoint', 'moveCheckpoint', 'deleteCheckpoint', 'addKerb', 'moveKerb', 'deleteKerb', 'addSpawn', 'moveSpawn', 'deleteSpawn', 'setStartLine', 'moveStartLine', 'deleteStartLine'
        this.zoom = 1;
        this.offsetX = 0;
        this.offsetY = 0;
        this.previewMode = false;
        
        // íŒ¬(ì´ë™) ê´€ë ¨ ë³€ìˆ˜
        this.isPanning = false;
        this.panStartX = 0;
        this.panStartY = 0;
        this.panStartOffsetX = 0;
        this.panStartOffsetY = 0;
        
        // ë¯¸ë‹ˆë§µ ë“œë˜ê·¸ ê´€ë ¨ ë³€ìˆ˜
        this.isMinimapDragging = false;
        this.minimapDragStartX = 0;
        this.minimapDragStartY = 0;
        
        // ë Œë”ë§ ìµœì í™”ë¥¼ ìœ„í•œ ë³€ìˆ˜
        this.animationFrameId = null;
        this.pendingRender = false;
        
        // ì—°ì„ ì´ë™ ì„±ëŠ¥ ìµœì í™”ë¥¼ ìœ„í•œ ìºì‹œ
        this._smoothPathCache = null;
        this._trackBoundsCache = null;
        this._pointsHash = null; // í¬ì¸íŠ¸ ë°°ì—´ í•´ì‹œ (ìºì‹œ ë¬´íš¨í™”ìš©)

        // ìº”ë²„ìŠ¤ í¬ê¸° ì¡°ì •
        this.resizeCanvas();
        window.addEventListener('resize', () => this.resizeCanvas());

        // localStorageì—ì„œ ë°ì´í„° ë³µì›
        this.loadFromStorage();
        
        this.setupEventListeners();
        
        // ëª¨ë“œ ë³µì› (ë²„íŠ¼ì´ ìƒì„±ëœ í›„ì— ì‹¤í–‰)
        const savedMode = localStorage.getItem('trackEditor_mode');
        if (savedMode) {
          this.setMode(savedMode);
        }
        
        this.updateCodeOutput();
        
        // ì´ˆê¸° ë Œë”ë§ì€ ì•½ê°„ ì§€ì—°í•˜ì—¬ DOMì´ ì™„ì „íˆ ë¡œë“œëœ í›„ ìˆ˜í–‰
        // requestAnimationFrameì„ ì‚¬ìš©í•˜ì—¬ ë¸Œë¼ìš°ì €ê°€ ì¤€ë¹„ëœ í›„ ë Œë”ë§
        requestAnimationFrame(() => {
          // ìº”ë²„ìŠ¤ í¬ê¸° ì¬í™•ì¸
          this.resizeCanvas();
          
          // ì €ì¥ëœ ì¤Œ ìƒíƒœê°€ ìˆìœ¼ë©´ ë³µì›, ì—†ìœ¼ë©´ resetView í˜¸ì¶œ
          // (loadFromStorageì—ì„œ ì´ë¯¸ ë³µì›ë˜ì—ˆì„ ìˆ˜ ìˆì§€ë§Œ, ìº”ë²„ìŠ¤ í¬ê¸°ê°€ ì¤€ë¹„ëœ í›„ ë‹¤ì‹œ í™•ì¸)
          const savedZoom = localStorage.getItem('trackEditor_zoom');
          const savedOffsetX = localStorage.getItem('trackEditor_offsetX');
          const savedOffsetY = localStorage.getItem('trackEditor_offsetY');
          if (savedZoom && savedOffsetX !== null && savedOffsetY !== null) {
            // ì €ì¥ëœ ì¹´ë©”ë¼ ìœ„ì¹˜ì™€ ì¤Œ ë³µì›
            this.zoom = parseFloat(savedZoom);
            this.offsetX = parseFloat(savedOffsetX);
            this.offsetY = parseFloat(savedOffsetY);
          } else {
            // ì €ì¥ëœ ìƒíƒœê°€ ì—†ìœ¼ë©´ ì´ˆê¸° ë·°ë¡œ ë¦¬ì…‹ (ì´ˆê¸° ë¡œë“œ ì‹œì—ëŠ” ì €ì¥í•˜ì§€ ì•ŠìŒ)
            this.resetView(true);
          }
          
          // ì¦‰ì‹œ ë Œë”ë§
          this.render();
          
          // ì¶”ê°€ë¡œ í•œ ë²ˆ ë” ë Œë”ë§ (ìº”ë²„ìŠ¤ê°€ ì™„ì „íˆ ì¤€ë¹„ëœ í›„)
          setTimeout(() => {
            // ìº”ë²„ìŠ¤ í¬ê¸°ê°€ ë³€ê²½ë˜ì—ˆì„ ìˆ˜ ìˆìœ¼ë¯€ë¡œ ì¬í™•ì¸
            const prevCanvasWidth = this.canvas.width;
            const prevCanvasHeight = this.canvas.height;
            this.resizeCanvas();
            
            // ìº”ë²„ìŠ¤ í¬ê¸°ê°€ ë³€ê²½ëœ ê²½ìš° ì €ì¥ëœ ì˜¤í”„ì…‹ ê°’ ì¡°ì •
            if (prevCanvasWidth !== this.canvas.width || prevCanvasHeight !== this.canvas.height) {
              const savedZoom2 = localStorage.getItem('trackEditor_zoom');
              const savedOffsetX2 = localStorage.getItem('trackEditor_offsetX');
              const savedOffsetY2 = localStorage.getItem('trackEditor_offsetY');
              if (savedZoom2 && savedOffsetX2 && savedOffsetY2) {
                // ì €ì¥ëœ ê°’ì„ ë‹¤ì‹œ ë³µì› (ìº”ë²„ìŠ¤ í¬ê¸° ë³€ê²½ í›„)
                this.zoom = parseFloat(savedZoom2);
                this.offsetX = parseFloat(savedOffsetX2);
                this.offsetY = parseFloat(savedOffsetY2);
              }
            }
            
            this.render();
          }, 50);
        });
      }
      
      // localStorageì— ì €ì¥
      saveToStorage() {
        window.TrackEditorTrackManager.saveToStorage(this);
      }
      
      // localStorageì—ì„œ ë³µì›
      loadFromStorage() {
        window.TrackEditorTrackManager.loadFromStorage(this);
      }

      resizeCanvas() {
        const container = this.canvas.parentElement;
        const rect = container.getBoundingClientRect();
        this.canvas.width = rect.width;
        this.canvas.height = rect.height;
        
        // ë¯¸ë‹ˆë§µ ìº”ë²„ìŠ¤ í¬ê¸° ì„¤ì •
        if (this.minimapCanvas) {
          this.minimapCanvas.width = 200;
          this.minimapCanvas.height = 150;
        }
      }

      setupEventListeners() {
        window.TrackEditorEventHandler.setupEventListeners(this);
      }

      setMode(mode) {
        window.TrackEditorUIManager.setMode(this, mode);
      }

      togglePreview() {
        window.TrackEditorUIManager.togglePreview(this);
      }

      // ìº”ë²„ìŠ¤ ì¢Œí‘œë¥¼ ì›”ë“œ ì¢Œí‘œë¡œ ë³€í™˜
      canvasToWorld(canvasX, canvasY) {
        return window.TrackEditorUtils.canvasToWorld(canvasX, canvasY, this.offsetX, this.offsetY, this.zoom);
      }
      
      // ì›”ë“œ ì¢Œí‘œë¥¼ ìº”ë²„ìŠ¤ ì¢Œí‘œë¡œ ë³€í™˜
      worldToCanvas(worldX, worldY) {
        return window.TrackEditorUtils.worldToCanvas(worldX, worldY, this.offsetX, this.offsetY, this.zoom);
      }
      
      getCanvasPoint(e, round = true) {
        return window.TrackEditorUtils.getCanvasPoint(e, this.canvas, this.offsetX, this.offsetY, this.zoom, round);
      }

      findPointAt(x, y, radius = 10) {
        return window.TrackEditorUtils.findPointAt(x, y, this.points, radius);
      }
      
      // íŠ¸ë™ ì¤‘ì‹¬ì„ ì— ê°€ì¥ ê°€ê¹Œìš´ ì  ì°¾ê¸° (ìŠ¤ëƒ…ìš©)
      snapToTrackCenter(x, y) {
        return window.TrackEditorUtils.snapToTrackCenter(x, y, this.points);
      }
      
      // ì²´í¬í¬ì¸íŠ¸ ê°ë„ ê³„ì‚° (ê°€ì¥ ê°€ê¹Œìš´ íŠ¸ë™ í¬ì¸íŠ¸ì˜ ë°©í–¥)
      calculateCheckpointAngle(x, y) {
        return window.TrackEditorUtils.calculateCheckpointAngle(x, y, this.points);
      }
      
      // ì²´í¬í¬ì¸íŠ¸ ì°¾ê¸°
      findCheckpointAt(x, y, radius = 15) {
        return window.TrackEditorUtils.findCheckpointAt(x, y, this.checkpoints, radius);
      }
      
      // ì¶œë°œ ìœ„ì¹˜ ì°¾ê¸°
      findSpawnAt(x, y, radius = 15) {
        return window.TrackEditorUtils.findSpawnAt(x, y, this.spawnPositions, radius);
      }
      
    // ì‹œì‘ì„  ì°¾ê¸° (íŠ¸ë™ ì „ì²´ë¥¼ ê°€ë¡œì§€ë¥´ëŠ” ì‹œì‘ì„ )
    findStartLineAt(x, y, threshold = 30) {
        const trackWidth = parseInt(document.getElementById('trackWidth')?.value || '120') || 120;
        return window.TrackEditorUtils.findStartLineAt(x, y, this.startLine, trackWidth, threshold);
    }

      
      // ì—°ì„ ì°¾ê¸°
      // ì—°ì„ ê°ì§€ - ê²½ë¡œ ê¸°ë°˜
      findKerbAt(x, y, threshold = 30) {
        return window.TrackEditorUtils.findKerbAt(x, y, this.curbs, threshold);
      }
      
      // ê°€ì¥ ê°€ê¹Œìš´ íŠ¸ë™ ê²½ê³„ ì°¾ê¸° (ì—°ì„ ë°°ì¹˜ìš©) - ê°œì„ ëœ ë²„ì „
      findNearestTrackBoundary(x, y, kerbLength = 300, isDragging = false) {
        const trackWidth = parseInt(document.getElementById('trackWidth')?.value || '120') || 120;
        return window.TrackEditorUtils.findNearestTrackBoundary(x, y, this.points, trackWidth, kerbLength, isDragging, this);
      }
      
      // ìºì‹œ ë¬´íš¨í™” (í¬ì¸íŠ¸ ë³€ê²½ ì‹œ í˜¸ì¶œ)
      invalidatePathCache() {
        this._smoothPathCache = null;
        this._trackBoundsCache = null;
        this._pointsHash = null;
      }
      
      // ê²½ë¡œì—ì„œ ì§€ì •ëœ ê¸¸ì´ë§Œí¼ì˜ ì„¸ê·¸ë¨¼íŠ¸ ì¶”ì¶œ (ì„¸ë°€í•œ ìœ„ì¹˜ ê³ ë ¤)
      extractPathSegment(path, startIndex, targetLength, t = 0) {
        return window.TrackEditorUtils.extractPathSegment(path, startIndex, targetLength, t);
      }

      handleCanvasClick(e) {
        const point = this.getCanvasPoint(e);
        
        if (this.mode === 'add') {
          this.addPoint(point.x, point.y);
        } else if (this.mode === 'delete') {
          const index = this.findPointAt(point.x, point.y);
          if (index >= 0) {
            this.deletePoint(index);
          }
        } else if (this.mode === 'addCheckpoint') {
          // ê°€ì¥ ê°€ê¹Œìš´ í¬ì¸íŠ¸ì˜ ê°ë„ ê³„ì‚°
          const angle = this.calculateCheckpointAngle(point.x, point.y);
          this.addCheckpoint(point.x, point.y, angle);
        } else if (this.mode === 'deleteCheckpoint') {
          const index = this.findCheckpointAt(point.x, point.y);
          if (index >= 0) {
            this.deleteCheckpoint(index);
          }
        } else if (this.mode === 'addKerb') {
          console.log('addKerb mode, point:', point);
          // ê¸°ë³¸ ì—°ì„ ê¸¸ì´ 300
          const kerbLength = 300;
          this.addKerb(point.x, point.y, kerbLength);
        } else if (this.mode === 'deleteKerb') {
          const index = this.findKerbAt(point.x, point.y);
          if (index >= 0) {
            this.deleteKerb(index);
          }
        } else if (this.mode === 'addSpawn') {
          this.addSpawn(point.x, point.y);
        } else if (this.mode === 'deleteSpawn') {
          const index = this.findSpawnAt(point.x, point.y);
          if (index >= 0) {
            this.deleteSpawn(index);
          }
        } else if (this.mode === 'setStartLine') {
          // ì‹œì‘ì„  ì„¤ì •: í´ë¦­í•œ ìœ„ì¹˜ë¥¼ íŠ¸ë™ ì¤‘ì‹¬ì„ ì— ìŠ¤ëƒ…, ê°ë„ëŠ” ê°€ì¥ ê°€ê¹Œìš´ íŠ¸ë™ í¬ì¸íŠ¸ì˜ ë°©í–¥ìœ¼ë¡œ ê³„ì‚°
          const snappedPoint = this.snapToTrackCenter(point.x, point.y);
          const angle = this.calculateCheckpointAngle(snappedPoint.x, snappedPoint.y);
          this.startLine = { x: snappedPoint.x, y: snappedPoint.y, angle: angle };
          if (document.getElementById('startLineX')) document.getElementById('startLineX').value = snappedPoint.x;
          if (document.getElementById('startLineY')) document.getElementById('startLineY').value = snappedPoint.y;
          if (document.getElementById('startLineAngle')) document.getElementById('startLineAngle').value = angle.toFixed(3);
          if (document.getElementById('startLineAngleDeg')) document.getElementById('startLineAngleDeg').value = Math.round(angle * 180 / Math.PI);
          this.updateCodeOutput();
          this.saveToStorage();
          this.render();
        } else if (this.mode === 'deleteStartLine') {
          if (this.findStartLineAt(point.x, point.y)) {
            this.startLine = { x: 0, y: 0, angle: 0 };
            if (document.getElementById('startLineX')) document.getElementById('startLineX').value = 0;
            if (document.getElementById('startLineY')) document.getElementById('startLineY').value = 0;
            if (document.getElementById('startLineAngle')) document.getElementById('startLineAngle').value = '0.000';
            if (document.getElementById('startLineAngleDeg')) document.getElementById('startLineAngleDeg').value = '0';
            this.updateCodeOutput();
            this.saveToStorage();
            this.render();
          }
        }
      }

      handleMouseDown(e) {
        // ìš°í´ë¦­ ë˜ëŠ” ìŠ¤í˜ì´ìŠ¤ë°” + ë“œë˜ê·¸ë¡œ íŒ¬
        if (e.button === 2 || (e.button === 0 && e.spaceKey)) {
          this.isPanning = true;
          this.panStartX = e.clientX;
          this.panStartY = e.clientY;
          this.panStartOffsetX = this.offsetX;
          this.panStartOffsetY = this.offsetY;
          this.canvas.style.cursor = 'grabbing';
          return;
        }
        
        const point = this.getCanvasPoint(e);
        
        if (this.mode === 'move') {
          this.draggingPointIndex = this.findPointAt(point.x, point.y);
          if (this.draggingPointIndex >= 0) {
            this.selectedPointIndex = this.draggingPointIndex;
            this.selectedCheckpointIndex = -1;
            this.updatePointList();
            this.updateSelectedPointInfo();
            this.updateCheckpointList();
            this.updateSelectedCheckpointInfo();
          }
        } else if (this.mode === 'moveCheckpoint') {
          this.draggingCheckpointIndex = this.findCheckpointAt(point.x, point.y);
          if (this.draggingCheckpointIndex >= 0) {
            this.selectedCheckpointIndex = this.draggingCheckpointIndex;
            this.selectedPointIndex = -1;
            this.selectedKerbIndex = -1;
            this.updatePointList();
            this.updateSelectedPointInfo();
            this.updateCheckpointList();
            this.updateSelectedCheckpointInfo();
            this.updateKerbList();
            this.updateSelectedKerbInfo();
          }
        } else if (this.mode === 'moveKerb') {
          this.draggingKerbIndex = this.findKerbAt(point.x, point.y);
          if (this.draggingKerbIndex >= 0) {
            this.selectedKerbIndex = this.draggingKerbIndex;
            this.selectedPointIndex = -1;
            this.selectedCheckpointIndex = -1;
            this.updatePointList();
            this.updateSelectedPointInfo();
            this.updateCheckpointList();
            this.updateSelectedCheckpointInfo();
            this.updateKerbList();
            this.updateSelectedKerbInfo();
          }
        } else if (this.mode === 'moveSpawn') {
          this.draggingSpawnIndex = this.findSpawnAt(point.x, point.y);
          if (this.draggingSpawnIndex >= 0) {
            this.selectedSpawnIndex = this.draggingSpawnIndex;
            this.selectedPointIndex = -1;
            this.selectedCheckpointIndex = -1;
            this.selectedKerbIndex = -1;
            this.updatePointList();
            this.updateSelectedPointInfo();
            this.updateCheckpointList();
            this.updateSelectedCheckpointInfo();
            this.updateKerbList();
            this.updateSelectedKerbInfo();
            this.updateSpawnList();
            this.updateSelectedSpawnInfo();
          }
        } else if (this.mode === 'moveStartLine') {
          if (this.findStartLineAt(point.x, point.y)) {
            this.draggingStartLine = true;
          }
        }
      }

      handleMouseMove(e) {
        // íŒ¬ ì¤‘ì¼ ë•Œ
        if (this.isPanning) {
          const deltaX = e.clientX - this.panStartX;
          const deltaY = e.clientY - this.panStartY;
          this.offsetX = this.panStartOffsetX + deltaX;
          this.offsetY = this.panStartOffsetY + deltaY;
          this.saveToStorage(); // ì €ì¥ (throttle í•„ìš”í•  ìˆ˜ ìˆìŒ)
          this.render();
          return;
        }
        
        // ì‚­ì œ/ì´ë™ ëª¨ë“œì¼ ë•Œ í˜¸ë²„ ê°€ëŠ¥í•œ í•­ëª© ê°ì§€ ë° ì»¤ì„œ ë³€ê²½
        const point = this.getCanvasPoint(e);
        let cursorChanged = false;
        
        if (this.mode === 'delete' || this.mode === 'move') {
          const pointIndex = this.findPointAt(point.x, point.y);
          if (pointIndex >= 0) {
            if (this.hoveredPointIndex !== pointIndex) {
              this.hoveredPointIndex = pointIndex;
              this.canvas.style.cursor = this.mode === 'delete' ? 'pointer' : 'move';
              cursorChanged = true;
              this.render();
            }
          } else if (this.hoveredPointIndex >= 0) {
            this.hoveredPointIndex = -1;
            this.canvas.style.cursor = this.mode === 'delete' ? 'not-allowed' : 'move';
            cursorChanged = true;
            this.render();
          }
        } else if (this.mode === 'deleteCheckpoint' || this.mode === 'moveCheckpoint') {
          const checkpointIndex = this.findCheckpointAt(point.x, point.y);
          if (checkpointIndex >= 0) {
            if (this.hoveredCheckpointIndex !== checkpointIndex) {
              this.hoveredCheckpointIndex = checkpointIndex;
              this.canvas.style.cursor = this.mode === 'deleteCheckpoint' ? 'pointer' : 'move';
              cursorChanged = true;
              this.render();
            }
          } else if (this.hoveredCheckpointIndex >= 0) {
            this.hoveredCheckpointIndex = -1;
            this.canvas.style.cursor = this.mode === 'deleteCheckpoint' ? 'not-allowed' : 'move';
            cursorChanged = true;
            this.render();
          }
        } else if (this.mode === 'deleteKerb' || this.mode === 'moveKerb') {
          const kerbIndex = this.findKerbAt(point.x, point.y);
          if (kerbIndex >= 0) {
            if (this.hoveredKerbIndex !== kerbIndex) {
              this.hoveredKerbIndex = kerbIndex;
              this.canvas.style.cursor = this.mode === 'deleteKerb' ? 'pointer' : 'move';
              cursorChanged = true;
              this.render();
            }
          } else if (this.hoveredKerbIndex >= 0) {
            this.hoveredKerbIndex = -1;
            this.canvas.style.cursor = this.mode === 'deleteKerb' ? 'not-allowed' : 'move';
            cursorChanged = true;
            this.render();
          }
        } else if (this.mode === 'deleteSpawn' || this.mode === 'moveSpawn') {
          const spawnIndex = this.findSpawnAt(point.x, point.y);
          if (spawnIndex >= 0) {
            if (this.hoveredSpawnIndex !== spawnIndex) {
              this.hoveredSpawnIndex = spawnIndex;
              this.canvas.style.cursor = this.mode === 'deleteSpawn' ? 'pointer' : 'move';
              cursorChanged = true;
              this.render();
            }
          } else if (this.hoveredSpawnIndex >= 0) {
            this.hoveredSpawnIndex = -1;
            this.canvas.style.cursor = this.mode === 'deleteSpawn' ? 'not-allowed' : 'move';
            cursorChanged = true;
            this.render();
          }
        } else if (this.mode === 'deleteStartLine' || this.mode === 'moveStartLine') {
          const isHovered = this.findStartLineAt(point.x, point.y);
          if (isHovered !== this.hoveredStartLine) {
            this.hoveredStartLine = isHovered;
            this.canvas.style.cursor = this.mode === 'deleteStartLine' ? 'pointer' : 'move';
            cursorChanged = true;
            this.render();
          }
        } else {
          // ë‹¤ë¥¸ ëª¨ë“œì¼ ë•Œ í˜¸ë²„ ìƒíƒœ ì´ˆê¸°í™”
          if (this.hoveredPointIndex >= 0 || this.hoveredCheckpointIndex >= 0 || this.hoveredKerbIndex >= 0 || this.hoveredSpawnIndex >= 0 || this.hoveredStartLine) {
            this.hoveredPointIndex = -1;
            this.hoveredCheckpointIndex = -1;
            this.hoveredKerbIndex = -1;
            this.hoveredSpawnIndex = -1;
            this.hoveredStartLine = false;
            this.render();
          }
        }
        
        if (cursorChanged) {
          return; // ì»¤ì„œ ë³€ê²½ë§Œ í–ˆìœ¼ë©´ ë“œë˜ê·¸ ì²˜ë¦¬í•˜ì§€ ì•ŠìŒ
        }
        
        if (this.draggingPointIndex >= 0 && this.mode === 'move') {
          const point = this.getCanvasPoint(e);
          const currentPoint = this.points[this.draggingPointIndex];
          this.points[this.draggingPointIndex] = { 
            x: point.x, 
            y: point.y, 
            type: currentPoint.type || 'straight' 
          };
          // ê²½ë¡œ ìºì‹œ ë¬´íš¨í™” (í¬ì¸íŠ¸ ì¢Œí‘œê°€ ë³€ê²½ë¨)
          this.invalidatePathCache();
          this.updateSelectedPointInfo();
          this.updateCodeOutput();
          this.saveToStorage(); // ì €ì¥
          this.render();
        } else if (this.draggingCheckpointIndex >= 0 && this.mode === 'moveCheckpoint') {
          const point = this.getCanvasPoint(e);
          const currentCheckpoint = this.checkpoints[this.draggingCheckpointIndex];
          this.checkpoints[this.draggingCheckpointIndex] = {
            x: point.x,
            y: point.y,
            angle: currentCheckpoint.angle || 0
          };
          this.updateSelectedCheckpointInfo();
          this.updateCodeOutput();
          this.saveToStorage(); // ì €ì¥
          this.render();
        } else if (this.draggingKerbIndex >= 0 && this.mode === 'moveKerb') {
          // ì—°ì„ ì´ë™ ì‹œ ë¶€ë“œëŸ¬ìš´ ì´ë™ì„ ìœ„í•´ ë°˜ì˜¬ë¦¼í•˜ì§€ ì•ŠìŒ
          const point = this.getCanvasPoint(e, false);
          const currentKerb = this.curbs[this.draggingKerbIndex];
          // íŠ¸ë™ ê²½ê³„ë¥¼ ë”°ë¼ ìƒˆë¡œìš´ ê²½ë¡œ ìƒì„±
          const kerbLength = currentKerb.length || 300;
          // ë“œë˜ê·¸ ì¤‘ì—ëŠ” ìƒ˜í”Œë§ ê°œìˆ˜ë¥¼ ì¤„ì—¬ì„œ ë¶€ë“œëŸ¬ìš´ ì´ë™ (true = isDragging)
          const boundary = this.findNearestTrackBoundary(point.x, point.y, kerbLength, true);
          
          if (boundary && boundary.kerbPath && boundary.kerbPath.length >= 2) {
            this.curbs[this.draggingKerbIndex] = {
              centerPath: boundary.kerbPath,
              width: currentKerb.width || 20,
              length: kerbLength,
              trackSide: boundary.isInner ? 'inner' : 'outer'
            };
            this.updateSelectedKerbInfo();
            // ë¶€ë“œëŸ¬ìš´ ì´ë™ì„ ìœ„í•´ requestAnimationFrame ì‚¬ìš©
            this.scheduleRender();
            // ì €ì¥ì€ ë“œë˜ê·¸ ì¢…ë£Œ ì‹œì—ë§Œ ìˆ˜í–‰ (ì„±ëŠ¥ ìµœì í™”)
          }
        } else if (this.draggingSpawnIndex >= 0 && this.mode === 'moveSpawn') {
          const point = this.getCanvasPoint(e, false);
          this.spawnPositions[this.draggingSpawnIndex] = {
            x: point.x,
            y: point.y
          };
          this.updateSelectedSpawnInfo();
          this.updateCodeOutput();
          this.saveToStorage();
          this.render();
        } else if (this.draggingStartLine && this.mode === 'moveStartLine') {
          const point = this.getCanvasPoint(e, false);
          // íŠ¸ë™ ì¤‘ì‹¬ì„ ì— ìŠ¤ëƒ…
          const snappedPoint = this.snapToTrackCenter(point.x, point.y);
          // ê°ë„ëŠ” ê°€ì¥ ê°€ê¹Œìš´ íŠ¸ë™ í¬ì¸íŠ¸ì˜ ë°©í–¥ìœ¼ë¡œ ê³„ì‚°
          const angle = this.calculateCheckpointAngle(snappedPoint.x, snappedPoint.y);
          this.startLine = { x: snappedPoint.x, y: snappedPoint.y, angle: angle };
          if (document.getElementById('startLineX')) document.getElementById('startLineX').value = snappedPoint.x;
          if (document.getElementById('startLineY')) document.getElementById('startLineY').value = snappedPoint.y;
          if (document.getElementById('startLineAngle')) document.getElementById('startLineAngle').value = angle.toFixed(3);
          if (document.getElementById('startLineAngleDeg')) document.getElementById('startLineAngleDeg').value = Math.round(angle * 180 / Math.PI);
          this.updateCodeOutput();
          this.saveToStorage();
          this.render();
        }
      }

      handleMouseUp(e) {
        if (this.isPanning) {
          this.isPanning = false;
          const cursorMap = {
            'add': 'crosshair',
            'addCheckpoint': 'crosshair',
            'move': 'move',
            'moveCheckpoint': 'move',
            'delete': 'pointer',
            'deleteCheckpoint': 'pointer'
          };
          this.canvas.style.cursor = cursorMap[this.mode] || 'default';
          this.saveToStorage(); // íŒ¬ ì¢…ë£Œ ì‹œ ì €ì¥
        }
        
        if (this.draggingPointIndex >= 0) {
          this.draggingPointIndex = -1;
        }
        
        if (this.draggingCheckpointIndex >= 0) {
          this.draggingCheckpointIndex = -1;
        }
        
        if (this.draggingKerbIndex >= 0) {
          this.draggingKerbIndex = -1;
          // ë“œë˜ê·¸ ì¢…ë£Œ ì‹œ ì •ë°€í•œ ìœ„ì¹˜ë¡œ ì¬ê³„ì‚° (isDragging=falseë¡œ ìƒ˜í”Œë§ ê°œìˆ˜ 20)
          const point = this.getCanvasPoint(e, false);
          const currentKerb = this.curbs[this.selectedKerbIndex];
          if (currentKerb) {
            const kerbLength = currentKerb.length || 300;
            const boundary = this.findNearestTrackBoundary(point.x, point.y, kerbLength, false);
            if (boundary && boundary.kerbPath && boundary.kerbPath.length >= 2) {
              this.curbs[this.selectedKerbIndex] = {
                centerPath: boundary.kerbPath,
                width: currentKerb.width || 20,
                length: kerbLength,
                trackSide: boundary.isInner ? 'inner' : 'outer'
              };
            }
          }
          this.updateSelectedKerbInfo();
          this.updateCodeOutput();
          this.saveToStorage(); // ë“œë˜ê·¸ ì¢…ë£Œ ì‹œ ì €ì¥
          this.render(); // ìµœì¢… ë Œë”ë§
        }
        
        if (this.draggingSpawnIndex >= 0) {
          this.draggingSpawnIndex = -1;
          this.updateCodeOutput();
          this.saveToStorage(); // ë“œë˜ê·¸ ì¢…ë£Œ ì‹œ ì €ì¥
          this.render(); // ìµœì¢… ë Œë”ë§
        }
        
        if (this.draggingStartLine) {
          this.draggingStartLine = false;
          this.updateCodeOutput();
          this.saveToStorage(); // ë“œë˜ê·¸ ì¢…ë£Œ ì‹œ ì €ì¥
          this.render(); // ìµœì¢… ë Œë”ë§
        }
      }
      
      handleWheel(e) {
        e.preventDefault();
        
        const rect = this.canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;
        
        // ë§ˆìš°ìŠ¤ ì»¤ì„œ ìœ„ì¹˜ì˜ ì›”ë“œ ì¢Œí‘œ ê³„ì‚° (ì¤Œ ë³€ê²½ ì „)
        // canvasToWorld: (canvasX - offsetX) / zoom
        const worldX = (mouseX - this.offsetX) / this.zoom;
        const worldY = (mouseY - this.offsetY) / this.zoom;
        
        // ì¤Œ ë³€ê²½
        const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
        const newZoom = Math.max(0.1, Math.min(5, this.zoom * zoomFactor));
        
        // ë§ˆìš°ìŠ¤ ì»¤ì„œê°€ ê°€ë¦¬í‚¤ëŠ” ì›”ë“œ ì¢Œí‘œê°€ ê°™ì€ í™”ë©´ ìœ„ì¹˜ì— ìˆë„ë¡ ì˜¤í”„ì…‹ ì¡°ì •
        // ìƒˆë¡œìš´ ì˜¤í”„ì…‹ = ë§ˆìš°ìŠ¤ ìœ„ì¹˜ - (ì›”ë“œ ì¢Œí‘œ * ìƒˆë¡œìš´ ì¤Œ)
        this.offsetX = mouseX - worldX * newZoom;
        this.offsetY = mouseY - worldY * newZoom;
        this.zoom = newZoom;
        
        this.saveToStorage(); // ì €ì¥
        this.render();
      }
      
      zoomIn() {
        window.TrackEditorUIManager.zoomIn(this);
      }
      
      zoomOut() {
        window.TrackEditorUIManager.zoomOut(this);
      }
      
      resetView() {
        window.TrackEditorTrackManager.resetView(this);
      }
      
      handleMinimapMouseDown(e) {
        e.preventDefault();
        this.isMinimapDragging = true;
        const rect = this.minimapCanvas.getBoundingClientRect();
        this.minimapDragStartX = e.clientX - rect.left;
        this.minimapDragStartY = e.clientY - rect.top;
        this.minimapCanvas.style.cursor = 'grabbing';
        this.updateMinimapView(this.minimapDragStartX, this.minimapDragStartY);
      }
      
      handleMinimapMouseMove(e) {
        if (!this.isMinimapDragging) return;
        e.preventDefault();
        const rect = this.minimapCanvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        this.updateMinimapView(x, y);
      }
      
      handleMinimapMouseUp(e) {
        if (!this.isMinimapDragging) return;
        this.isMinimapDragging = false;
        this.minimapCanvas.style.cursor = 'pointer';
        this.saveToStorage(); // ì €ì¥
      }
      
      updateMinimapView(x, y) {
        const width = parseInt(document.getElementById('mapWidth')?.value || '4500') || 4500;
        const height = parseInt(document.getElementById('mapHeight')?.value || '3000') || 3000;
        
        // ë¯¸ë‹ˆë§µ ìŠ¤ì¼€ì¼ ê³„ì‚°
        const minimapScaleX = this.minimapCanvas.width / width;
        const minimapScaleY = this.minimapCanvas.height / height;
        const minimapScale = Math.min(minimapScaleX, minimapScaleY);
        
        const mapWidthOnMinimap = width * minimapScale;
        const mapHeightOnMinimap = height * minimapScale;
        const mapOffsetX = (this.minimapCanvas.width - mapWidthOnMinimap) / 2;
        const mapOffsetY = (this.minimapCanvas.height - mapHeightOnMinimap) / 2;
        
        // ë¯¸ë‹ˆë§µ ì¢Œí‘œë¥¼ ì›”ë“œ ì¢Œí‘œë¡œ ë³€í™˜
        const worldX = (x - mapOffsetX) / minimapScale;
        const worldY = (y - mapOffsetY) / minimapScale;
        
        // í´ë¦­í•œ ìœ„ì¹˜ê°€ í™”ë©´ ì¤‘ì•™ì— ì˜¤ë„ë¡ ì˜¤í”„ì…‹ ì¡°ì •
        this.offsetX = this.canvas.width / 2 - worldX * this.zoom;
        this.offsetY = this.canvas.height / 2 - worldY * this.zoom;
        
        this.render();
      }
      
      renderMinimap() {
        if (!this.minimapCanvas || !this.minimapCtx) return;
        
        const width = parseInt(document.getElementById('mapWidth')?.value || '4500') || 4500;
        const height = parseInt(document.getElementById('mapHeight')?.value || '3000') || 3000;
        const trackWidth = parseInt(document.getElementById('trackWidth')?.value || '120') || 120;
        
        const minimapScaleX = this.minimapCanvas.width / width;
        const minimapScaleY = this.minimapCanvas.height / height;
        const minimapScale = Math.min(minimapScaleX, minimapScaleY);
        
        // ë¯¸ë‹ˆë§µ ì´ˆê¸°í™”
        this.minimapCtx.clearRect(0, 0, this.minimapCanvas.width, this.minimapCanvas.height);
        
        // ë°°ê²½
        this.minimapCtx.fillStyle = '#1e4620';
        this.minimapCtx.fillRect(0, 0, this.minimapCanvas.width, this.minimapCanvas.height);
        
        // ë§µ ì˜ì—­ í‘œì‹œ
        const mapWidthOnMinimap = width * minimapScale;
        const mapHeightOnMinimap = height * minimapScale;
        const mapOffsetX = (this.minimapCanvas.width - mapWidthOnMinimap) / 2;
        const mapOffsetY = (this.minimapCanvas.height - mapHeightOnMinimap) / 2;
        
        // ë¯¸ë‹ˆë§µì—ì„œë„ ê²½ê³„ì„ ì„ ë” ëˆˆì— ë„ê²Œ
        this.minimapCtx.strokeStyle = '#00d4ff'; // ë°ì€ íŒŒë€ìƒ‰
        this.minimapCtx.lineWidth = 2;
        this.minimapCtx.strokeRect(mapOffsetX, mapOffsetY, mapWidthOnMinimap, mapHeightOnMinimap);
        
        // íŠ¸ë™ ê·¸ë¦¬ê¸°
        if (this.previewMode && this.points.length >= 2) {
          const smoothCenterPath = this.getSmoothPath(this.points, 100);
          const { innerPath, outerPath } = this.getTrackBounds(smoothCenterPath, trackWidth);
          const smoothInnerPath = this.getSmoothPath(innerPath, 100);
          const smoothOuterPath = this.getSmoothPath(outerPath, 100);
          
          // íŠ¸ë™ ì±„ìš°ê¸°
          this.minimapCtx.fillStyle = '#4a4a4a';
          this.minimapCtx.beginPath();
          if (smoothOuterPath.length > 0) {
            const p0 = smoothOuterPath[0];
            this.minimapCtx.moveTo(mapOffsetX + p0.x * minimapScale, mapOffsetY + p0.y * minimapScale);
            for (let i = 1; i < smoothOuterPath.length; i++) {
              const p = smoothOuterPath[i];
              this.minimapCtx.lineTo(mapOffsetX + p.x * minimapScale, mapOffsetY + p.y * minimapScale);
            }
            if (this.points.length > 2) {
              this.minimapCtx.closePath();
            }
          }
          if (smoothInnerPath.length > 0 && this.points.length > 2) {
            const p0 = smoothInnerPath[0];
            this.minimapCtx.moveTo(mapOffsetX + p0.x * minimapScale, mapOffsetY + p0.y * minimapScale);
            for (let i = smoothInnerPath.length - 1; i >= 0; i--) {
              const p = smoothInnerPath[i];
              this.minimapCtx.lineTo(mapOffsetX + p.x * minimapScale, mapOffsetY + p.y * minimapScale);
            }
            this.minimapCtx.closePath();
          }
          this.minimapCtx.fill('evenodd');
          
          // ì¤‘ì•™ì„ 
          this.minimapCtx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
          this.minimapCtx.lineWidth = 1;
          this.minimapCtx.beginPath();
          if (smoothCenterPath.length > 0) {
            const p0 = smoothCenterPath[0];
            this.minimapCtx.moveTo(mapOffsetX + p0.x * minimapScale, mapOffsetY + p0.y * minimapScale);
            for (let i = 1; i < smoothCenterPath.length; i++) {
              const p = smoothCenterPath[i];
              this.minimapCtx.lineTo(mapOffsetX + p.x * minimapScale, mapOffsetY + p.y * minimapScale);
            }
            if (this.points.length > 2) {
              this.minimapCtx.closePath();
            }
          }
          this.minimapCtx.stroke();
        } else if (this.points.length >= 2) {
          // í¸ì§‘ ëª¨ë“œ: í¬ì¸íŠ¸ë§Œ í‘œì‹œ
          this.minimapCtx.strokeStyle = '#00ff88';
          this.minimapCtx.lineWidth = 1;
          this.minimapCtx.beginPath();
          const p0 = this.points[0];
          this.minimapCtx.moveTo(mapOffsetX + p0.x * minimapScale, mapOffsetY + p0.y * minimapScale);
          for (let i = 1; i < this.points.length; i++) {
            const p = this.points[i];
            this.minimapCtx.lineTo(mapOffsetX + p.x * minimapScale, mapOffsetY + p.y * minimapScale);
          }
          if (this.points.length > 2) {
            this.minimapCtx.closePath();
          }
          this.minimapCtx.stroke();
        }
        
        // í¬ì¸íŠ¸ í‘œì‹œ
        this.points.forEach((p, i) => {
          const x = mapOffsetX + p.x * minimapScale;
          const y = mapOffsetY + p.y * minimapScale;
          this.minimapCtx.fillStyle = i === this.selectedPointIndex ? '#00ff88' : '#fff';
          this.minimapCtx.beginPath();
          this.minimapCtx.arc(x, y, 2, 0, Math.PI * 2);
          this.minimapCtx.fill();
        });
        
        // í˜„ì¬ ë·°í¬íŠ¸ í‘œì‹œ
        const viewportWorldLeft = -this.offsetX / this.zoom;
        const viewportWorldTop = -this.offsetY / this.zoom;
        const viewportWorldRight = (this.canvas.width - this.offsetX) / this.zoom;
        const viewportWorldBottom = (this.canvas.height - this.offsetY) / this.zoom;
        
        const viewportMinimapX = mapOffsetX + viewportWorldLeft * minimapScale;
        const viewportMinimapY = mapOffsetY + viewportWorldTop * minimapScale;
        const viewportMinimapWidth = (viewportWorldRight - viewportWorldLeft) * minimapScale;
        const viewportMinimapHeight = (viewportWorldBottom - viewportWorldTop) * minimapScale;
        
        this.minimapCtx.strokeStyle = '#00ff88';
        this.minimapCtx.lineWidth = 2;
        this.minimapCtx.strokeRect(viewportMinimapX, viewportMinimapY, viewportMinimapWidth, viewportMinimapHeight);
      }

      addPoint(x, y) {
        window.TrackEditorPointManager.addPoint(this, x, y);
      }
      
      addCheckpoint(x, y, angle = 0) {
        window.TrackEditorCheckpointManager.addCheckpoint(this, x, y, angle);
      }
      
      deleteCheckpoint(index) {
        window.TrackEditorCheckpointManager.deleteCheckpoint(this, index);
      }
      
      addKerb(x, y, length = 300) {
        window.TrackEditorKerbManager.addKerb(this, x, y, length);
      }
      
      deleteKerb(index) {
        window.TrackEditorKerbManager.deleteKerb(this, index);
      }
      
      addSpawn(x, y) {
        window.TrackEditorSpawnManager.addSpawn(this, x, y);
      }
      
      deleteSpawn(index) {
        window.TrackEditorSpawnManager.deleteSpawn(this, index);
      }
      
      selectSpawn(index) {
        window.TrackEditorSpawnManager.selectSpawn(this, index);
      }
      
      updateSpawnList() {
        window.TrackEditorSpawnManager.updateSpawnList(this);
      }
      
      updateSelectedSpawnInfo() {
        window.TrackEditorSpawnManager.updateSelectedSpawnInfo(this);
      }
      
      updateSelectedSpawn() {
        window.TrackEditorSpawnManager.updateSelectedSpawn(this);
      }
      
      selectKerb(index) {
        window.TrackEditorKerbManager.selectKerb(this, index);
      }
      
      updateKerbList() {
        window.TrackEditorKerbManager.updateKerbList(this);
      }
      
      updateSelectedKerbInfo() {
        window.TrackEditorKerbManager.updateSelectedKerbInfo(this);
      }
      
      updateSelectedKerb() {
        window.TrackEditorKerbManager.updateSelectedKerb(this);
      }

      deletePoint(index) {
        window.TrackEditorPointManager.deletePoint(this, index);
      }

      updateSelectedPoint() {
        window.TrackEditorPointManager.updateSelectedPoint(this);
      }

      updateSelectedPointInfo() {
        window.TrackEditorPointManager.updateSelectedPointInfo(this);
      }
      
      setPointType(type) {
        window.TrackEditorPointManager.setPointType(this, type);
      }

      updatePointList() {
        window.TrackEditorPointManager.updatePointList(this);
      }

      selectPoint(index) {
        window.TrackEditorPointManager.selectPoint(this, index);
      }
      
      selectCheckpoint(index) {
        window.TrackEditorCheckpointManager.selectCheckpoint(this, index);
      }
      
      updateCheckpointList() {
        window.TrackEditorCheckpointManager.updateCheckpointList(this);
      }
      
      updateSelectedCheckpointInfo() {
        window.TrackEditorCheckpointManager.updateSelectedCheckpointInfo(this);
      }
      
      updateSelectedCheckpoint() {
        window.TrackEditorCheckpointManager.updateSelectedCheckpoint(this);
      }

      // ì§ì„ ê³¼ ê³¡ì„ ì„ êµ¬ë¶„í•˜ì—¬ ê²½ë¡œ ìƒì„± (ì „í™˜ ì§€ì  ë¶€ë“œëŸ½ê²Œ ì²˜ë¦¬)
      getSmoothPath(points, targetPoints = 400) {
        return window.TrackEditorUtils.getSmoothPath(points, targetPoints);
      }
      
      // ê³¡ì„  ì—°ì„ ê·¸ë¦¬ê¸°
      // ê²½ë¡œ ê¸°ë°˜ ì—°ì„ ê·¸ë¦¬ê¸° - í•˜ë‚˜ì˜ ì—°ì†ëœ í˜•íƒœë¡œ (íŠ¸ë™ ë°”ê¹¥ìª½ì—ë§Œ ë°°ì¹˜)
      drawPathBasedKerb(centerPath, kerbWidth, trackSide = 'outer') {
        window.TrackEditorRenderer.drawPathBasedKerb(this.ctx, centerPath, kerbWidth, trackSide);
      }
      
      // êµ¬í˜• ê³¡ì„  ì—°ì„ ê·¸ë¦¬ê¸° (í•˜ìœ„ í˜¸í™˜ì„±)
      drawCurvedKerb(pathSegment, height, isSelected) {
        window.TrackEditorRenderer.drawCurvedKerb(this.ctx, pathSegment, height, isSelected);
      }

      // íŠ¸ë™ ê²½ê³„ ìƒì„± (ì¤‘ì•™ì„ ì—ì„œ ì¢Œìš°ë¡œ í™•ì¥)
      getTrackBounds(centerPath, trackWidth) {
        return window.TrackEditorUtils.getTrackBounds(centerPath, trackWidth);
      }

      // ë¶€ë“œëŸ¬ìš´ ê²½ë¡œ ê·¸ë¦¬ê¸°
      drawSmoothPath(ctx, path, closed = false) {
        window.TrackEditorRenderer.drawSmoothPath(ctx, path, closed);
      }

      // ë Œë”ë§ ìŠ¤ì¼€ì¤„ë§ (ë¶€ë“œëŸ¬ìš´ ì• ë‹ˆë©”ì´ì…˜ì„ ìœ„í•´)
      scheduleRender() {
        window.TrackEditorRenderer.scheduleRender(this);
      }

      render() {
        if (!this.canvas || !this.ctx) return;
        
        const width = parseInt(document.getElementById('mapWidth')?.value || '4500') || 4500;
        const height = parseInt(document.getElementById('mapHeight')?.value || '3000') || 3000;
        const trackWidth = parseInt(document.getElementById('trackWidth')?.value || '120') || 120;

        // ìº”ë²„ìŠ¤ ì´ˆê¸°í™”
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

        // ë°°ê²½ (ì „ì²´ ìº”ë²„ìŠ¤ ì±„ìš°ê¸°)
        this.ctx.fillStyle = '#1e4620';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        
        // ì¤Œê³¼ ì˜¤í”„ì…‹ ì ìš©
        this.ctx.save();
        this.ctx.translate(this.offsetX, this.offsetY);
        this.ctx.scale(this.zoom, this.zoom);

        // ë§µ ì˜ì—­ í‘œì‹œ (ì¤Œê³¼ ê´€ê³„ì—†ì´ ê³ ì •ëœ ë‘ê»˜) - ë” ëˆˆì— ë„ê²Œ
        // ì™¸ê³½ í…Œë‘ë¦¬ (ë‘êº¼ìš´ ì„ )
        this.ctx.strokeStyle = '#00d4ff'; // ë°ì€ íŒŒë€ìƒ‰
        this.ctx.lineWidth = 4; // ë” ë‘ê»ê²Œ
        this.ctx.setLineDash([]); // ì‹¤ì„ 
        this.ctx.strokeRect(0, 0, width, height);
        
        // ë‚´ë¶€ í…Œë‘ë¦¬ (ì–‡ì€ ì„ ìœ¼ë¡œ ê°•ì¡°)
        this.ctx.strokeStyle = '#ffffff'; // í°ìƒ‰
        this.ctx.lineWidth = 1;
        this.ctx.strokeRect(1, 1, width - 2, height - 2);
        
        // ì½”ë„ˆ ë§ˆì»¤ ì¶”ê°€ (ë” ëª…í™•í•˜ê²Œ)
        const cornerSize = 20;
        this.ctx.fillStyle = '#00d4ff';
        // ì¢Œìƒë‹¨
        this.ctx.fillRect(0, 0, cornerSize, 4);
        this.ctx.fillRect(0, 0, 4, cornerSize);
        // ìš°ìƒë‹¨
        this.ctx.fillRect(width - cornerSize, 0, cornerSize, 4);
        this.ctx.fillRect(width - 4, 0, 4, cornerSize);
        // ì¢Œí•˜ë‹¨
        this.ctx.fillRect(0, height - 4, cornerSize, 4);
        this.ctx.fillRect(0, height - cornerSize, 4, cornerSize);
        // ìš°í•˜ë‹¨
        this.ctx.fillRect(width - cornerSize, height - 4, cornerSize, 4);
        this.ctx.fillRect(width - 4, height - cornerSize, 4, cornerSize);

        if (this.previewMode && this.points.length >= 2) {
          // ë¶€ë“œëŸ¬ìš´ ì¤‘ì•™ì„  ê²½ë¡œ ìƒì„± (ê²Œì„ê³¼ ë™ì¼í•œ ë°©ì‹)
          const smoothCenterPath = this.getSmoothPath(this.points, 200);
          
          // íŠ¸ë™ì˜ ì‹¤ì œ í¬ê¸°ëŠ” ê³ ì •ë˜ì–´ì•¼ í•˜ë¯€ë¡œ, ì¤Œì„ ì ìš©í•˜ê¸° ì „ì— lineWidthë¥¼ ì„¤ì •
          // ì¤Œì´ ì ìš©ë˜ë©´ lineWidthë„ ìŠ¤ì¼€ì¼ë§ë˜ë¯€ë¡œ, ì›í•˜ëŠ” í¬ê¸°ë¥¼ ì¤Œìœ¼ë¡œ ë‚˜ëˆ ì„œ ì„¤ì •
          // í•˜ì§€ë§Œ íŠ¸ë™ í¬ê¸°ë¥¼ ê³ ì •í•˜ë ¤ë©´ lineWidthë¥¼ ì¤Œê³¼ ê´€ê³„ì—†ì´ ê³ ì •ê°’ìœ¼ë¡œ ì„¤ì •
          
          // ê²Œì„ê³¼ ë™ì¼í•œ ë Œë”ë§ ë°©ì‹: stroke ê¸°ë°˜
          // íŠ¸ë™ ì™¸ê³½ì„  (ì§„í•œ íšŒìƒ‰ í…Œë‘ë¦¬) - íŠ¸ë™ í¬ê¸° ê³ ì •
          this.ctx.strokeStyle = '#333';
          this.ctx.lineWidth = (trackWidth + 20); // ì¤Œìœ¼ë¡œ ë‚˜ëˆ„ì§€ ì•ŠìŒ
          this.ctx.lineCap = 'round';
          this.ctx.lineJoin = 'round';
          this.drawSmoothPath(this.ctx, smoothCenterPath, this.points.length > 2);
          this.ctx.stroke();
          
          // íŠ¸ë™ ë³¸ì²´ (ì•„ìŠ¤íŒ”íŠ¸) - íŠ¸ë™ í¬ê¸° ê³ ì •
          const trackGradient = this.ctx.createLinearGradient(0, 0, width, height);
          trackGradient.addColorStop(0, '#3d3d3d');
          trackGradient.addColorStop(0.5, '#4a4a4a');
          trackGradient.addColorStop(1, '#3d3d3d');
          
          this.ctx.strokeStyle = trackGradient;
          this.ctx.lineWidth = trackWidth; // ì¤Œìœ¼ë¡œ ë‚˜ëˆ„ì§€ ì•ŠìŒ
          this.drawSmoothPath(this.ctx, smoothCenterPath, this.points.length > 2);
          this.ctx.stroke();
          
          // íŠ¸ë™ ì¤‘ì•™ì„  (ì ì„ ) - íŠ¸ë™ í¬ê¸° ê³ ì •
          this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
          this.ctx.lineWidth = 2; // ì¤Œìœ¼ë¡œ ë‚˜ëˆ„ì§€ ì•ŠìŒ
          this.ctx.setLineDash([20, 20]); // ì¤Œìœ¼ë¡œ ë‚˜ëˆ„ì§€ ì•ŠìŒ
          this.drawSmoothPath(this.ctx, smoothCenterPath, this.points.length > 2);
          this.ctx.stroke();
          this.ctx.setLineDash([]);
        } else {
          // í¸ì§‘ ëª¨ë“œ: ê²½ë¡œë§Œ í‘œì‹œ (ì¤Œê³¼ ê´€ê³„ì—†ì´ ê³ ì •ëœ ë‘ê»˜)
          if (this.points.length >= 2) {
            // í¸ì§‘ ëª¨ë“œì—ì„œë„ ë¶€ë“œëŸ¬ìš´ ê²½ë¡œ í‘œì‹œ
            const smoothPath = this.getSmoothPath(this.points, 200);
            this.ctx.strokeStyle = '#00ff88';
            this.ctx.lineWidth = 2; // ì¤Œìœ¼ë¡œ ë‚˜ëˆ„ì§€ ì•ŠìŒ
            this.ctx.setLineDash([5, 5]); // ì¤Œìœ¼ë¡œ ë‚˜ëˆ„ì§€ ì•ŠìŒ
            this.drawSmoothPath(this.ctx, smoothPath, this.points.length > 2);
            this.ctx.stroke();
            this.ctx.setLineDash([]);
          }
        }

        // í¬ì¸íŠ¸ ê·¸ë¦¬ê¸° (ì¤Œê³¼ ê´€ê³„ì—†ì´ ê³ ì •ëœ í¬ê¸°)
        this.points.forEach((p, i) => {
          const isSelected = i === this.selectedPointIndex;
          const isHovered = i === this.hoveredPointIndex && (this.mode === 'delete' || this.mode === 'move');
          const radius = isSelected ? 8 : (isHovered ? 10 : 6); // í˜¸ë²„ ì‹œ ë” í¬ê²Œ
          
          // í¬ì¸íŠ¸ íƒ€ì…ì— ë”°ë¼ ìƒ‰ìƒ ë³€ê²½
          const pointColor = p.type === 'curve' ? '#ff6b6b' : '#4ecdc4';
          
          // ì‚­ì œ/ì´ë™ ëª¨ë“œì—ì„œ í˜¸ë²„ ì‹œ ê°•ì¡°
          if (isHovered && this.mode === 'delete') {
            // ë¹¨ê°„ìƒ‰ ì™¸ê³½ ì› (ì‚­ì œ ê°€ëŠ¥ í‘œì‹œ)
            this.ctx.fillStyle = '#ff0000';
            this.ctx.beginPath();
            this.ctx.arc(p.x, p.y, radius + 2, 0, Math.PI * 2);
            this.ctx.fill();
          } else if (isHovered && this.mode === 'move') {
            // ì´ë™ ëª¨ë“œì—ì„œ í˜¸ë²„ ì‹œ ì´ˆë¡ìƒ‰ ì™¸ê³½ ì› (ì´ë™ ê°€ëŠ¥ í‘œì‹œ)
            this.ctx.fillStyle = '#00ff88';
            this.ctx.beginPath();
            this.ctx.arc(p.x, p.y, radius + 2, 0, Math.PI * 2);
            this.ctx.fill();
          }
          
          // ì™¸ê³½ ì›
          this.ctx.fillStyle = isSelected ? '#00ff88' : (isHovered && this.mode === 'delete' ? '#ff6666' : (isHovered && this.mode === 'move' ? '#66ff88' : pointColor));
          this.ctx.beginPath();
          this.ctx.arc(p.x, p.y, radius, 0, Math.PI * 2);
          this.ctx.fill();
          
          // ë‚´ë¶€ ì›
          this.ctx.fillStyle = isSelected ? '#000' : '#333';
          this.ctx.beginPath();
          this.ctx.arc(p.x, p.y, radius - 2, 0, Math.PI * 2); // ì¤Œìœ¼ë¡œ ë‚˜ëˆ„ì§€ ì•ŠìŒ
          this.ctx.fill();
        });
        
        // ì²´í¬í¬ì¸íŠ¸ ê·¸ë¦¬ê¸° (ì¤Œê³¼ ê´€ê³„ì—†ì´ ê³ ì •ëœ í¬ê¸°)
        this.checkpoints.forEach((cp, i) => {
          const isSelected = i === this.selectedCheckpointIndex;
          const isHovered = i === this.hoveredCheckpointIndex && (this.mode === 'deleteCheckpoint' || this.mode === 'moveCheckpoint');
          const radius = isSelected ? 12 : (isHovered ? 14 : 10); // í˜¸ë²„ ì‹œ ë” í¬ê²Œ
          
          // ì‚­ì œ ëª¨ë“œì—ì„œ í˜¸ë²„ ì‹œ ë¹¨ê°„ìƒ‰ ê°•ì¡°
          if (isHovered && this.mode === 'deleteCheckpoint') {
            // ë¹¨ê°„ìƒ‰ ì™¸ê³½ ì› (ì‚­ì œ ê°€ëŠ¥ í‘œì‹œ)
            this.ctx.fillStyle = '#ff0000';
            this.ctx.beginPath();
            this.ctx.arc(cp.x, cp.y, radius + 2, 0, Math.PI * 2);
            this.ctx.fill();
          } else if (isHovered && this.mode === 'moveCheckpoint') {
            // ì´ë™ ëª¨ë“œì—ì„œ í˜¸ë²„ ì‹œ ì´ˆë¡ìƒ‰ ì™¸ê³½ ì› (ì´ë™ ê°€ëŠ¥ í‘œì‹œ)
            this.ctx.fillStyle = '#00ff88';
            this.ctx.beginPath();
            this.ctx.arc(cp.x, cp.y, radius + 2, 0, Math.PI * 2);
            this.ctx.fill();
          }
          
          // ì²´í¬í¬ì¸íŠ¸ëŠ” ê¸ˆìƒ‰ìœ¼ë¡œ í‘œì‹œ
          this.ctx.fillStyle = isSelected ? '#00ff88' : (isHovered && this.mode === 'deleteCheckpoint' ? '#ff6666' : (isHovered && this.mode === 'moveCheckpoint' ? '#66ff88' : '#ffd700'));
          this.ctx.beginPath();
          this.ctx.arc(cp.x, cp.y, radius, 0, Math.PI * 2);
          this.ctx.fill();
          
          // ë‚´ë¶€ ì›
          this.ctx.fillStyle = isSelected ? '#000' : '#333';
          this.ctx.beginPath();
          this.ctx.arc(cp.x, cp.y, radius - 3, 0, Math.PI * 2);
          this.ctx.fill();
          
          // ê°ë„ í‘œì‹œ (í™”ì‚´í‘œ)
          const arrowLength = 20;
          const arrowX = cp.x + Math.cos(cp.angle) * arrowLength;
          const arrowY = cp.y + Math.sin(cp.angle) * arrowLength;
          
          this.ctx.strokeStyle = isSelected ? '#00ff88' : (isHovered && this.mode === 'deleteCheckpoint' ? '#ff6666' : (isHovered && this.mode === 'moveCheckpoint' ? '#66ff88' : '#ffd700'));
          this.ctx.lineWidth = 2;
          this.ctx.beginPath();
          this.ctx.moveTo(cp.x, cp.y);
          this.ctx.lineTo(arrowX, arrowY);
          this.ctx.stroke();
          
          // í™”ì‚´í‘œ ë¨¸ë¦¬
          const arrowAngle1 = cp.angle + Math.PI * 0.8;
          const arrowAngle2 = cp.angle - Math.PI * 0.8;
          const arrowHeadSize = 6;
          this.ctx.beginPath();
          this.ctx.moveTo(arrowX, arrowY);
          this.ctx.lineTo(
            arrowX + Math.cos(arrowAngle1) * arrowHeadSize,
            arrowY + Math.sin(arrowAngle1) * arrowHeadSize
          );
          this.ctx.moveTo(arrowX, arrowY);
          this.ctx.lineTo(
            arrowX + Math.cos(arrowAngle2) * arrowHeadSize,
            arrowY + Math.sin(arrowAngle2) * arrowHeadSize
          );
          this.ctx.stroke();
        });

        // ì¢Œí‘œ í‘œì‹œ (ì¤Œê³¼ ê´€ê³„ì—†ì´ ê³ ì •ëœ í¬ê¸°)
        this.points.forEach((p, i) => {
          if (i === this.selectedPointIndex) {
            this.ctx.fillStyle = '#00ff88';
            this.ctx.font = `12px monospace`; // ì¤Œìœ¼ë¡œ ë‚˜ëˆ„ì§€ ì•ŠìŒ
            this.ctx.fillText(`(${p.x}, ${p.y})`, p.x + 12, p.y - 12); // ì¤Œìœ¼ë¡œ ë‚˜ëˆ„ì§€ ì•ŠìŒ
          }
        });
        
        // ì²´í¬í¬ì¸íŠ¸ ì¢Œí‘œ í‘œì‹œ
        this.checkpoints.forEach((cp, i) => {
          if (i === this.selectedCheckpointIndex) {
            this.ctx.fillStyle = '#ffd700';
            this.ctx.font = `12px monospace`;
            const angleDeg = (cp.angle * 180 / Math.PI).toFixed(0);
            this.ctx.fillText(`CP${i + 1}: (${cp.x}, ${cp.y}) ${angleDeg}Â°`, cp.x + 12, cp.y - 12);
          }
        });
        
        // ì—°ì„ ê·¸ë¦¬ê¸° - ê²½ë¡œ ê¸°ë°˜ (ì¤Œê³¼ ê´€ê³„ì—†ì´ ê³ ì •ëœ í¬ê¸°)
        this.curbs.forEach((kerb, i) => {
          const isSelected = i === this.selectedKerbIndex;
          const isHovered = i === this.hoveredKerbIndex && (this.mode === 'deleteKerb' || this.mode === 'moveKerb');
          
          // ìƒˆë¡œìš´ ê²½ë¡œ ê¸°ë°˜ ì—°ì„
          if (kerb.centerPath && kerb.centerPath.length >= 2) {
            const kerbWidth = kerb.width || 20;
            const trackSide = kerb.trackSide || 'outer';
            
            // ì—°ì„ì„ ê²½ë¡œë¥¼ ë”°ë¼ í•˜ë‚˜ì˜ ì—°ì†ëœ í˜•íƒœë¡œ ê·¸ë¦¬ê¸° (íŠ¸ë™ ë°”ê¹¥ìª½ìœ¼ë¡œë§Œ)
            this.drawPathBasedKerb(kerb.centerPath, kerbWidth, trackSide);
            
            // í˜¸ë²„ ì‹œì—ë§Œ ì „ì²´ í…Œë‘ë¦¬ í‘œì‹œ
            if (isHovered) {
              this.ctx.save();
              let strokeColor = '#00ff88'; // ê¸°ë³¸ ìƒ‰ìƒ (ì´ˆë¡ìƒ‰)
              if (this.mode === 'deleteKerb') {
                strokeColor = '#ff0000'; // ì‚­ì œ ëª¨ë“œ (ë¹¨ê°„ìƒ‰)
              }
              this.ctx.strokeStyle = strokeColor;
              this.ctx.lineWidth = 3;
              
              // ëˆ„ì  ê¸¸ì´ í…Œì´ë¸” ê³„ì‚°
              const cumulative = [0];
              for (let i = 1; i < kerb.centerPath.length; i++) {
                const p1 = kerb.centerPath[i - 1];
                const p2 = kerb.centerPath[i];
                const dx = p2.x - p1.x;
                const dy = p2.y - p1.y;
                cumulative.push(cumulative[i - 1] + Math.hypot(dx, dy));
              }
              const totalLength = cumulative[cumulative.length - 1];
              
              // ê²½ë¡œìƒì˜ íŠ¹ì • ê±°ë¦¬ì—ì„œ ìœ„ì¹˜ì™€ ë²•ì„ ì„ ê³„ì‚°í•˜ëŠ” í•¨ìˆ˜
              const getPointAt = (dist) => {
                const clamped = Math.min(Math.max(dist, 0), totalLength);
                let idx = cumulative.findIndex((len) => len >= clamped);
                if (idx === -1) idx = cumulative.length - 1;
                if (idx === 0) idx = 1;
                
                const p1 = kerb.centerPath[idx - 1];
                const p2 = kerb.centerPath[idx];
                const segLen = cumulative[idx] - cumulative[idx - 1] || 1;
                const t = (clamped - cumulative[idx - 1]) / segLen;
                
                const x = p1.x + (p2.x - p1.x) * t;
                const y = p1.y + (p2.y - p1.y) * t;
                
                const dx = p2.x - p1.x;
                const dy = p2.y - p1.y;
                const len = Math.hypot(dx, dy) || 1;
                
                const nx = -dy / len;
                const ny = dx / len;
                const sign = trackSide === 'inner' ? 1 : -1;
                
                return {
                  track: { x, y },
                  outer: { x: x + nx * kerbWidth * sign, y: y + ny * kerbWidth * sign }
                };
              };
              
              const strokeStep = 0.5; // ë¶€ë“œëŸ¬ìš´ ê³¡ì„ ì„ ìœ„í•œ ê°„ê²©
              
              // íŠ¸ë™ ê²½ê³„ì„  (ì™„ì „íˆ ë¶€ë“œëŸ¬ìš´ ê³¡ì„ )
              this.ctx.beginPath();
              const first = getPointAt(0);
              this.ctx.moveTo(first.track.x, first.track.y);
              for (let d = strokeStep; d <= totalLength; d += strokeStep) {
                const pt = getPointAt(Math.min(d, totalLength));
                this.ctx.lineTo(pt.track.x, pt.track.y);
              }
              const lastTrack = getPointAt(totalLength);
              this.ctx.lineTo(lastTrack.track.x, lastTrack.track.y);
              this.ctx.stroke();
              
              // ë°”ê¹¥ìª½ ê²½ê³„ì„  (ì™„ì „íˆ ë¶€ë“œëŸ¬ìš´ ê³¡ì„ )
              this.ctx.beginPath();
              this.ctx.moveTo(first.outer.x, first.outer.y);
              for (let d = strokeStep; d <= totalLength; d += strokeStep) {
                const pt = getPointAt(Math.min(d, totalLength));
                this.ctx.lineTo(pt.outer.x, pt.outer.y);
              }
              const lastOuter = getPointAt(totalLength);
              this.ctx.lineTo(lastOuter.outer.x, lastOuter.outer.y);
              this.ctx.stroke();
              
              // ì–‘ ë ì—°ê²°ì„ 
              this.ctx.beginPath();
              this.ctx.moveTo(first.track.x, first.track.y);
              this.ctx.lineTo(first.outer.x, first.outer.y);
              this.ctx.moveTo(lastTrack.track.x, lastTrack.track.y);
              this.ctx.lineTo(lastOuter.outer.x, lastOuter.outer.y);
              this.ctx.stroke();
              
              this.ctx.restore();
            }
          }
          // êµ¬í˜• í¬ë§· (í•˜ìœ„ í˜¸í™˜ì„±)
          else if (kerb.x !== undefined && kerb.y !== undefined) {
            const width = kerb.width || 200;
            const height = kerb.height || 20;
            
            // í˜¸ë²„ ì‹œì—ë§Œ ì™¸ê³½ì„  í‘œì‹œ
            if (isHovered) {
              let strokeColor = '#00ff88'; // ê¸°ë³¸ ìƒ‰ìƒ (ì´ˆë¡ìƒ‰)
              if (this.mode === 'deleteKerb') {
                strokeColor = '#ff0000'; // ì‚­ì œ ëª¨ë“œ (ë¹¨ê°„ìƒ‰)
              }
              this.ctx.strokeStyle = strokeColor;
              this.ctx.lineWidth = 3;
              this.ctx.save();
              this.ctx.translate(kerb.x, kerb.y);
              this.ctx.rotate(kerb.angle || 0);
              this.ctx.strokeRect(-width / 2 - 2, -height / 2 - 2, width + 4, height + 4);
              this.ctx.restore();
            }
            
            // ì§ì„  ì—°ì„ ê·¸ë¦¬ê¸°
            this.ctx.save();
            this.ctx.globalCompositeOperation = 'source-over';
            this.ctx.translate(kerb.x, kerb.y);
            this.ctx.rotate(kerb.angle || 0);
            
            const blockWidth = 20;
            const blockCount = Math.floor(width / blockWidth);
            for (let j = 0; j < blockCount; j++) {
              const isRed = j % 2 === 0;
              const color = isRed ? '#ff0000' : '#ffffff';
              this.ctx.fillStyle = color;
              this.ctx.fillRect(-width / 2 + j * blockWidth, -height / 2, blockWidth, height);
            }
            
            // ê²€ì€ìƒ‰ í…Œë‘ë¦¬ ì œê±°ë¨
            this.ctx.restore();
          }
        });
        
// ì‹œì‘ì„  ê·¸ë¦¬ê¸° (ì²´ì»¤í”Œë˜ê·¸ íŒ¨í„´ - íŠ¸ë™ ì „ì²´)
if (this.startLine && (this.startLine.x !== 0 || this.startLine.y !== 0)) {
  const isHovered =
    this.hoveredStartLine &&
    (this.mode === 'deleteStartLine' || this.mode === 'moveStartLine');

  const trackWidth =
    parseInt(document.getElementById('trackWidth')?.value || '120') || 120;
  const halfTrackWidth = trackWidth / 2;

  const perpAngle = this.startLine.angle + Math.PI / 2;
  const cos = Math.cos(perpAngle);
  const sin = Math.sin(perpAngle);

  // ì²´ì»¤ í”Œë˜ê·¸ í¬ê¸° ê³„ì‚° (í˜¸ë²„ ì™¸ê³½ì„ ê³¼ ì²´ì»¤ í”Œë˜ê·¸ ëª¨ë‘ì— ì‚¬ìš©)
  const thickness = 24; // ì‹œì‘ì„  ë‘ê»˜ (ì²´ì»¤ í”Œë˜ê·¸ ê¸¸ì´)
  const blockSize = 14; // ì²´ì»¤ ë¸”ë¡ í¬ê¸° (ë” ì‘ê²Œ í•˜ì—¬ ì •êµí•œ ì¡°ì • ê°€ëŠ¥)
  // íŠ¸ë™ ì „ì²´ ë„ˆë¹„ë³´ë‹¤ ì¡°ê¸ˆ ë” ê¸¸ê²Œ (ê°€ë¡œ ê¸¸ì´ í™•ì¥)
  const extendedWidth = trackWidth * 0.98; // íŠ¸ë™ ë„ˆë¹„ì˜ 104%
  const blockCount = Math.round(extendedWidth / blockSize, 5);
  const actualWidth = blockCount * blockSize; // ì‹¤ì œ ê·¸ë ¤ì§ˆ ë„ˆë¹„ (blockSize ë‹¨ìœ„ë¡œ ì •êµí•˜ê²Œ ì¡°ì •)
  const halfActualWidth = actualWidth / 2;

  // === í˜¸ë²„ ì™¸ê³½ì„  === (ì²´ì»¤ í”Œë˜ê·¸ ì‚¬ê°í˜• ì˜ì—­)
  if (isHovered) {
    this.ctx.save();
    this.ctx.translate(this.startLine.x, this.startLine.y);
    this.ctx.rotate(this.startLine.angle + Math.PI / 2);
    
    this.ctx.strokeStyle =
      this.mode === 'deleteStartLine' ? '#ff0000' : '#00ff88';
    this.ctx.lineWidth = 4;
    this.ctx.setLineDash([]);
    this.ctx.beginPath();
    // ì²´ì»¤ í”Œë˜ê·¸ì˜ ì‚¬ê°í˜• ì™¸ê³½ì„  ê·¸ë¦¬ê¸°
    this.ctx.rect(-halfActualWidth, -thickness / 2, actualWidth, thickness);
    this.ctx.stroke();
    
    this.ctx.restore();
  }

  // === ì²´ì»¤í”Œë˜ê·¸ === (íŠ¸ë™ ì „ì²´, ì‹œì‘ì„  ì¤‘ì‹¬ì´ íŠ¸ë™ ì¤‘ì‹¬)
  this.ctx.save();
  this.ctx.translate(this.startLine.x, this.startLine.y);
  this.ctx.rotate(this.startLine.angle + Math.PI / 2);

  const startX = -halfActualWidth; // ì¤‘ì‹¬ì—ì„œ ì‹œì‘í•˜ì—¬ ì–‘ìª½ìœ¼ë¡œ ê·¸ë¦¬ê¸°
  
  // 2í–‰ìœ¼ë¡œ ê·¸ë¦¬ê¸°
  const rowHeight = thickness / 2;
  
  // ì¤‘ì‹¬ì—ì„œ ì–‘ìª½ìœ¼ë¡œ íŠ¸ë™ ì „ì²´ í­ ê·¸ë¦¬ê¸°
  for (let row = 0; row < 2; row++) {
    for (let i = 0; i < blockCount; i++) {
      const x = startX + i * blockSize;
      const y = -thickness / 2 + row * rowHeight;
      // í–‰ê³¼ ì—´ì˜ í•©ì´ ì§ìˆ˜ë©´ ê²€ì€ìƒ‰, í™€ìˆ˜ë©´ í°ìƒ‰
      const isBlack = (i + row) % 2 === 0;
      this.ctx.fillStyle = isBlack ? '#000' : '#fff';
      this.ctx.fillRect(x, y, blockSize, rowHeight);
    }
  }

  this.ctx.restore();
}

        
        // ì¶œë°œ ìœ„ì¹˜ ê·¸ë¦¬ê¸° (ì¤Œê³¼ ê´€ê³„ì—†ì´ ê³ ì •ëœ í¬ê¸°)
        this.spawnPositions.forEach((spawn, i) => {
          const isSelected = i === this.selectedSpawnIndex;
          const isHovered = i === this.hoveredSpawnIndex && (this.mode === 'deleteSpawn' || this.mode === 'moveSpawn');
          const radius = 8; // ì¶œë°œ ìœ„ì¹˜ ì  í¬ê¸°
          
          // í˜¸ë²„/ì„ íƒ ì‹œ ì™¸ê³½ ì›
          if (isSelected) {
            // ì„ íƒ ì‹œ ë¹¨ê°„ìƒ‰ ì™¸ê³½ ì›
            this.ctx.fillStyle = '#ff0000';
            this.ctx.beginPath();
            this.ctx.arc(spawn.x, spawn.y, radius + 2, 0, Math.PI * 2);
            this.ctx.fill();
          } else if (isHovered && this.mode === 'moveSpawn') {
            // ì´ë™ ëª¨ë“œì—ì„œ í˜¸ë²„ ì‹œ ì´ˆë¡ìƒ‰ ì™¸ê³½ ì› (ì´ë™ ê°€ëŠ¥ í‘œì‹œ)
            this.ctx.fillStyle = '#00ff88';
            this.ctx.beginPath();
            this.ctx.arc(spawn.x, spawn.y, radius + 2, 0, Math.PI * 2);
            this.ctx.fill();
          }
          
          // ì¶œë°œ ìœ„ì¹˜ëŠ” íŒŒë€ìƒ‰ìœ¼ë¡œ í‘œì‹œ
          this.ctx.fillStyle = isSelected ? '#00ff88' : (isHovered && this.mode === 'deleteSpawn' ? '#ff6666' : (isHovered && this.mode === 'moveSpawn' ? '#66ff88' : '#4a9eff'));
          this.ctx.beginPath();
          this.ctx.arc(spawn.x, spawn.y, radius, 0, Math.PI * 2);
          this.ctx.fill();
          
          // ë‚´ë¶€ ì›
          this.ctx.fillStyle = isSelected ? '#000' : '#333';
          this.ctx.beginPath();
          this.ctx.arc(spawn.x, spawn.y, radius - 3, 0, Math.PI * 2);
          this.ctx.fill();
          
          // ì¶œë°œ ë°©í–¥ í‘œì‹œ (í™”ì‚´í‘œ)
          const arrowLength = 20;
          const arrowX = spawn.x + Math.cos(this.spawnAngle) * arrowLength;
          const arrowY = spawn.y + Math.sin(this.spawnAngle) * arrowLength;
          
          this.ctx.strokeStyle = isSelected ? '#00ff88' : (isHovered && this.mode === 'deleteSpawn' ? '#ff6666' : (isHovered && this.mode === 'moveSpawn' ? '#66ff88' : '#4a9eff'));
          this.ctx.lineWidth = 2;
          this.ctx.beginPath();
          this.ctx.moveTo(spawn.x, spawn.y);
          this.ctx.lineTo(arrowX, arrowY);
          this.ctx.stroke();
          
          // í™”ì‚´í‘œ ë¨¸ë¦¬
          const arrowAngle1 = this.spawnAngle + Math.PI * 0.8;
          const arrowAngle2 = this.spawnAngle - Math.PI * 0.8;
          const arrowHeadSize = 6;
          this.ctx.beginPath();
          this.ctx.moveTo(arrowX, arrowY);
          this.ctx.lineTo(
            arrowX + Math.cos(arrowAngle1) * arrowHeadSize,
            arrowY + Math.sin(arrowAngle1) * arrowHeadSize
          );
          this.ctx.moveTo(arrowX, arrowY);
          this.ctx.lineTo(
            arrowX + Math.cos(arrowAngle2) * arrowHeadSize,
            arrowY + Math.sin(arrowAngle2) * arrowHeadSize
          );
          this.ctx.stroke();
        });
        
        // ì¶œë°œ ìœ„ì¹˜ ì¢Œí‘œ í‘œì‹œ
        this.spawnPositions.forEach((spawn, i) => {
          if (i === this.selectedSpawnIndex) {
            this.ctx.fillStyle = '#4a9eff';
            this.ctx.font = `12px monospace`;
            this.ctx.fillText(`ì¶œë°œ${i + 1}: (${Math.round(spawn.x)}, ${Math.round(spawn.y)})`, spawn.x + 12, spawn.y - 12);
          }
        });
        
        // ì—°ì„ ì •ë³´ í‘œì‹œ
        this.curbs.forEach((kerb, i) => {
          if (i === this.selectedKerbIndex) {
            this.ctx.fillStyle = '#ff9500';
            this.ctx.font = `12px monospace`;
            let displayText = `ì—°ì„${i + 1}`;
            let displayX = 0, displayY = 0;
            
            if (kerb.centerPath && kerb.centerPath.length > 0) {
              // ê²½ë¡œ ê¸°ë°˜: ì¤‘ì‹¬ì  í‘œì‹œ
              const midIdx = Math.floor(kerb.centerPath.length / 2);
              displayX = kerb.centerPath[midIdx].x;
              displayY = kerb.centerPath[midIdx].y;
              displayText += `: ${kerb.length || 300}px`;
            } else if (kerb.x !== undefined) {
              // êµ¬í˜• í¬ë§·
              displayX = kerb.x;
              displayY = kerb.y;
              const angleDeg = ((kerb.angle || 0) * 180 / Math.PI).toFixed(0);
              displayText += `: (${kerb.x}, ${kerb.y}) ${angleDeg}Â° ${kerb.width || 200}px`;
            }
            
            this.ctx.fillText(displayText, displayX + 12, displayY - 12);
          }
        });
        
        this.ctx.restore();
        
        // ë¯¸ë‹ˆë§µ ë Œë”ë§
        this.renderMinimap();
      }

      updateCodeOutput() {
        window.TrackEditorCodeGenerator.updateCodeOutput(this);
      }

      copyCode() {
        window.TrackEditorCodeGenerator.copyCode();
      }

      newTrack() {
        window.TrackEditorTrackManager.newTrack(this);
      }
      
      clearTrack() {
        window.TrackEditorTrackManager.clearTrack(this);
      }

      async loadTrack() {
        await window.TrackEditorTrackManager.loadTrack(this);
      }

      updateStatus() {
        window.TrackEditorUIManager.updateStatus(this);
      }
    }

    // í¸ì§‘ê¸° ì´ˆê¸°í™”
    let editor;
    
    // íŠ¸ë™ ê´€ë ¨ í•¨ìˆ˜ê°€ í•„ìš”í•˜ë©´ ë¡œë“œ
    function getTrack(trackId) {
      // ì „ì—­ TRACKS ê°ì²´ì—ì„œ íŠ¸ë™ ê°€ì ¸ì˜¤ê¸°
      if (typeof window.TRACKS !== 'undefined' && window.TRACKS[trackId]) {
        return window.TRACKS[trackId].data;
      }
      return null;
    }
    
    window.addEventListener('load', async () => {
      // íŠ¸ë™ íŒŒì¼ì„ ë¨¼ì € ë¡œë“œ
      const loadScript = (src) => {
        return new Promise((resolve, reject) => {
          // ì´ë¯¸ ë¡œë“œëœ ìŠ¤í¬ë¦½íŠ¸ì¸ì§€ í™•ì¸
          const existingScript = document.querySelector(`script[src="${src}"]`);
          if (existingScript) {
            resolve();
            return;
          }
          
          const script = document.createElement('script');
          script.src = src;
          script.onload = resolve;
          script.onerror = reject;
          document.body.appendChild(script);
        });
      };
      
      // track.jsì™€ íŠ¸ë™ íŒŒì¼ë“¤ì„ ë¡œë“œ
      try {
        await Promise.all([
          loadScript('/js/track.js'),
          loadScript('/js/tracks/basic-circuit.js'),
          loadScript('/js/tracks/monza.js')
        ]);
        // registerTrack í˜¸ì¶œ ì™„ë£Œ ëŒ€ê¸°
        await new Promise(resolve => setTimeout(resolve, 200));
        console.log('íŠ¸ë™ íŒŒì¼ë“¤ì´ ë¡œë“œë˜ì—ˆìŠµë‹ˆë‹¤.', window.TRACKS);
      } catch (error) {
        console.warn('íŠ¸ë™ íŒŒì¼ ë¡œë“œ ì‹¤íŒ¨ (íŠ¸ë™ ë¡œë“œ ê¸°ëŠ¥ ì‚¬ìš© ë¶ˆê°€):', error);
      }
      
      // í¸ì§‘ê¸° ì´ˆê¸°í™”
      editor = new TrackEditor();
    });
  </script>
</body>
</html>

